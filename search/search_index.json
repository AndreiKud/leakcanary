{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"LeakCanary \ud83d\udc24 \u00b6 LeakCanary is a memory leak detection library for Android. LeakCanary\u2019s knowledge of the internals of the Android Framework gives it a unique ability to narrow down the cause of each leak, helping developers dramatically reduce Application Not Responding freezes and OutOfMemoryError crashes. Get started! Quote \u201cA small leak will sink a great ship.\u201d - Benjamin Franklin","title":"Overview"},{"location":"#leakcanary","text":"LeakCanary is a memory leak detection library for Android. LeakCanary\u2019s knowledge of the internals of the Android Framework gives it a unique ability to narrow down the cause of each leak, helping developers dramatically reduce Application Not Responding freezes and OutOfMemoryError crashes. Get started! Quote \u201cA small leak will sink a great ship.\u201d - Benjamin Franklin","title":"LeakCanary \ud83d\udc24"},{"location":"blog-articles/","text":"Memory Leaks in Android Detect memory leaks in your instrumentation tests using LeakCanary 9 ways to avoid memory leaks in Android LeakCanary - Deobfuscation Feature Explained LeakCanary - An in-depth example of Android memory-leaks in MVP architecture Detecting memory leaks in Android applications Your article should be here, please update this list! Any technical level welcome.","title":"Blog Articles"},{"location":"changelog/","text":"Change Log \u00b6 Please thank our contributors \ud83d\ude4f \ud83d\ude4f \ud83d\ude4f. Version 2.10 (2022-11-10) \u00b6 Experimental Neo4j heap dump exploration \u00b6 shark-cli has a new experiment neo4j command that will convert a heap dump into an embedded Neo4j database and then open Neo4j Browser to explore the heap dump. brew install leakcanary-shark shark-cli --process com.example.app.debug neo4j Other bug fixes and improvements \ud83d\udc1b\ud83d\udd28 \u00b6 \ud83d\udc24 #2440 Add Android 13 POST_NOTICICATIONS permission as well as a new LeakCanary.Config.showNotifications config to disable notifications entirely. \ud83d\udc24 #2416 Add Android 13 monochrome icon. \ud83d\udca5 #2371 Fix db crash when navigating heap dump screen. \ud83d\udc1b #2393 Allow LeakCanary to be defined as an AndroidX Startup dependency. \ud83d\udca5 #2430 Fix ShortcutManager crash on Android TV. \ud83d\udca5 #2382 Fix heap dump close crash. This list reflects only a subset of all changes. For more details, see the 2.10 Milestone and the full diff . Version 2.9.1 (2022-04-20) \u00b6 Preface \u00b6 What are some things you\u2019d like to see in a future LeakCanary 3 version? Tell me on Twitter ! Some ideas I\u2019m playing with: Moving heap analysis leak visualisation to a separate single app (written with Compose!) available on the PlayStore. Bumping Okio to 3.0 Multiplatform heap analysis? Analyze a JVM heap dump in your browser?! Visualize the heap dominators / retained size as a treemap. A backend for LeakCanary? Anyway, that\u2019s still very much the future, let\u2019s talk about what\u2019s in 2.9.1 now! New metrics in heap analysis metadata \u00b6 I built LeakCanary to help fix leaks, but in doing so I accidentally wrote a fairly flexible heap dump parser. Since we\u2019re parsing the heap to find leaks anyway, we might as well report additional interesting metrics. Here\u2019s what you\u2019ll now see in the heap dump metadata: Class count: count of loaded classes Instance count Primitive array count Object array count Thread count Heap total bytes Bitmap count Bitmap total bytes Large bitmap count (bitmaps with more pixels than 1.1x the pixels on screen) Large bitmap total bytes SQLiteDatabase in memory (open or closed, as well as their file path) This is just a first pass, feedback and ideas welcome! Performance improvements \u00b6 The heap analysis now traverses the heap dump using RandomAccessFile instead of FileChannel.transferTo() and is now 40% faster on API 23 and 20% faster on newer APIs. Also, sticky class GC roots are now deduplicated, which great reduces the memory footprint of LeakCanary on API 23 ( #2324 ). You can read about the related investigation on py.hashnode.dev . Breaking change: FailTestOnLeakRunListener deleted \u00b6 FailTestOnLeakRunListener , FailTestOnLeak and FailAnnotatedTestOnLeakRunListener were deprecated in LeakCanary 2.8 as they rely on hacking the Android Test library internals which have since changed, and have been replaced by LeakAssertions.assertNoLeak() and the DetectLeaksAfterTestSuccess test rule. I was initially planning of keep these around, but as I tried to increase API level coverage in LeakCanary I needed to upgrade the Android Test library to a more recent version, and the hacks now had compilation errors. So they\u2019re gone: #2282 . If you can\u2019t use the test rules just yet, you\u2019re welcome to copy paste the listener implementations in your own codebase. Other bug fixes and improvements \ud83d\udc1b\ud83d\udd28 \u00b6 \ud83d\udca5 #2367 Fixed AndroidLeakFixes.FLUSH_HANDLER_THREADS ( HandlerThread can have a null Looper ). \ud83d\udca5 #2286 Update Curtains to include Proguard rules and prevent WindowCallbackWrapper crashes. \ud83d\udca5 #2294 Fixed WindowDelegateCallback.onMenuOpened() crash. \ud83d\udc24 #2328 Fixed ToastEventListener leak. Sorry \ud83d\ude2c! \ud83d\udca5 #2310 Fixed crash when using WorkManager < 2.1.0. \ud83d\udca5 #2342 Fixed crash when HashSet.map is null (which isn\u2019t supposed to happen, oh well, Android \ud83e\udd37\u200d\u2642\ufe0f). \ud83d\udc1b #2117 Fixed StrictMode disk read violations. \ud83d\udca5 #2351 Fixed a race causing a startup crash. \ud83d\udca5 #2315 Fixed crash when using Okio 1.14. \ud83d\udc1b #2182 Fixed multi rescheduling of BackgroundListener$checkAppInBackground . \ud83d\udca5 #2360 Fixed SQLiteOpenHelper concurrent creation crash. This list reflects only a subset of all changes. For more details, see the 2.9 Milestone and the full diff . Version 2.8.1 (2022-01-06) \u00b6 This is a bugfix release, a quick follow up to 2.8 which had a few major issues \ud83d\ude05. If you haven\u2019t yet, you should definitely read the 2.8 changelog. Thanks \u00b6 Please thank @dicosta , @Goooler , @plnice , @preetha1326 for their contributions, bug reports and feature requests \ud83d\ude4f \ud83d\ude4f \ud83d\ude4f. Crash fixes \ud83d\udca5\ud83d\udca5\ud83d\udca5 \u00b6 This patch release fixes not 1, not 2, but 3 crashes! \ud83d\udca5 #2268 WorkManager expedited request crashes before API 31. \ud83d\udca5 #2270 Updating LeakCanary.config crashes when AppWatcher is not installed. \ud83d\udca5 #2271 Analysis failure on API 25 because HashMap$Entry became HashMap$HashMapEntry (on API 25) before it finally changed to HashMap$Node . For more details, see the 2.8.1 Milestone and the full diff . Version 2.8 (2022-01-04) \u00b6 Note: please update to 2.8.1 instead. Preface \u00b6 The last release was 9 months ago. What happened?! Well, soon after releasing LeakCanary 2.7, I had my 2 nd baby, a wonderful daughter \ud83d\ude0d. Having 2 young kids leaves a lot less time available for Open Source work\u2026 but it\u2019s worth it! \u2015 P.Y. Thanks \u00b6 Please thank @aaronweihe , @alhah , @Andre-max , @AoraMD , @BraisGabin , @breezenan , @Goooler , @iliaskomp @Jeff11 , @jmnwong , @IdioticMadman , @keyur1sst , @lchen8 , @leinardi , @Maragues , @mars885 , @mateuszkwiecinski , @matiash , @maxxx , @preetha1326 , @SimonMarquis , @slavonnet , @Sonphil , @summerlyr , @SUPERCILEX , @utwyko , @ZacSweers , @ziranshang , @zoltish for their contributions, bug reports and feature requests \ud83d\ude4f \ud83d\ude4f \ud83d\ude4f. Improved support for data structure internals \u00b6 \ud83e\udd13 Inspired by Android Studio , LeakCanary\u2019s node discovery during heap graph traversal is now abstracted away. This allows overlaying logical structure over common data structure internals. \ud83d\ude05 WHAT?! \ud83d\udc49 This means we can make known data structures look more like their APIs than their internals. For example, developers tend to think of setting a HashMap entry as map[\"key\"] = value rather than map.table[hash(\"key\")].next.next.next = Node(value) , which is what LeakCanary would previously show in its leak traces. Let\u2019s look at a HashMap example: class CheckoutController { val tabs = HashMap < String , Tab > () fun addItemsTab ( tab : Tab ) { tabs [ \"ItemsTab\" ] = tab } } If the Tab instance holds on to a view, we might see a leak trace that would look like this: \u2502 ... \u251c\u2500 com.example.CheckoutController instance \u2502 \u2193 CheckoutController.tabs \u251c\u2500 java.util.HashMap instance \u2502 \u2193 HashMap.table \u251c\u2500 java.util.HashMap$Node[] array \u2502 \u2193 HashMap$Node[42] \u251c\u2500 java.util.HashMap$Node instance \u2502 \u2193 HashMap$Node.next \u251c\u2500 java.util.HashMap$Node instance \u2502 \u2193 HashMap$Node.value \u251c\u2500 com.example.Tab instance \u2502 ... With the improved data structure support, the leak trace is much clearer (also note how the ItemsTab string key is now surfaced): \u2502 ... \u251c\u2500 com.example.CheckoutController instance \u2502 \u2193 CheckoutController.tabs \u251c\u2500 java.util.HashMap instance \u2502 \u2193 HashMap[ItemsTab] \u251c\u2500 com.example.Tab instance \u2502 ... Another benefit of this change is that leak signatures become less dependent of the runtime, and therefore are more consistent. This is especially true for any data structure that relies on a linked list ( HashMap , LinkedList , MessageQueue , \u2026). Currently LeakCanary supports a limited set of common data structures from Apache Harmony, Open JDK, and the Android SDK. Let me know what else you need! ObjectAnimator leaks \u00b6 LeakCanary will now detect leaks that trigger when forgetting to cancel ObjectAnimator . This new feature is enabled by the node discovery changes described above! Let\u2019s say you accidentally start an infinite ObjectAnimator and never cancel it, like so: class ExampleActivity : Activity () { override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) setContentView ( R . layout . main_activity ) findViewById < Button > ( R . id . button ). setOnClickListener { view -> ObjectAnimator . ofFloat ( view , View . ALPHA , 0.1f , 0.2f ). apply { duration = 100 repeatMode = ValueAnimator . REVERSE repeatCount = ValueAnimator . INFINITE start () } } } } In previous releases, LeakCanary would detect that the animated view is leaking but it wouldn\u2019t be able to find the leak and instead would report it as an unreachable object: An unreachable object is still in memory but LeakCanary could not find a strong reference path from GC roots. LeakCanary now reports the leak and adds animator state information, helping detect and fix any infinite ObjectAnimator . \u252c\u2500\u2500\u2500 \u2502 GC Root: Thread object \u2502 \u251c\u2500 java.lang.Thread instance \u2502 Leaking: NO (the main thread always runs) \u2502 Thread name: 'main' \u2502 \u2193 Thread.threadLocals \u2502 ~~~~~~~~~~~~ ... \u251c\u2500 android.animation.ObjectAnimator instance \u2502 Leaking: UNKNOWN \u2502 mListeners = null \u2502 mPropertyName = null \u2502 mProperty.mName = alpha \u2502 mProperty.mType = java.lang.Float \u2502 mInitialized = true \u2502 mStarted = true \u2502 mRunning = true \u2502 mAnimationEndRequested = false \u2502 mDuration = 100 \u2502 mStartDelay = 0 \u2502 mRepeatCount = INFINITE (-1) \u2502 mRepeatMode = REVERSE (2) \u2502 \u2193 ObjectAnimator.mTarget \u2502 ~~~~~~~ \u2570\u2192 android.widget.Button instance Leaking: YES (View.mContext references a destroyed activity) To learn more, see this AOSP issue: ObjectAnimator.mTarget weak ref creates memory leaks on infinite animators . Leak detection in tests \u00b6 Previous releases of leakcanary-android-instrumentation introduced a FailTestOnLeakRunListener which could run leak detection after each UI tests. Unfortunately FailTestOnLeakRunListener relied on a hack around androidx.test internals to report failures. The internals keep changing with every androidx.test release and breaking FailTestOnLeakRunListener \ud83d\ude2d. FailTestOnLeakRunListener is now deprecated (\ud83d\udc4b) and replaced by the DetectLeaksAfterTestSuccess test rule, which you can add to your test like any normal test rule. Additionally, you can call LeakAssertions.assertNoLeak() from anywhere in your instrumentation tests. You can also annotate tests with @SkipLeakDetection (for that to work you\u2019ll also need to set up the TestDescriptionHolder test rule). class CartTest { @get : Rule val rules = RuleChain . outerRule ( TestDescriptionHolder ) . around ( DetectLeaksAfterTestSuccess ()) . around ( ActivityScenarioRule ( CartActivity :: class . java )) @Test fun addItemToCart () { // ... } @SkipLeakDetection ( \"See #1234\" ) @Test fun removeItemFromCart () { // ... } } Android 12 \u00b6 Hopefully this time we fixed everything that Android 12 broke: missing exported:true tags, missing pending intent flags, and ForegroundServiceStartNotAllowedException crashes. If not, let us know! Can\u2019t wait for Android 13 to break everything again \ud83e\udd2c. WorkManager \u00b6 Running an Android Service without crashing ( ForegroundServiceStartNotAllowedException \u2026) is becoming harder with every release of Android, so I got rid of the LeakCanary heap analyzer service! Instead, LeakCanary leverages WorkManager if you already have it as a dependency. If you don\u2019t use WorkManager, then LeakCanary will fall back to using a simple thread. Note: I recommend using at least WorkManager 2.7.0 as it adds the WorkRequest.Builder.setExpedited() API which LeakCanarty leverages if available. Multi process \u00b6 Switching to WorkManager also impacts the LeakCanary multi process approach, which now leverages WorkManager remote jobs. Blog on how I got this working: WorkManager multi-process for libraries . Multi process is harder to get right so you should only use this if LeakCanary frequently runs out of memory while performing the heap analysis. Here are the updated set up steps: 1) Add the leakcanary-android-process dependency and keep the leakcanary-android dependency . dependencies { debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.8' debugImplementation 'com.squareup.leakcanary:leakcanary-android-process:2.8' } 2) Skip the initialization code in the Application class class ExampleApplication : Application () { override fun onCreate () { if ( LeakCanaryProcess . isInAnalyzerProcess ( this )) { return } super . onCreate () // normal init goes here, skipped in :leakcanary process. } } That\u2019s it! Note that event listeners (see below) related to the analysis will fire in the remote process. AndroidX App Startup \u00b6 LeakCanary now optionally supports the AndroidX App Startup library . All you need to do is replace the leakcanary-android dependency with leakcanary-android-startup : dependencies { // Remove the normal leakcanary-android dependency // debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.8' debugImplementation 'com.squareup.leakcanary:leakcanary-android-startup:2.8' } Note 1: leakcanary-android adds the code for automatic installl to leakcanary-android-core . If you\u2019re calling AppWatcher.manualInstall() , you can depend directly on leakcanary-android-core instead of leakcanary-android , and you won\u2019t need the disable any automatic install. Note 2: the same principle applies to leakcanary-object-watcher-android : it depends on leakcanary-object-watcher-android-core and adds automatic install, while leakcanary-object-watcher-android-startup leverages the App Startup library. Same for plumber-android , plumber-android-core and plumber-android-startup . Event listeners \u00b6 LeakCanary.Config has a new eventListeners field allowing you to react to LeakCanary\u2019s lifecycle. If you want to customize this, you most likely should be keeping the default list of listeners and add or remove from it. For example, if you want to disable the LeakCanary toast: LeakCanary . config = LeakCanary . config . run { copy ( eventListeners = eventListeners . filter { it !is ToastEventListener } ) } If you want to upload heap analysis results: LeakCanary . config = LeakCanary . config . run { copy ( eventListeners = eventListeners + EventListener { event -> if ( event is HeapAnalysisSucceeded ) { // Upload event.heapAnalysis } } ) } Note: Leakcanary.Config.onHeapAnalyzedListener still works but is now deprecated. Feedback welcome on this new API! Other bug fixes and improvements \ud83d\udc1b\ud83d\udd28 \u00b6 #2096 Opening / sharing heap dump files now supports LeakCanary as an option. #2210 First Compose dedicated object inspectors! #2121 Support for customizing the heap dumper. This list reflects only a subset of all changes. For more details, see the 2.8 Milestone and the full diff . Version 2.7 (2021-03-26) \u00b6 Please thank @chao2zhang , @ihrupin , @jzbrooks , @msfjarvis , @reneargento , @Unpublished for their contributions, bug reports and feature requests \ud83d\ude4f \ud83d\ude4f \ud83d\ude4f. Finer grained root view watching \u00b6 In version 2.6, LeakCanary added detection of root views retained after View.onDetachedFromWindow() . This helps find more leaks, but unfortunately some Android widgets keep a detached root view around to reattach it later (e.g. spinner). App developers also sometimes do the same with dialogs, keeping a single instance around and calling show() and hide() as needed. As a result, LeakCanary would report leaks that were actually not leaks. In version 2.7, the default behavior changed: LeakCanary will continue to detect leaks of toasts, but will ignore root views created by a PopupWindow (which is what Android widgets use). It will also ignore root views created by a dialog by default, and you can turn this back on by setting the leak_canary_watcher_watch_dismissed_dialogs resource boolean to true: <?xml version=\"1.0\" encoding=\"utf-8\"?> <resources> <bool name= \"leak_canary_watcher_watch_dismissed_dialogs\" > true </bool> </resources> This is implemented using a new Square library: Curtains . Targeting Android 12 \u00b6 We fixed two issues for apps that want to target Android 12: #2074 Activities that use intent filters must declare the android:exported attribute. #2079 PendingIntent requires the FLAG_IMMUTABLE flag. Bug fixes and improvements \ud83d\udc1b\ud83d\udd28 \u00b6 #2075 Fixed crash when sharing heap dumps. #2067 Fixed crash when opening leaks from older versions (before 2.6) of LeakCanary. #2049 Fixed Plumber crash due to R8 shaking AndroidLeakFixes. #2084 Fixed Shark crash when used from multiple threads. #2054 \ud83d\ude48\ud83d\ude49\ud83d\ude4a Blocked Monkeys from deleting leaks. #2069 Added X button to the root leak activity (for custom devices with no back button) #2091 Added receiver details if LoadedApk shows up in the leaktrace. #2083 Added service status details (created or not) to leaktrace. #2099 Retry button if analysis fails. #2066 When heap analysis in UI tests is skipped and NoAnalysis is returned, NoAnalysis now includes a reason to help debug why it didn\u2019t run. #2000 The LeakCanary CI now leverages GitHub actions instead of Travis. For more details, see the 2.7 Milestone and the full diff . Version 2.6 - Christmas Release \ud83c\udf84 (2020-12-24) \u00b6 Please thank @chao2zhang , @ChaosLeung , @LitterSun , @mickverm , @opatry , @Thomas-Vos , @tricknology , @rahul-a , @samoylenkodmitry , @sing0055 , @ubiratansoares for their contributions, bug reports and feature requests \ud83d\ude4f \ud83d\ude4f \ud83d\ude4f. This Christmas Release includes several external contributions and a bunch of cool new features! \ud83c\udf81\ud83c\udf81 Detecting root views retained after View.onDetachedFromWindow() \u00b6 On Android, every displayed view hierarchy is attached to a window, whether it be the view hierarchy of an activity, a dialog, a toast or a chat head . After a view hierarchy is detached from its window, it should be garbage collected. LeakCanary already detects leaks of activity view hierarchies because retained detached views reference their activity context and LeakCanary detects activities retained after Activity.onDestroy() . In this new release, LeakCanary will now detect the leak of a dialog view hierarchy as soon as that dialog is dismissed, or any other view that is passed to WindowManager.removeView() . Detecting services retained after Service.onDestroy() \u00b6 After an Android service is destroyed, it should be garbage collected. Unfortunately, the Android SDK does not provide any generic API to observe the service lifecycle. We worked around that using reflection on greylist APIs (details in #2014 ). Let\u2019s hope this motivates the Android team to build the APIs developers need . Configuring retained object detection \u00b6 With the detection of 2 new types of retained objects, we\u2019re also adding APIs to configure which watchers should be installed as well as adding filtering capabilities. First, disable the automatic install: <?xml version=\"1.0\" encoding=\"utf-8\"?> <resources> <bool name= \"leak_canary_watcher_auto_install\" > false </bool> </resources> Then you can install LeakCanary manually. LeakCanary 2.6 comes with 4 watchers installed by default: ActivityWatcher , FragmentAndViewModelWatcher , RootViewWatcher , ServiceWatcher . Here\u2019s an example to get all the default watchers except ServiceWatcher : class DebugExampleApplication : ExampleApplication () { override fun onCreate () { super . onCreate () val watchersToInstall = AppWatcher . appDefaultWatchers ( application ) . filter { it !is ServiceWatcher } AppWatcher . manualInstall ( application = application , watchersToInstall = watchersToInstall ) } } LeakCanary introduces a new functional (SAM) interface implemented by ObjectWatcher : ReachabilityWatcher , with a ReachabilityWatcher.expectWeaklyReachable() method that replaces the now deprecated ObjectWatcher.watch() method. You can create the default watcher instances with a custom ReachabilityWatcher that delegates to AppWatcher.objectWatcher but filters out specific instances (e.g. BadSdkLeakingFragment ): class DebugExampleApplication : ExampleApplication () { override fun onCreate () { super . onCreate () val delegate = ReachabilityWatcher { watchedObject , description -> if ( watchedObject !is BadSdkLeakingFragment ) { AppWatcher . objectWatcher . expectWeaklyReachable ( watchedObject , description ) } } val watchersToInstall = AppWatcher . appDefaultWatchers ( application , delegate ) AppWatcher . manualInstall ( application = application , watchersToInstall = watchersToInstall ) } } With these new configuration options, AppWatcher.config is now deprecated and a no-op. Dumping the heap on screen off \u00b6 The default threshold to dump the heap is 5 retained objects when the app is visible , and 1 retained object when the app is not visible . Up until now, visible meant \u201cthe app has at least one activity in started state\u201d. In LeakCanary 2.6, the app will now be considered not visible if the device screen is off , lowering the threshold to trigger heap dumps when you turn off the device screen. LeakCanary for releases \u00b6 LeakCanary 2.6 introduces a new artifact: leakcanary-android-release . This artifact exposes APIs to run a heap analysis in release builds, in production. Danger Everything about this is experimental. Running a heap analysis in production is not a very common thing to do, and we\u2019re still learning and experimenting with this. Also, both the artifact name and the APIs may change. dependencies { // debugImplementation because LeakCanary should only run in debug builds. debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.6' // NEW: LeakCanary for releases! releaseImplementation 'com.squareup.leakcanary:leakcanary-android-release:2.6' // Optional: detect retained objects. This helps but is not required. releaseImplementation 'com.squareup.leakcanary:leakcanary-object-watcher-android:2.6' } Here\u2019s a code example that runs a heap analysis when the screen is turned off or the app enters background, checking first if a Firebase Remote Config flag is turned on, and uploading the result to Bugsnag: class ReleaseExampleApplication : ExampleApplication () { // Cancels heap analysis if \"heap_analysis_flag\" is false. private val flagInterceptor by lazy { object : HeapAnalysisInterceptor { val remoteConfig : FirebaseRemoteConfig = TODO () override fun intercept ( chain : Chain ): HeapAnalysisJob . Result { if ( remoteConfig . getBoolean ( \"heap_analysis_flag\" )) { chain . job . cancel ( \"heap_analysis_flag false\" ) } return chain . proceed () } } } private val analysisClient by lazy { HeapAnalysisClient ( // Use private app storage. cacheDir is never backed up which is important. heapDumpDirectoryProvider = { cacheDir }, // stripHeapDump: remove all user data from hprof before analysis. config = HeapAnalysisConfig ( stripHeapDump = true ), // Default interceptors may cancel analysis for several other reasons. interceptors = listOf ( flagInterceptor ) + HeapAnalysisClient . defaultInterceptors ( this ) ) } private val analysisExecutor by lazy { Executors . newSingleThreadExecutor { thread ( start = false , name = \"Heap analysis executor\" ) { android . os . Process . setThreadPriority ( THREAD_PRIORITY_BACKGROUND ) it . run () } } } private val analysisCallback : ( Result ) -> Unit by lazy { val uploader = BugsnagHeapAnalysisUploader ( this @ReleaseExampleApplication ) { result -> if ( result is Done ) { uploader . upload ( result . analysis ) } } } override fun onCreate () { super . onCreate () // Delete any remaining heap dump (if we crashed) analysisExecutor . execute { analysisClient . deleteHeapDumpFiles () } // Starts heap analysis on background importance BackgroundTrigger ( application = this , analysisClient = analysisClient , analysisExecutor = analysisExecutor , analysisCallback = analysisCallback ). start () // Starts heap analysis when screen off ScreenOffTrigger ( application = this , analysisClient = analysisClient , analysisExecutor = analysisExecutor , analysisCallback = analysisCallback ). start () } /** * Call this to trigger heap analysis manually, e.g. from * a help button. * * This method returns a `HeapAnalysisJob` on which you can * call `HeapAnalysisJob.cancel()` at any time. */ fun triggerHeapAnalysisNow (): HeapAnalysisJob { val job = analysisClient . newJob () analysisExecutor . execute { val result = job . execute () analysisCallback ( result ) } return job } } The Bugsnag uploader: class BugsnagHeapAnalysisUploader ( applicationContext : Application ) { private val bugsnagClient : Client init { bugsnagClient = Client ( applicationContext , BUGSNAG_API_KEY , DO_NOT_ENABLE_EXCEPTION_HANDLER ) bugsnagClient . setSendThreads ( false ) } fun upload ( heapAnalysis : HeapAnalysis ) { when ( heapAnalysis ) { is HeapAnalysisSuccess -> { val exception = HeapAnalysisReport () bugsnagClient . notify ( exception ) { report -> val metaData = report . error . metaData metaData . addToTab ( \"Heap Analysis\" , \"result\" , heapAnalysis . toString ()) } } is HeapAnalysisFailure -> { // Please file any reported failure to // https://github.com/square/leakcanary/issues bugsnagClient . notify ( heapAnalysis . exception ) } } } // Exception with fake unique stacktrace to send all reports to the same error entry. class HeapAnalysisReport : Exception ( \"Check the HEAP ANALYSIS tab\" ) { override fun fillInStackTrace (): Throwable { stackTrace = arrayOf ( StackTraceElement ( \"HeapAnalysisReport\" , \"analyzeHeap\" , \"HeapAnalysisReport.kt\" , 1 ) ) return this } } companion object { private const val BUGSNAG_API_KEY = YOUR_BUGSNAG_API_KEY private const val DO_NOT_ENABLE_EXCEPTION_HANDLER = false } } More leak fixes in Plumber \u00b6 We added 3 new automatic fixes for known AOSP leaks in plumber-android (details: #1993 ). As a reminder, plumber-android is automatically included when you add leakcanary-android , and you can add it manually for build types that don\u2019t include LeakCanary: dependencies { // leakcanary-android adds plumber-android to debug builds debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.6' // This adds plumber-android to all build types implementation 'com.squareup.leakcanary:plumber-android:2.6' } Bug fixes and improvements \ud83d\udc1b\ud83d\udd28 \u00b6 #1948 Leakcanary is now compiled against Kotlin 1.4 (while staying 1.3 compatible) to support Functional (SAM) interfaces . #1956 The retained object size is displayed as a human readable output (KB, MB, \u2026). #1976 Improved default object inspectors and leak finders for View and Context . #1972 Fields are printed with the parent class name that holds the field in leak traces. #1981 Fixed StrictMode policy violation (main thread read from disk). #1977 Report objects that are not strongly reachable. #2018 & #2019 Fixed crashes in LeakCanary UI (discovered by Monkey tests). #2015 Fixed crash on Android < 16. #2023 Fixed crash in plugin projects. For more details, see the 2.6 Milestone and the full diff . Version 2.5 (2020-10-01) \u00b6 Please thank @Amokrane , @Armaxis , @askont , @chao2zhang , @daniil-shevtsov , @eygraber , @msfjarvis , @mzgreen , @lchen8 , @rpattabi , @sahil2441 , @SylvainGirod , @vhow for their contributions, bug reports and feature requests \ud83d\ude4f \ud83d\ude4f \ud83d\ude4f. Heap analysis is twice as fast \ud83d\udc24\ud83d\udca8 \u00b6 No one asked, so we delivered! We rewrote several core components in Shark (LeakCanary\u2019s heap analyzer) to dramatically reduce IO reads and allocations while keeping memory constant. More details on Twitter: thread by @ArtemChubaryan and thread by @Piwai . Compute retained size within the leak trace \u00b6 Previously, LeakCanary computed the retained size for the leaking object (the last object in the leak trace). However, the bad reference causing objects to leak is often higher up in the leak trace and everything that it holds onto is actually leaking. So LeakCanary now computes the retained size for all the objects in the leaktrace that have a LEAKING or UNKNOWN status : \u252c\u2500\u2500\u2500 \u2502 GC Root: System class \u2502 \u251c\u2500 com.example.MySingleton class \u2502 Leaking: NO (a class is never leaking) \u2502 \u2193 static MySingleton.leakedView \u2502 ~~~~~~~~~~ \u251c\u2500 android.widget.TextView instance \u2502 Leaking: YES (View.mContext references a destroyed activity) \u2502 Retaining 46326 bytes in 942 objects \u2502 \u2193 TextView.mContext \u2570\u2192 com.example.MainActivity instance \u200b Leaking: YES (Activity#mDestroyed is true) \u200b Retaining 1432 bytes in 36 objects Disable LeakCanary from the UI \u00b6 New toggle to disable heap dumping , which can be useful for QA, or when doing a product demo. LeakCanary will still show a notification when an object is retained. Deobfuscating hprof files \u00b6 The Shark CLI can now deobfuscate heap dumps : brew install leakcanary-shark shark-cli --hprof heapdump.hprof -m mapping.txt deobfuscate-hprof Bug fixes and improvements \ud83d\udc1b\ud83d\udd28 \u00b6 Heap analysis text results now wrap to a max width when sharing them from the LeakCanary activity or printing to logcat. This will make it harder to miss details that are lost at the end of long lines of text. The leak_canary_watcher_auto_install , leak_canary_allow_in_non_debuggable_build and leak_canary_plumber_auto_install resource booleans were meant to be public . We sprinkled a few @JvmStatic to help Java consummers . Fixed crash when no browser installed . Use distinct group for LeakCanary notifications . The heap analysis result now includes the heap dump duration because it looks like Android 11 heap dumps are sometimes super slow . We also added more perf related metrics . Disable logging when AppWatcher runs in release builds. Highlight library leak patterns directly within the leak traces . Improved inspections for Context, View and ContextImpl . For more details, see the 2.5 Milestone and the full diff . Version 2.4 (2020-06-10) \u00b6 Please thank @0x109 , @andersu , @antoniomerlin , @bishiboosh , @ckesc , @jrodbx , @LouisCAD , @marcardar , @OlivierGenez , @pyricau , @runningcode , @seljad , @worldsnas for their contributions, bug reports and feature requests. plumber-android is a new artifact that fixes known Android leaks \ud83d\udebd\ud83d\udd27 \u00b6 LeakCanary reports all leaks, including leaks caused by a known bug in 3 rd party code that you do not have control over (reported as Library leaks ). That can be annoying! LeakCanary now ships with a new dependency, plumber-android , which performs hacks at runtime to fix some of these known leaks. This releases has fixes for 11 known leaks , but this is just the beginning. Contributions welcome! \ud83d\ude4f Note that since the leakcanary-android dependency is usually added as a debugImplementation dependency, the plumber-android is transitively added only in debug builds, so it will not fix leaks in your release builds. You can add the dependency directly as implementation to get these fixes in release builds as well: dependencies { implementation 'com.squareup.leakcanary:plumber-android:2.4' } Warning While several of these fixes already ship in release builds of Square apps, this is the first official release of plumber-android , so you should consider it experimental . Analyzing leaks from the CLI is easier than ever \ud83c\udf7a \u00b6 The Shark CLI can now be installed via Homebrew brew install leakcanary-shark You can then look for leaks in apps on any connected device, for example: $ shark-cli --device emulator-5554 --process com.example.app.debug analyze Support for Android Test Orchestrator \ud83c\udfbc \u00b6 If you set up LeakCanary to report test failures when detecting leaks in instrumentation tests, it now works with Android Test Orchestrator as well. No change required, LeakCanary will automatically detect thatAndroid Test Orchestrator is running and hook into it. No more master branch \u00b6 The branch name master comes from the master / slave terminology. We renamed the default branch to main , a small step towards making the LeakCanary community a safer space. Here\u2019s a good thread on this topic . Bug fixes and improvements \ud83d\udc1b\ud83d\udd28 \u00b6 URLs in Library Leak descriptions are now clickable Fixed ordering issues causing improper config with manual setup. A related change is that AppWatcher.Config.enabled is now deprecated. Fixed possible OutOfMemoryError failure when computing retained size: we were loading to memory large arrays from the heap dump just to get their size. For more details, see the 2.4 Milestone and the full diff . Version 2.3 (2020-04-08) \u00b6 This is a minor release on the feature front, but a large release on the documentation front! Many thanks to @adamfit , @Amokrane , @Armaxis , @artnc , @burakeregar , @ClaasJG , @clementcontet , @ckesc , @cketti , @fbenbassat , @Guneetgstar , @Igorxp5 , @JLLeitschuh , @KidAndroid , @ligi , @mzgreen , @pyricau , @sprintuu , @tevjef , @thrlr123 for the contributions, bug reports and feature requests. We asked for help and immediately started seeing more contributions. Thanks all! Check out the How to help page. LeakCanary will now crash in release builds \u00b6 Despite the documentation insisting on using debugImplementation , we\u2019ve seen apps ship LeakCanary in release builds . Mistakes happen, so we\u2019ve made that mistake harder to miss by making LeakCanary crash when included in release builds . Learn More: LeakCanary in release builds . Doc site \ud83d\udec0\ud83d\udca5 \u00b6 The doc site content has changed quite a bit! We applied advice from Google\u2019s tech writing guide . If you\u2019ve been confused by Library Leaks before, check out see the new Categorizing leaks section. Take a look around, let us know what you think. Bug fixes and improvements \ud83d\ude09 \u00b6 The new deobfuscation Gradle plugin wasn\u2019t working with Gradle 3.6 , this is now fixed. Also removed the requirement for the plugin to be applied after AGP . Fixed 2 crashes ( #1768 & #1769 ) in the LeakCanary UI found by a sneaky monkey runner \ud83d\ude48. The LeakCanary UI updates immediately when a heap analysis is added or deleted. Fixed a crash when updating from LeakCanary 2.0 . The About section of the LeakCanary now surfaces whether heap dumping is currently enabled . Fixed process not exiting in SharkCLI on Windows. Improved error message when obfuscation mappings appear to be missing. For more details, see the 2.3 Milestone and the full diff . Version 2.2 (2020-02-05) \u00b6 We\u2019ve got some good stuff for the first release of the decade! Many thanks to @AndroidInternal , @Armaxis , @lic2050 , @mzgreen , @orenktaboola , @personshelldon , @Plastix , @pyricau for the contributions, bug reports and feature requests. ViewModel leak detection \u00b6 Android ViewModels are really cool! Their lifecycle is much nicer than fragments or activities, but sometimes mistakes happen. LeakCanary will now automatically detect ViewModel leaks and report any ViewModel instance retained after its onCleared() method was called. Android TV \u00b6 LeakCanary is finally coming to big screens near you! Best part - no additional setup is required, just enable it like you would for a mobile device . Now whenever there\u2019s a leak - you will see a helpful Toast appear with all the details. Make sure to check out our new Android TV section and chill! Java-friendly Config builders \u00b6 It was brought to our attention that configuring LeakCanary and AppWatcher was a miserable experience from Java code. Well, not anymore! Now you can use LeakCanary.Config.Builder and AppWatcher.Config.Builder to have idiomatic Java when updating the configurations. For example: LeakCanary.Config config = LeakCanary.getConfig().newBuilder() .retainedVisibleThreshold(3) .computeRetainedHeapSize(false) .build(); LeakCanary.setConfig(config); If you notice any other problems when using LeakCanary from Java, please file an issue ! We take Java-interop seriously and will be happy to improve LeakCanary\u2019s API! For more details, see the 2.2 Milestone and the full diff . Version 2.1 (2019-12-31) \u00b6 A special New Year\u2019s Eve release \ud83e\udd73, the next release will be in another decade \ud83d\ude0e! Many thanks to @adamfit , @alexander-smityuk , @Armaxis , @BraisGabin , @devism , @ditclear , @jrodbx , @jstefanowski , @Maragues , @mzgreen , @pyricau for the contributions, bug reports and feature requests. A Gradle plugin for obfuscated apps \u00b6 It\u2019s fairly common for teams to have a QA build that is tested before making the release build. Usually that build will be obfuscated (via Proguard or R8), but also add LeakCanary to detect leaks during QA. This leads to obfuscated leak traces, which are hard to understand \ud83e\udd2f. Check out our new Gradle deobfuscation plugin and rejoice! UI twix tweaks \u00b6 In 2.0 we changed the LeakCanary UI and UX, and built a foundation on which 2.1 extends. Since 2.0, Leaks are grouped by their distinct signature. In 2.1 there\u2019s a New tag that will show until you open up a leak. There\u2019s also a Library Leak tag for leaks that are known to be caused by a bug in the Android Framework or Google libraries, and the library leak description now shows up in the UI. The type of the Java objects (class, instance, array) is now displayed in the LeakTrace, e.g. see FontsContract class and ExampleApplication instance above. The type of the GC root now shows up at the root of the leak trace. Makes sense! The leak result notification has an importance now set to MAX so that it\u2019ll show up right in your face. If you turn it off, the canary will haunt you in your dreams \ud83d\udc24\ud83d\udc7b. To save your sanity and your device battery, automatic heap dumps now won\u2019t happen more often than once per minute. The resource id name for View instances is now displayed in the leak trace. You shouldn\u2019t look at the implementation . \u251c\u2500 android.widget.TextView instance \u2502 View.mID = R.id.helper_text Documentation goodies \u00b6 The Fundamentals page was entirely rewritten, split into 3 pages and moved to its own tab. Please read it and provide feedback! At Square, we have been uploading leaks to Bugsnag for 3 years now, so that no leak ever gets missed. Follow this recipe ! Did you know you can run LeakCanary in a JVM ? API breaking bettering changes \u00b6 The APIs of the Leak and LeakTrace classes have significantly changed, e.g. all LeakTrace instances with an identical signature are grouped under the same Leak object. Despite these breaking changes, this release version is a minor update. Oh noes, what about semantic versioning \ud83d\ude31? Ask Don Quixote. You can now customize the way LeakCanary finds the leaking objects in the heap dump. For example, here\u2019s the configuration SharkCli uses to find leaks in heap dumps of apps that don\u2019t even have the LeakCanary dependency: LeakCanary . config = LeakCanary . config . copy ( leakingObjectFinder = FilteringLeakingObjectFinder ( AndroidObjectInspectors . appLeakingObjectFilters ) ) LeakCanary automatically disables itself in tests by detecting that the org.junit.Test is in the classpath. Unfortunately, some apps ship Junit in their app debug classpath (e.g. when using OkHttp MockWebServer). You can now customize which class is used to detect tests: <resources> <string name= \"leak_canary_test_class_name\" > assertk.Assert </string> </resources> Interactive CLI \u00b6 Shark CLI was rewritten on top of Clikt : $ shark-cli Usage: shark-cli [ OPTIONS ] COMMAND [ ARGS ] ... ^ ` . . = \"\" = . ^_ \\ \\ / _ _ \\ \\ \\ { \\ | d b | { \\ / ` ~~~--__ \\ / \\ / { \\_ __----~~ ' `~~-_/' - = \\/ = - '\\, \\ /// a `~. \\ \\ / /~~~~-, ,__. , /// __,,,,) \\ | \\/ \\/ `~~~; ,---~~-_`/ \\ / \\/ / / ' . . ' ' ._. ' _ | ` ~~ ` | _ / | \\ / | \\ Options: -p, --process NAME Full or partial name of a process, e.g. \"example\" would match \"com.example.app\" -d, --device ID device/emulator id -m, --obfuscation-mapping PATH path to obfuscation mapping file --verbose / --no-verbose provide additional details as to what shark-cli is doing -h, --hprof FILE path to a .hprof file --help Show this message and exit Commands: interactive Explore a heap dump. analyze Analyze a heap dump. dump-process Dump the heap and pull the hprof file. strip-hprof Replace all primitive arrays from the provided heap dump with arrays of zeroes and generate a new \"-stripped.hprof\" file. There\u2019s a new interactive command which enables exploring the heap dump from the command line: $ shark-cli -h heapdump.hprof interactive Enter command [ help ] : help Available commands: analyze Analyze the heap dump. class NAME@ID Show class with a matching NAME and Object ID. instance CLASS_NAME@ID Show instance with a matching CLASS_NAME and Object ID. array CLASS_NAME@ID Show array instance with a matching CLASS_NAME and Object ID. ->instance CLASS_NAME@ID Show path from GC Roots to instance. ~>instance CLASS_NAME@ID Show path from GC Roots to instance, highlighting suspect references. help Show this message. exit Exit this interactive prompt. We\u2019re currently exploring the idea of adding support for SQL queries , feedback welcome! For more details, see the 2.1 Milestone and the full diff . Version 2.0 (2019-11-27) \u00b6 In the past 7 months, LeakCanary went through 3 alphas and 5 betas, encompassing 23 contributors over 493 commits, 35826 insertions and 10156 deletions. Should I upgrade? \u00b6 YES! LeakCanary 2 is so much better, it might make you excited when you see a new memory leak. Follow the upgrade guide , you won\u2019t regret it! So, what\u2019s changed since 1.6.3? \u00b6 Everything. The LeakCanary codebase went from ~6000 lines of Java to ~16000 lines of Kotlin, excluding comments & blanks. Isn\u2019t Kotlin supposed to drastically reduce the amount of boilerplate code? Absolutely! And it did. But then, we wrote more code. LeakCanary used to depend on HAHA , a repackaging of perflib , the heap dump parser used by Android Studio. Unfortunately perflib was slow and used too much memory, so LeakCanary now includes its own heap dump parser: Shark . The extra code comes from Shark, but also from having a lot more automated tests, and an improved UI layer. One major difference: when the app is in foreground, LeakCanary 2 will not trigger on every retained instance. Instead it will wait until the app goes in background or to reach a threashold of 5 retained instances in foreground. The analysis will then find all the leaks at once, and group identical leaks in the results UI. Please read the Fundamentals section to learn more! Random facts \u00b6 You can customize the Leaks launcher icon and label: learn more here . If you ` press on your main activity launcher icon, you should see a LeakCanary dynamic shortcut. You can then long press that to drop it on your home screen, and the launcher shows that it\u2019s the leaks launcher for your app. Out of the box, LeakCanary tracks all fragments flavors: AOSP, Support Library and Android X. From within the leak screen, you can share a leak to stack overflow. You can also share a heap dump, or import and analyze a heap dump from another device. You can run LeakCanary from your computer command line, on any debuggable app even if that app doesn\u2019t have LeakCanary: learn more here . The new documentation is fully searchable and includes the API documentation. Try the search bar \u2934. A large 160Mb heap dump uses 2Gb memory when opening it in Android Studio, but only 40Mb with Shark. Changes since 2.0 Beta 5 \u00b6 Shark CLI supports multiple connected devices #1642 Fixed missing sources from Maven Central #1643 Updated notification icon to avoid confusion with Twitter DM notifications, and added icons to bottom navigation bar #1648 Automatic leak detection for support library fragments #1611 Many thanks to @AndreasBoehm , @jrodbx , @pyricau for the contributions, bug reports and feature requests. For more details, see the 2.0 Milestone and the full diff . Version 2.0 Beta 5 (2019-11-25) \u00b6 Major bugfix: native gc roots were accidentally ignored in Beta 4, as a result some leaks were not found #1634 Fixed Lint warning ( leak_canary_about_message string triggered multiple substitutions warning) #1630 Many thanks to @DanEdgarTarget , @msfjarvis , @PaulWoitaschek , @pyricau , @ZacSweers for the contributions, bug reports and feature requests. For more details, see the 2.0-beta-5 Milestone and the full diff . Version 2.0 Beta 4 (2019-11-18) \u00b6 Improved string rendering for heap analysis results UX redesign #1445 Support for pattern matching of native reference leaks #1562 Added support for deobfuscation using Proguard mapping files in Shark #1499 . This isn\u2019t directly supported in LeakCanary yet. Added support for extracting metadata from the heap dump (see the recipe ) #1519 Improved auto disabling of LeakCanary in Unit and UI tests #1552 Several performance improvements when parsing heap dumps Fixed several bugs and crashes Added new known leak patterns Many thanks to @Armaxis , @BraisGabin , @bric3 , @elihart , @fernandospr , @flickator , @gabrysgab , @JorgeDLS , @lannyf77 , @msfjarvis , @mzgreen , @ozmium , @PaulWoitaschek , @pyricau , @shelpy , @vRallev , @ZacSweers for the contributions, bug reports and feature requests. For more details, see the 2.0-beta-4 Milestone and the full diff . Version 2.0 Beta 3 (2019-08-22) \u00b6 Baseline memory usage for large hprofs divided by 3 and removed memory spikes #1543 Fixed crash when LeakCanary is initialized from another process #1529 Java local references are deprioritized to look for longer alternative paths #1525 Fixed JavaLocalPattern not matching on Lollipop #1524 Many thanks to @Armaxis , @elihart , @emartynov , @hmcgreevy-instil , @pyricau for the contributions, bug reports and feature requests. For more details, see the 2.0-beta-3 Milestone and the full diff . Version 2.0 Beta 2 (2019-08-02) \u00b6 Fixed Leak analysis failed: Object id not found in heap dump. #1516 10x speed increase of hprof indexing on large heap dumps #1520 Many thanks to @kolphi , @pyricau , @ZacSweers for the contributions, bug reports and feature requests. For more details, see the 2.0-beta-2 Milestone and the full diff . Version 2.0 Beta 1 (2019-07-30) \u00b6 New standalone library! Shark is the heap analyzer that powers LeakCanary 2, and it can run in any Java VM. It comes with a CLI : you can now run shark-cli analyze-process com.example.myapp from your computer. New Heap Explorer directly on device! Open a Heap Analysis in LeakCanary, tap the options menu and select \u201cHeap Explorer\u201d. This is still experimental and not very user friendly, contributions welcome! Large API rewrite to improve usability. If you used the alpha with a customized configuration, there are breaking changes. Of note: LeakSentry became AppWatcher , RefWatcher became ObjectWatcher , AndroidExcludedRefs became AndroidReferenceMatchers , AnalysisResultListener became OnHeapAnalyzedListener , AndroidLeakTraceInspectors became AndroidObjectInspectors . The entire API surface is now documented and the documentation is available on this website: see the LeakCanary API tab at the top. Removed the dependency on Android X . No more configuration issues! #1462 Added Proguard rules for LeakCanary and ObjectWatcher. #1500 Display LeakCanary version in the About screen. #1448 Bug fixes, new reference matchers and object inspectors Many thanks to @arctouch-carlosottoboni , @jemaystermind , @kushagrakumar27 , @pyricau , @snkashis for the contributions, bug reports and feature requests. For more details, see the 2.0-beta-1 Milestone and the full diff . Version 2.0 Alpha 3 (2019-07-04) \u00b6 #1401 LeakCanary can now import all hprof files created from prior LeakCanary versions. #1414 New API: RefWatcher.retainedInstances which returns the instances that are currently considered retained. #1419 New APIs: LeakCanary.Config.maxStoredHeapDumps (default 7) and LeakCanary.Config.requestWriteExternalStoragePermission (default false). LeakCanary won\u2019t ask for the external storage permission anymore by default. #1338 API change: LeakCanary.Config.exclusionsFactory replaced with LeakCanary.Config.knownReferences (simpler use), LeakCanary.Config.leakInspectors and LeakCanary.Config.labelers merged into LeakCanary.Config.leakTraceInspectors which provides access to the entire leak trace as well as a new graph oriented API that replaces the low level hprof parser API. #1382 LeakCanary now disables automatic heap dumping when running in AndroidX UI tests. #1424 API rename: RefWatcher.hasRetainedReferences => RefWatcher.hasRetainedInstances , RefWatcher.retainedReferenceCount => RefWatcher.retainedInstanceCount , RefWatcher.hasWatchedReferences => RefWatcher.hasWatchedInstances , RefWatcher.removeKeysRetainedBeforeHeapDump => RefWatcher.removeInstancesRetainedBeforeHeapDump , RefWatcher.clearWatchedReferences => RefWatcher.clearWatchedInstances . #1432 #1438 #1440 New \u201cwon\u2019t fix\u201d leaks and leak trace inspectors #1374 #1364 #1366 #1417 #1399 #1416 #1407 #1427 #1385 Bug and crash fixes Many thanks to @1step2hell , @afollestad , @ansman , @bjdodson , @BraisGabin , @EBfVince , @jaredsburrows , @pforhan , @pyricau , @tellypresence , @wiyarmir for the contributions, bug reports and feature requests. For more details, see the 2.0-alpha-3 Milestone and the full diff . Version 2.0 Alpha 2 (2019-05-21) \u00b6 #1040 Import and analyze hprof files from other devices #1344 Computing retained size #1325 New notification showing current count of retained instances #1079 \u201cExcluded\u201d leaks have been renamed to \u201cWon\u2019t fix\u201d leaks to clarify meaning. #1328 New leaks are called out in the UI. #1327 LeakSentry can be enabled / disabled and is automatically disabled in non debuggable builds. #1173 Experimental: now reporting leaks that only go through weak references (previously reported as \u201cno path to instance\u201d) #1339 Readded support for Thread name based exclusions #1312 Fixed bug causing LeakCanary to stop detecting leaks after the app is killed. #1310 #1313 #1314 #1340 #1337 Many API changes #1296 #1293 #1306 #1336 Fixed several crashes. Many thanks to @forrestbice , @Foso , @Goddchen , @marcosholgado , @orionlee , @pyricau , @satoshun , @ZacSweers for the contributions! For more details, see the 2.0-alpha-2 Milestone and the full diff . Version 2.0 Alpha 1 (2019-04-23) \u00b6 New logo , thanks @flickator ! Entirely rewritten to 100% Kotlin Multiple leaks detected in one analysis The heap is dumped when the app goes in the background, or when a minimum of 5 leaks is reached in the foreground. Leak grouping Leaks that share similar causes are grouped in the UI. New screens to see the list of groups and each group. Improved leaktrace strings to highlight leak causes. Leaks can be shared to Stack Overflow New library: LeakSentry . Detects when objects are leaking and triggers LeakCanary Can be used independently in production, for instance to report the number of leaking instances on an OutOfMemoryError crash. New heap parser Uses 90% less memory and 6 times faster than the prior heap parser. Runs in the same process as the app on a low priority thread. No more dependency on Perflib and TroveJ. New dependency on Okio. The old parser is still available as leakcanary-android-perflib but will be removed after alpha. Labelers can add any string content to leak elements 0 code setup, just add the one debug dependency. Simpler configuration options Updated from support library to Android X Many thanks to @BraisGabin , @colinmarsch , @jrodbx , @flickator , @JakeWharton , @pyricau , @WhatsEmo for the contributions! For more details, see the 2.0-alpha-1 Milestone and the full diff . Version 1.6.3 (2019-01-10) \u00b6 #1163 Fixed leaks being incorrectly classified as \u201cno leak\u201d due to missed GC Roots. #1153 LeakCanary.isInAnalyzerProcess now correctly returns true in the analyzer process prior to any first leak (could be triggered by starting the leak result activity). #1158 Stopped enabling DisplayLeakActivity when not using DisplayLeakService. #1135 Fixed IndexOutOfBoundsException for leak traces of size 1. #1163 Keep \u201cno leak\u201d heap dumps. Many thanks to @KMaragh , @pyricau , @SebRut for the code contributions! For more details, see the 1.6.3 Milestone and the full diff . Version 1.6.2 (2018-10-16) \u00b6 #1067 Fixed TransactionTooLargeException crash (leak analysis would never complete). #1061 Detection of Fragment view leaks after Fragment#onDestroyView(). #1076 Added the FOREGROUND_SERVICE permission for Android P. #1062 The LeakCanary toast now always shows correctly. It doesn\u2019t show if there is no activity in foreground. #1115 Reenabled the DisplayLeakActivity icon on fresh installs. #1100 Added nullability annotations to improve Kotlin support. Updates to excluded leaks ( commits ). Updates to reachability inspectors ( commits ). Many thanks to @fractalwrench , @ZacSweers , @Goddchen , @igokoro , @IlyaGulya , @JakeWharton , @javmarina , @jokermonn , @jrodbx , @Parseus , @pyricau , @scottkennedy for the code contributions! Public API changes \u00b6 Subclasses of AbstractAnalysisResultService should now override onHeapAnalyzed(@NonNull AnalyzedHeap analyzedHeap) instead of onHeapAnalyzed(@NonNull HeapDump heapDump, @NonNull AnalysisResult result) For more details, see the 1.6.2 Milestone and the full diff . Version 1.6.1 (2018-06-21) \u00b6 #727 Improved leak analysis: LeakCanary now identifies and highlights the potential causes of the leak. #1011 We noticed that computing the retained heap size could take a long time, so it\u2019s now optional and off by default. #633 Support for detecting leaks in instrumentation tests ( see the wiki ). #985 Ability to convert leak traces into stack traces for easy remote reporting ( see the wiki ). #983 Support for watching destroyed Fragments. #846 LeakCanary now uses foreground services and displays a notification when the analysis is in progress. This also fixes crashes when analyzing in background on O+. The LeakCanary icon (to start to DisplayLeakActivity) is now hidden by default, and only enabled after the first leak is found. #775 Fixed crash when sharing heap dumps on O+ and added a dependency to the support-core-utils library. #930 DisplayLeakActivity has a responsive icon. #685 Stopped doing IO on main thread in DisplayLeakActivity (fixes StrictMode errors). #999 Updated HAHA to 2.0.4, which uses Trove4j as an external dependency (from jcenter) instead of rebundling it. This is to clarify licences (Apache v2 vs LGPL 2.1). Several bug and crash fixes. Many thanks to @AdityaAnand1 , @alhah , @christxph , @csoon03 , @daqi , @JakeWharton , @jankovd , @jrodbx , @kurtisnelson , @NightlyNexus , @pyricau , @SalvatoreT , @shmuelr , @tokou , @xueqiushi for the code contributions! Note: we made a 1.6 release but quickly followed up with 1.6.1 due to #1058 . Public API changes \u00b6 The installed ref watcher singleton is now available via LeakCanary.installedRefWatcher() AnalysisResult.leakTraceAsFakeException() returns an exception that can be used to report and group leak traces to a tool like Bugsnag or Crashlytics. New InstrumentationLeakDetector and FailTestOnLeakRunListener APIs for detecting leaks in instrumentation tests. New Reachability.Inspector and RefWatcherBuilder.stethoscopeClasses() API to establish reachability and help identify leak causes. Watching activities can be disabled with AndroidRefWatcherBuilder.watchActivities(false) , watching fragments can be disabled with AndroidRefWatcherBuilder.watchFragments(false) LeakCanary.setDisplayLeakActivityDirectoryProvider() is deprecated and replaced with LeakCanary.setLeakDirectoryProvider() New RefWatcherBuilder.computeRetainedHeapSize() API to enable the computing of the retained heap size (off by default). For more details, see the 1.6.1 Milestone and the full diff . Version 1.5.4 (2017-09-22) \u00b6 Restore Java 7 compatibility in leakcanary-watcher Version 1.5.3 (2017-09-17) \u00b6 Fix broken 1.5.2 build Convert leakcanary-watcher from Android library to Java library Disable finish animations in RequestStoragePermissionActivity Corrected README sample for Robolectric tests For more details, see the full diff . Version 1.5.2 (2017-08-09) \u00b6 New excluded leaks Move Leakcanary UI into leak analyzer process Ignore computing retained sizes for bitmaps on O+ Add notification channel for persistent messages on O+ Exclude permission activity from recents menu Updated README and sample for handling Robolectric tests For more details, see the full diff . Version 1.5.1 (2017-04-25) \u00b6 New excluded leaks Fix java.util.MissingFormatArgumentException in DisplayLeakService Separate task affinities for different apps Bump minSdk to 14 Fix HahaHelper for O Preview For more details, see the full diff . Version 1.5 (2016-09-28) \u00b6 New excluded leaks Added LeakCanary.isInAnalyzerProcess() to the no-op jar Fixed several file access issues: No more cleanup on startup, we rotate the heap dump files on every new heap dump. LeakCanary now falls back to the app directory until it can write to the external storage. Leak notifications now each use a distinct notification instead of erasing each other. If LeakCanary can\u2019t perform a heap dump for any reason (e.g. analysis in progress, debugger attached), it retries later with an exponential backoff. Added confirmation dialog when user deletes all leaks. Replace the two LeakCanary configuration methods with a builder that provides more flexibility, see LeakCanary.refWatcher() . For more details, see the full diff . Public API changes \u00b6 New HeapAnalyzer.findTrackedReferences() method for headless analysis when you have no context on what leaked. Added LeakCanary.isInAnalyzerProcess() to the no-op jar Added LeakCanary.refWatcher() which returns an AndroidRefWatcherBuilder that extends RefWatcherBuilder and lets you fully customize the RefWatcher instance. Removed LeakCanary.install(Application, Class) and LeakCanary.androidWatcher(Context, HeapDump.Listener, ExcludedRefs) . Removed R.integer.leak_canary_max_stored_leaks and R.integer.leak_canary_watch_delay_millis , those can now be set via LeakCanary.refWatcher() . Updated the LeakDirectoryProvider API to centralize all file related responsibilities. RefWatcher is now constructed with a WatchExecutor which executes a Retryable , instead of an Executor that executes a Runnable . HeapDumper.NO_DUMP was renamed HeapDumper.RETRY_LATER Version 1.4 (2016-09-11) \u00b6 Fix false negative where GC root is of type android.os.Binder #482 Update HAHA to 2.0.3; clear compiler warnings #563 Correct some mistakes in German translation #516 Don\u2019t loop when storage permission denied #422 Remove old references to \u201c__\u201d prefixed resources #477 Fix permission crash for DisplayLeakActivity on M #382 Fix NPE when thread name not found in heap dump #417 Add version info to stacktrace #473 Version 1.4-beta2 (2016-03-23) \u00b6 Add reason for ignoring to analysis result #365 . Lower memory usage when parsing heap dumps on M #223 . Fix NPE in LeakCanaryInternals.isInServiceProcess() #449 . New ignored Android SDK leaks #297 , #322 . Use leakcanary-android-no-op in test builds #143 . Fixes to allow LeakCanary to work with ProGuard #398 . Optimize png assets #406 . Fix delete button not working on error views #408 . Add German translation #437 . Version 1.4-beta1 (2016-01-08) \u00b6 Switched to HAHA 2.0.2 with uses Perflib instead of MAT under the hood #219 . This fixes crashes and improves speed a lot. We can now parse Android M heap dumps #267 , although there are still memory issues (see #223 ). Excluded leaks are now reported as well and available in the display leak activity. Added ProGuard configuration for #132 . Many new ignored Android SDK leaks. Added excluded leaks to text report #119 . Added LeakCanary SHA to text report #120 . Added CanaryLog API to replace the logger: #201 . Renamed all resources to begin with leak_canary_ instead of __leak_canary #161 No crash when heap dump fails #226 . Add retained size to leak reports #162 . Public API changes \u00b6 AnalysisResult.failure is now a Throwable instead of an Exception . Main goal is to catch and correctly report OOMs while parsing. Added ARRAY_ENTRY to LeakTraceElement.Type for references through array entries. Renamed ExcludedRefs fields. Each ExcludedRef entry can now be ignored entirely or \u201ckept only if no other path\u201d. Added support for ignoring all fields (static and non static) for a given class. Version 1.3.1 (2015-05-16) \u00b6 Heap dumps and analysis results are now saved on the sd card: #21 . ExcludedRef and AndroidExcludedRefs are customizable: #12 #73 . 7 new ignored Android SDK leaks: #1 #4 #32 #89 #82 #97 . Fixed 3 crashes in LeakCanary: #37 #46 #66 . Fixed StrictMode thread policy violations: #15 . Updated minSdkVersion from 9 to 8 : #57 . Added LeakCanary version name to LeakCanary.leakInfo() : #49 . leakcanary-android-no-op is lighter, it does not depend on leakcanary-watcher anymore, only 2 classes now: #74 . Adding field state details to the text leak trace. A Toast is displayed while the heap dump is in progress to warn that the UI will freeze: #20 . You can customize the toast by providing your own layout named __leak_canary_heap_dump_toast.xml (e.g. you could make it an empty layout). If the analysis fails, the result and heap dump are kept so that it can be reported to LeakCanary: #102 . Update to HAHA 1.3 to fix a 2 crashes #3 46 Public API changes \u00b6 When upgrading from 1.3 to 1.3.1, previously saved heap dumps will not be readable any more, but they won\u2019t be removed from the app directory. You should probably uninstall your app. Added android.permission.WRITE_EXTERNAL_STORAGE to leakcanary-android artifact. LeakCanary.androidWatcher() parameter types have changed (+ExcludedRefs). LeakCanary.leakInfo() parameter types have changed (+boolean) ExcludedRef is now serializable and immutable, instances can be created using ExcludedRef.Builder . ExcludedRef is available in HeapDump AndroidExcludedRefs is an enum, you can now pick the leaks you want to ignore in AndroidExcludedRefs by creating an EnumSet and calling AndroidExcludedRefs.createBuilder() . AndroidExcludedRefs.createAppDefaults() & AndroidExcludedRefs.createAndroidDefaults() return a ExcludedRef.Builder . ExcludedRef moved from leakcanary-analyzer to leakcanary-watcher Version 1.3 (2015-05-08) \u00b6 Initial release. Dependencies \u00b6","title":"Change Log"},{"location":"changelog/#change-log","text":"Please thank our contributors \ud83d\ude4f \ud83d\ude4f \ud83d\ude4f.","title":"Change Log"},{"location":"changelog/#version-210-2022-11-10","text":"","title":"Version 2.10 (2022-11-10)"},{"location":"changelog/#experimental-neo4j-heap-dump-exploration","text":"shark-cli has a new experiment neo4j command that will convert a heap dump into an embedded Neo4j database and then open Neo4j Browser to explore the heap dump. brew install leakcanary-shark shark-cli --process com.example.app.debug neo4j","title":"Experimental Neo4j heap dump exploration"},{"location":"changelog/#other-bug-fixes-and-improvements","text":"\ud83d\udc24 #2440 Add Android 13 POST_NOTICICATIONS permission as well as a new LeakCanary.Config.showNotifications config to disable notifications entirely. \ud83d\udc24 #2416 Add Android 13 monochrome icon. \ud83d\udca5 #2371 Fix db crash when navigating heap dump screen. \ud83d\udc1b #2393 Allow LeakCanary to be defined as an AndroidX Startup dependency. \ud83d\udca5 #2430 Fix ShortcutManager crash on Android TV. \ud83d\udca5 #2382 Fix heap dump close crash. This list reflects only a subset of all changes. For more details, see the 2.10 Milestone and the full diff .","title":"Other bug fixes and improvements \ud83d\udc1b\ud83d\udd28"},{"location":"changelog/#version-291-2022-04-20","text":"","title":"Version 2.9.1 (2022-04-20)"},{"location":"changelog/#preface","text":"What are some things you\u2019d like to see in a future LeakCanary 3 version? Tell me on Twitter ! Some ideas I\u2019m playing with: Moving heap analysis leak visualisation to a separate single app (written with Compose!) available on the PlayStore. Bumping Okio to 3.0 Multiplatform heap analysis? Analyze a JVM heap dump in your browser?! Visualize the heap dominators / retained size as a treemap. A backend for LeakCanary? Anyway, that\u2019s still very much the future, let\u2019s talk about what\u2019s in 2.9.1 now!","title":"Preface"},{"location":"changelog/#new-metrics-in-heap-analysis-metadata","text":"I built LeakCanary to help fix leaks, but in doing so I accidentally wrote a fairly flexible heap dump parser. Since we\u2019re parsing the heap to find leaks anyway, we might as well report additional interesting metrics. Here\u2019s what you\u2019ll now see in the heap dump metadata: Class count: count of loaded classes Instance count Primitive array count Object array count Thread count Heap total bytes Bitmap count Bitmap total bytes Large bitmap count (bitmaps with more pixels than 1.1x the pixels on screen) Large bitmap total bytes SQLiteDatabase in memory (open or closed, as well as their file path) This is just a first pass, feedback and ideas welcome!","title":"New metrics in heap analysis metadata"},{"location":"changelog/#performance-improvements","text":"The heap analysis now traverses the heap dump using RandomAccessFile instead of FileChannel.transferTo() and is now 40% faster on API 23 and 20% faster on newer APIs. Also, sticky class GC roots are now deduplicated, which great reduces the memory footprint of LeakCanary on API 23 ( #2324 ). You can read about the related investigation on py.hashnode.dev .","title":"Performance improvements"},{"location":"changelog/#breaking-change-failtestonleakrunlistener-deleted","text":"FailTestOnLeakRunListener , FailTestOnLeak and FailAnnotatedTestOnLeakRunListener were deprecated in LeakCanary 2.8 as they rely on hacking the Android Test library internals which have since changed, and have been replaced by LeakAssertions.assertNoLeak() and the DetectLeaksAfterTestSuccess test rule. I was initially planning of keep these around, but as I tried to increase API level coverage in LeakCanary I needed to upgrade the Android Test library to a more recent version, and the hacks now had compilation errors. So they\u2019re gone: #2282 . If you can\u2019t use the test rules just yet, you\u2019re welcome to copy paste the listener implementations in your own codebase.","title":"Breaking change:  FailTestOnLeakRunListener deleted"},{"location":"changelog/#other-bug-fixes-and-improvements_1","text":"\ud83d\udca5 #2367 Fixed AndroidLeakFixes.FLUSH_HANDLER_THREADS ( HandlerThread can have a null Looper ). \ud83d\udca5 #2286 Update Curtains to include Proguard rules and prevent WindowCallbackWrapper crashes. \ud83d\udca5 #2294 Fixed WindowDelegateCallback.onMenuOpened() crash. \ud83d\udc24 #2328 Fixed ToastEventListener leak. Sorry \ud83d\ude2c! \ud83d\udca5 #2310 Fixed crash when using WorkManager < 2.1.0. \ud83d\udca5 #2342 Fixed crash when HashSet.map is null (which isn\u2019t supposed to happen, oh well, Android \ud83e\udd37\u200d\u2642\ufe0f). \ud83d\udc1b #2117 Fixed StrictMode disk read violations. \ud83d\udca5 #2351 Fixed a race causing a startup crash. \ud83d\udca5 #2315 Fixed crash when using Okio 1.14. \ud83d\udc1b #2182 Fixed multi rescheduling of BackgroundListener$checkAppInBackground . \ud83d\udca5 #2360 Fixed SQLiteOpenHelper concurrent creation crash. This list reflects only a subset of all changes. For more details, see the 2.9 Milestone and the full diff .","title":"Other bug fixes and improvements \ud83d\udc1b\ud83d\udd28"},{"location":"changelog/#version-281-2022-01-06","text":"This is a bugfix release, a quick follow up to 2.8 which had a few major issues \ud83d\ude05. If you haven\u2019t yet, you should definitely read the 2.8 changelog.","title":"Version 2.8.1 (2022-01-06)"},{"location":"changelog/#thanks","text":"Please thank @dicosta , @Goooler , @plnice , @preetha1326 for their contributions, bug reports and feature requests \ud83d\ude4f \ud83d\ude4f \ud83d\ude4f.","title":"Thanks"},{"location":"changelog/#crash-fixes","text":"This patch release fixes not 1, not 2, but 3 crashes! \ud83d\udca5 #2268 WorkManager expedited request crashes before API 31. \ud83d\udca5 #2270 Updating LeakCanary.config crashes when AppWatcher is not installed. \ud83d\udca5 #2271 Analysis failure on API 25 because HashMap$Entry became HashMap$HashMapEntry (on API 25) before it finally changed to HashMap$Node . For more details, see the 2.8.1 Milestone and the full diff .","title":"Crash fixes \ud83d\udca5\ud83d\udca5\ud83d\udca5"},{"location":"changelog/#version-28-2022-01-04","text":"Note: please update to 2.8.1 instead.","title":"Version 2.8 (2022-01-04)"},{"location":"changelog/#preface_1","text":"The last release was 9 months ago. What happened?! Well, soon after releasing LeakCanary 2.7, I had my 2 nd baby, a wonderful daughter \ud83d\ude0d. Having 2 young kids leaves a lot less time available for Open Source work\u2026 but it\u2019s worth it! \u2015 P.Y.","title":"Preface"},{"location":"changelog/#thanks_1","text":"Please thank @aaronweihe , @alhah , @Andre-max , @AoraMD , @BraisGabin , @breezenan , @Goooler , @iliaskomp @Jeff11 , @jmnwong , @IdioticMadman , @keyur1sst , @lchen8 , @leinardi , @Maragues , @mars885 , @mateuszkwiecinski , @matiash , @maxxx , @preetha1326 , @SimonMarquis , @slavonnet , @Sonphil , @summerlyr , @SUPERCILEX , @utwyko , @ZacSweers , @ziranshang , @zoltish for their contributions, bug reports and feature requests \ud83d\ude4f \ud83d\ude4f \ud83d\ude4f.","title":"Thanks"},{"location":"changelog/#improved-support-for-data-structure-internals","text":"\ud83e\udd13 Inspired by Android Studio , LeakCanary\u2019s node discovery during heap graph traversal is now abstracted away. This allows overlaying logical structure over common data structure internals. \ud83d\ude05 WHAT?! \ud83d\udc49 This means we can make known data structures look more like their APIs than their internals. For example, developers tend to think of setting a HashMap entry as map[\"key\"] = value rather than map.table[hash(\"key\")].next.next.next = Node(value) , which is what LeakCanary would previously show in its leak traces. Let\u2019s look at a HashMap example: class CheckoutController { val tabs = HashMap < String , Tab > () fun addItemsTab ( tab : Tab ) { tabs [ \"ItemsTab\" ] = tab } } If the Tab instance holds on to a view, we might see a leak trace that would look like this: \u2502 ... \u251c\u2500 com.example.CheckoutController instance \u2502 \u2193 CheckoutController.tabs \u251c\u2500 java.util.HashMap instance \u2502 \u2193 HashMap.table \u251c\u2500 java.util.HashMap$Node[] array \u2502 \u2193 HashMap$Node[42] \u251c\u2500 java.util.HashMap$Node instance \u2502 \u2193 HashMap$Node.next \u251c\u2500 java.util.HashMap$Node instance \u2502 \u2193 HashMap$Node.value \u251c\u2500 com.example.Tab instance \u2502 ... With the improved data structure support, the leak trace is much clearer (also note how the ItemsTab string key is now surfaced): \u2502 ... \u251c\u2500 com.example.CheckoutController instance \u2502 \u2193 CheckoutController.tabs \u251c\u2500 java.util.HashMap instance \u2502 \u2193 HashMap[ItemsTab] \u251c\u2500 com.example.Tab instance \u2502 ... Another benefit of this change is that leak signatures become less dependent of the runtime, and therefore are more consistent. This is especially true for any data structure that relies on a linked list ( HashMap , LinkedList , MessageQueue , \u2026). Currently LeakCanary supports a limited set of common data structures from Apache Harmony, Open JDK, and the Android SDK. Let me know what else you need!","title":"Improved support for data structure internals"},{"location":"changelog/#objectanimator-leaks","text":"LeakCanary will now detect leaks that trigger when forgetting to cancel ObjectAnimator . This new feature is enabled by the node discovery changes described above! Let\u2019s say you accidentally start an infinite ObjectAnimator and never cancel it, like so: class ExampleActivity : Activity () { override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) setContentView ( R . layout . main_activity ) findViewById < Button > ( R . id . button ). setOnClickListener { view -> ObjectAnimator . ofFloat ( view , View . ALPHA , 0.1f , 0.2f ). apply { duration = 100 repeatMode = ValueAnimator . REVERSE repeatCount = ValueAnimator . INFINITE start () } } } } In previous releases, LeakCanary would detect that the animated view is leaking but it wouldn\u2019t be able to find the leak and instead would report it as an unreachable object: An unreachable object is still in memory but LeakCanary could not find a strong reference path from GC roots. LeakCanary now reports the leak and adds animator state information, helping detect and fix any infinite ObjectAnimator . \u252c\u2500\u2500\u2500 \u2502 GC Root: Thread object \u2502 \u251c\u2500 java.lang.Thread instance \u2502 Leaking: NO (the main thread always runs) \u2502 Thread name: 'main' \u2502 \u2193 Thread.threadLocals \u2502 ~~~~~~~~~~~~ ... \u251c\u2500 android.animation.ObjectAnimator instance \u2502 Leaking: UNKNOWN \u2502 mListeners = null \u2502 mPropertyName = null \u2502 mProperty.mName = alpha \u2502 mProperty.mType = java.lang.Float \u2502 mInitialized = true \u2502 mStarted = true \u2502 mRunning = true \u2502 mAnimationEndRequested = false \u2502 mDuration = 100 \u2502 mStartDelay = 0 \u2502 mRepeatCount = INFINITE (-1) \u2502 mRepeatMode = REVERSE (2) \u2502 \u2193 ObjectAnimator.mTarget \u2502 ~~~~~~~ \u2570\u2192 android.widget.Button instance Leaking: YES (View.mContext references a destroyed activity) To learn more, see this AOSP issue: ObjectAnimator.mTarget weak ref creates memory leaks on infinite animators .","title":"ObjectAnimator leaks"},{"location":"changelog/#leak-detection-in-tests","text":"Previous releases of leakcanary-android-instrumentation introduced a FailTestOnLeakRunListener which could run leak detection after each UI tests. Unfortunately FailTestOnLeakRunListener relied on a hack around androidx.test internals to report failures. The internals keep changing with every androidx.test release and breaking FailTestOnLeakRunListener \ud83d\ude2d. FailTestOnLeakRunListener is now deprecated (\ud83d\udc4b) and replaced by the DetectLeaksAfterTestSuccess test rule, which you can add to your test like any normal test rule. Additionally, you can call LeakAssertions.assertNoLeak() from anywhere in your instrumentation tests. You can also annotate tests with @SkipLeakDetection (for that to work you\u2019ll also need to set up the TestDescriptionHolder test rule). class CartTest { @get : Rule val rules = RuleChain . outerRule ( TestDescriptionHolder ) . around ( DetectLeaksAfterTestSuccess ()) . around ( ActivityScenarioRule ( CartActivity :: class . java )) @Test fun addItemToCart () { // ... } @SkipLeakDetection ( \"See #1234\" ) @Test fun removeItemFromCart () { // ... } }","title":"Leak detection in tests"},{"location":"changelog/#android-12","text":"Hopefully this time we fixed everything that Android 12 broke: missing exported:true tags, missing pending intent flags, and ForegroundServiceStartNotAllowedException crashes. If not, let us know! Can\u2019t wait for Android 13 to break everything again \ud83e\udd2c.","title":"Android 12"},{"location":"changelog/#workmanager","text":"Running an Android Service without crashing ( ForegroundServiceStartNotAllowedException \u2026) is becoming harder with every release of Android, so I got rid of the LeakCanary heap analyzer service! Instead, LeakCanary leverages WorkManager if you already have it as a dependency. If you don\u2019t use WorkManager, then LeakCanary will fall back to using a simple thread. Note: I recommend using at least WorkManager 2.7.0 as it adds the WorkRequest.Builder.setExpedited() API which LeakCanarty leverages if available.","title":"WorkManager"},{"location":"changelog/#multi-process","text":"Switching to WorkManager also impacts the LeakCanary multi process approach, which now leverages WorkManager remote jobs. Blog on how I got this working: WorkManager multi-process for libraries . Multi process is harder to get right so you should only use this if LeakCanary frequently runs out of memory while performing the heap analysis. Here are the updated set up steps: 1) Add the leakcanary-android-process dependency and keep the leakcanary-android dependency . dependencies { debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.8' debugImplementation 'com.squareup.leakcanary:leakcanary-android-process:2.8' } 2) Skip the initialization code in the Application class class ExampleApplication : Application () { override fun onCreate () { if ( LeakCanaryProcess . isInAnalyzerProcess ( this )) { return } super . onCreate () // normal init goes here, skipped in :leakcanary process. } } That\u2019s it! Note that event listeners (see below) related to the analysis will fire in the remote process.","title":"Multi process"},{"location":"changelog/#androidx-app-startup","text":"LeakCanary now optionally supports the AndroidX App Startup library . All you need to do is replace the leakcanary-android dependency with leakcanary-android-startup : dependencies { // Remove the normal leakcanary-android dependency // debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.8' debugImplementation 'com.squareup.leakcanary:leakcanary-android-startup:2.8' } Note 1: leakcanary-android adds the code for automatic installl to leakcanary-android-core . If you\u2019re calling AppWatcher.manualInstall() , you can depend directly on leakcanary-android-core instead of leakcanary-android , and you won\u2019t need the disable any automatic install. Note 2: the same principle applies to leakcanary-object-watcher-android : it depends on leakcanary-object-watcher-android-core and adds automatic install, while leakcanary-object-watcher-android-startup leverages the App Startup library. Same for plumber-android , plumber-android-core and plumber-android-startup .","title":"AndroidX App Startup"},{"location":"changelog/#event-listeners","text":"LeakCanary.Config has a new eventListeners field allowing you to react to LeakCanary\u2019s lifecycle. If you want to customize this, you most likely should be keeping the default list of listeners and add or remove from it. For example, if you want to disable the LeakCanary toast: LeakCanary . config = LeakCanary . config . run { copy ( eventListeners = eventListeners . filter { it !is ToastEventListener } ) } If you want to upload heap analysis results: LeakCanary . config = LeakCanary . config . run { copy ( eventListeners = eventListeners + EventListener { event -> if ( event is HeapAnalysisSucceeded ) { // Upload event.heapAnalysis } } ) } Note: Leakcanary.Config.onHeapAnalyzedListener still works but is now deprecated. Feedback welcome on this new API!","title":"Event listeners"},{"location":"changelog/#other-bug-fixes-and-improvements_2","text":"#2096 Opening / sharing heap dump files now supports LeakCanary as an option. #2210 First Compose dedicated object inspectors! #2121 Support for customizing the heap dumper. This list reflects only a subset of all changes. For more details, see the 2.8 Milestone and the full diff .","title":"Other bug fixes and improvements \ud83d\udc1b\ud83d\udd28"},{"location":"changelog/#version-27-2021-03-26","text":"Please thank @chao2zhang , @ihrupin , @jzbrooks , @msfjarvis , @reneargento , @Unpublished for their contributions, bug reports and feature requests \ud83d\ude4f \ud83d\ude4f \ud83d\ude4f.","title":"Version 2.7 (2021-03-26)"},{"location":"changelog/#finer-grained-root-view-watching","text":"In version 2.6, LeakCanary added detection of root views retained after View.onDetachedFromWindow() . This helps find more leaks, but unfortunately some Android widgets keep a detached root view around to reattach it later (e.g. spinner). App developers also sometimes do the same with dialogs, keeping a single instance around and calling show() and hide() as needed. As a result, LeakCanary would report leaks that were actually not leaks. In version 2.7, the default behavior changed: LeakCanary will continue to detect leaks of toasts, but will ignore root views created by a PopupWindow (which is what Android widgets use). It will also ignore root views created by a dialog by default, and you can turn this back on by setting the leak_canary_watcher_watch_dismissed_dialogs resource boolean to true: <?xml version=\"1.0\" encoding=\"utf-8\"?> <resources> <bool name= \"leak_canary_watcher_watch_dismissed_dialogs\" > true </bool> </resources> This is implemented using a new Square library: Curtains .","title":"Finer grained root view watching"},{"location":"changelog/#targeting-android-12","text":"We fixed two issues for apps that want to target Android 12: #2074 Activities that use intent filters must declare the android:exported attribute. #2079 PendingIntent requires the FLAG_IMMUTABLE flag.","title":"Targeting Android 12"},{"location":"changelog/#bug-fixes-and-improvements","text":"#2075 Fixed crash when sharing heap dumps. #2067 Fixed crash when opening leaks from older versions (before 2.6) of LeakCanary. #2049 Fixed Plumber crash due to R8 shaking AndroidLeakFixes. #2084 Fixed Shark crash when used from multiple threads. #2054 \ud83d\ude48\ud83d\ude49\ud83d\ude4a Blocked Monkeys from deleting leaks. #2069 Added X button to the root leak activity (for custom devices with no back button) #2091 Added receiver details if LoadedApk shows up in the leaktrace. #2083 Added service status details (created or not) to leaktrace. #2099 Retry button if analysis fails. #2066 When heap analysis in UI tests is skipped and NoAnalysis is returned, NoAnalysis now includes a reason to help debug why it didn\u2019t run. #2000 The LeakCanary CI now leverages GitHub actions instead of Travis. For more details, see the 2.7 Milestone and the full diff .","title":"Bug fixes and improvements \ud83d\udc1b\ud83d\udd28"},{"location":"changelog/#version-26-christmas-release-2020-12-24","text":"Please thank @chao2zhang , @ChaosLeung , @LitterSun , @mickverm , @opatry , @Thomas-Vos , @tricknology , @rahul-a , @samoylenkodmitry , @sing0055 , @ubiratansoares for their contributions, bug reports and feature requests \ud83d\ude4f \ud83d\ude4f \ud83d\ude4f. This Christmas Release includes several external contributions and a bunch of cool new features! \ud83c\udf81\ud83c\udf81","title":"Version 2.6 - Christmas Release \ud83c\udf84 (2020-12-24)"},{"location":"changelog/#detecting-root-views-retained-after-viewondetachedfromwindow","text":"On Android, every displayed view hierarchy is attached to a window, whether it be the view hierarchy of an activity, a dialog, a toast or a chat head . After a view hierarchy is detached from its window, it should be garbage collected. LeakCanary already detects leaks of activity view hierarchies because retained detached views reference their activity context and LeakCanary detects activities retained after Activity.onDestroy() . In this new release, LeakCanary will now detect the leak of a dialog view hierarchy as soon as that dialog is dismissed, or any other view that is passed to WindowManager.removeView() .","title":"Detecting root views retained after View.onDetachedFromWindow()"},{"location":"changelog/#detecting-services-retained-after-serviceondestroy","text":"After an Android service is destroyed, it should be garbage collected. Unfortunately, the Android SDK does not provide any generic API to observe the service lifecycle. We worked around that using reflection on greylist APIs (details in #2014 ). Let\u2019s hope this motivates the Android team to build the APIs developers need .","title":"Detecting services retained after Service.onDestroy()"},{"location":"changelog/#configuring-retained-object-detection","text":"With the detection of 2 new types of retained objects, we\u2019re also adding APIs to configure which watchers should be installed as well as adding filtering capabilities. First, disable the automatic install: <?xml version=\"1.0\" encoding=\"utf-8\"?> <resources> <bool name= \"leak_canary_watcher_auto_install\" > false </bool> </resources> Then you can install LeakCanary manually. LeakCanary 2.6 comes with 4 watchers installed by default: ActivityWatcher , FragmentAndViewModelWatcher , RootViewWatcher , ServiceWatcher . Here\u2019s an example to get all the default watchers except ServiceWatcher : class DebugExampleApplication : ExampleApplication () { override fun onCreate () { super . onCreate () val watchersToInstall = AppWatcher . appDefaultWatchers ( application ) . filter { it !is ServiceWatcher } AppWatcher . manualInstall ( application = application , watchersToInstall = watchersToInstall ) } } LeakCanary introduces a new functional (SAM) interface implemented by ObjectWatcher : ReachabilityWatcher , with a ReachabilityWatcher.expectWeaklyReachable() method that replaces the now deprecated ObjectWatcher.watch() method. You can create the default watcher instances with a custom ReachabilityWatcher that delegates to AppWatcher.objectWatcher but filters out specific instances (e.g. BadSdkLeakingFragment ): class DebugExampleApplication : ExampleApplication () { override fun onCreate () { super . onCreate () val delegate = ReachabilityWatcher { watchedObject , description -> if ( watchedObject !is BadSdkLeakingFragment ) { AppWatcher . objectWatcher . expectWeaklyReachable ( watchedObject , description ) } } val watchersToInstall = AppWatcher . appDefaultWatchers ( application , delegate ) AppWatcher . manualInstall ( application = application , watchersToInstall = watchersToInstall ) } } With these new configuration options, AppWatcher.config is now deprecated and a no-op.","title":"Configuring retained object detection"},{"location":"changelog/#dumping-the-heap-on-screen-off","text":"The default threshold to dump the heap is 5 retained objects when the app is visible , and 1 retained object when the app is not visible . Up until now, visible meant \u201cthe app has at least one activity in started state\u201d. In LeakCanary 2.6, the app will now be considered not visible if the device screen is off , lowering the threshold to trigger heap dumps when you turn off the device screen.","title":"Dumping the heap on screen off"},{"location":"changelog/#leakcanary-for-releases","text":"LeakCanary 2.6 introduces a new artifact: leakcanary-android-release . This artifact exposes APIs to run a heap analysis in release builds, in production. Danger Everything about this is experimental. Running a heap analysis in production is not a very common thing to do, and we\u2019re still learning and experimenting with this. Also, both the artifact name and the APIs may change. dependencies { // debugImplementation because LeakCanary should only run in debug builds. debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.6' // NEW: LeakCanary for releases! releaseImplementation 'com.squareup.leakcanary:leakcanary-android-release:2.6' // Optional: detect retained objects. This helps but is not required. releaseImplementation 'com.squareup.leakcanary:leakcanary-object-watcher-android:2.6' } Here\u2019s a code example that runs a heap analysis when the screen is turned off or the app enters background, checking first if a Firebase Remote Config flag is turned on, and uploading the result to Bugsnag: class ReleaseExampleApplication : ExampleApplication () { // Cancels heap analysis if \"heap_analysis_flag\" is false. private val flagInterceptor by lazy { object : HeapAnalysisInterceptor { val remoteConfig : FirebaseRemoteConfig = TODO () override fun intercept ( chain : Chain ): HeapAnalysisJob . Result { if ( remoteConfig . getBoolean ( \"heap_analysis_flag\" )) { chain . job . cancel ( \"heap_analysis_flag false\" ) } return chain . proceed () } } } private val analysisClient by lazy { HeapAnalysisClient ( // Use private app storage. cacheDir is never backed up which is important. heapDumpDirectoryProvider = { cacheDir }, // stripHeapDump: remove all user data from hprof before analysis. config = HeapAnalysisConfig ( stripHeapDump = true ), // Default interceptors may cancel analysis for several other reasons. interceptors = listOf ( flagInterceptor ) + HeapAnalysisClient . defaultInterceptors ( this ) ) } private val analysisExecutor by lazy { Executors . newSingleThreadExecutor { thread ( start = false , name = \"Heap analysis executor\" ) { android . os . Process . setThreadPriority ( THREAD_PRIORITY_BACKGROUND ) it . run () } } } private val analysisCallback : ( Result ) -> Unit by lazy { val uploader = BugsnagHeapAnalysisUploader ( this @ReleaseExampleApplication ) { result -> if ( result is Done ) { uploader . upload ( result . analysis ) } } } override fun onCreate () { super . onCreate () // Delete any remaining heap dump (if we crashed) analysisExecutor . execute { analysisClient . deleteHeapDumpFiles () } // Starts heap analysis on background importance BackgroundTrigger ( application = this , analysisClient = analysisClient , analysisExecutor = analysisExecutor , analysisCallback = analysisCallback ). start () // Starts heap analysis when screen off ScreenOffTrigger ( application = this , analysisClient = analysisClient , analysisExecutor = analysisExecutor , analysisCallback = analysisCallback ). start () } /** * Call this to trigger heap analysis manually, e.g. from * a help button. * * This method returns a `HeapAnalysisJob` on which you can * call `HeapAnalysisJob.cancel()` at any time. */ fun triggerHeapAnalysisNow (): HeapAnalysisJob { val job = analysisClient . newJob () analysisExecutor . execute { val result = job . execute () analysisCallback ( result ) } return job } } The Bugsnag uploader: class BugsnagHeapAnalysisUploader ( applicationContext : Application ) { private val bugsnagClient : Client init { bugsnagClient = Client ( applicationContext , BUGSNAG_API_KEY , DO_NOT_ENABLE_EXCEPTION_HANDLER ) bugsnagClient . setSendThreads ( false ) } fun upload ( heapAnalysis : HeapAnalysis ) { when ( heapAnalysis ) { is HeapAnalysisSuccess -> { val exception = HeapAnalysisReport () bugsnagClient . notify ( exception ) { report -> val metaData = report . error . metaData metaData . addToTab ( \"Heap Analysis\" , \"result\" , heapAnalysis . toString ()) } } is HeapAnalysisFailure -> { // Please file any reported failure to // https://github.com/square/leakcanary/issues bugsnagClient . notify ( heapAnalysis . exception ) } } } // Exception with fake unique stacktrace to send all reports to the same error entry. class HeapAnalysisReport : Exception ( \"Check the HEAP ANALYSIS tab\" ) { override fun fillInStackTrace (): Throwable { stackTrace = arrayOf ( StackTraceElement ( \"HeapAnalysisReport\" , \"analyzeHeap\" , \"HeapAnalysisReport.kt\" , 1 ) ) return this } } companion object { private const val BUGSNAG_API_KEY = YOUR_BUGSNAG_API_KEY private const val DO_NOT_ENABLE_EXCEPTION_HANDLER = false } }","title":"LeakCanary for releases"},{"location":"changelog/#more-leak-fixes-in-plumber","text":"We added 3 new automatic fixes for known AOSP leaks in plumber-android (details: #1993 ). As a reminder, plumber-android is automatically included when you add leakcanary-android , and you can add it manually for build types that don\u2019t include LeakCanary: dependencies { // leakcanary-android adds plumber-android to debug builds debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.6' // This adds plumber-android to all build types implementation 'com.squareup.leakcanary:plumber-android:2.6' }","title":"More leak fixes in Plumber"},{"location":"changelog/#bug-fixes-and-improvements_1","text":"#1948 Leakcanary is now compiled against Kotlin 1.4 (while staying 1.3 compatible) to support Functional (SAM) interfaces . #1956 The retained object size is displayed as a human readable output (KB, MB, \u2026). #1976 Improved default object inspectors and leak finders for View and Context . #1972 Fields are printed with the parent class name that holds the field in leak traces. #1981 Fixed StrictMode policy violation (main thread read from disk). #1977 Report objects that are not strongly reachable. #2018 & #2019 Fixed crashes in LeakCanary UI (discovered by Monkey tests). #2015 Fixed crash on Android < 16. #2023 Fixed crash in plugin projects. For more details, see the 2.6 Milestone and the full diff .","title":"Bug fixes and improvements \ud83d\udc1b\ud83d\udd28"},{"location":"changelog/#version-25-2020-10-01","text":"Please thank @Amokrane , @Armaxis , @askont , @chao2zhang , @daniil-shevtsov , @eygraber , @msfjarvis , @mzgreen , @lchen8 , @rpattabi , @sahil2441 , @SylvainGirod , @vhow for their contributions, bug reports and feature requests \ud83d\ude4f \ud83d\ude4f \ud83d\ude4f.","title":"Version 2.5 (2020-10-01)"},{"location":"changelog/#heap-analysis-is-twice-as-fast","text":"No one asked, so we delivered! We rewrote several core components in Shark (LeakCanary\u2019s heap analyzer) to dramatically reduce IO reads and allocations while keeping memory constant. More details on Twitter: thread by @ArtemChubaryan and thread by @Piwai .","title":"Heap analysis is twice as fast \ud83d\udc24\ud83d\udca8"},{"location":"changelog/#compute-retained-size-within-the-leak-trace","text":"Previously, LeakCanary computed the retained size for the leaking object (the last object in the leak trace). However, the bad reference causing objects to leak is often higher up in the leak trace and everything that it holds onto is actually leaking. So LeakCanary now computes the retained size for all the objects in the leaktrace that have a LEAKING or UNKNOWN status : \u252c\u2500\u2500\u2500 \u2502 GC Root: System class \u2502 \u251c\u2500 com.example.MySingleton class \u2502 Leaking: NO (a class is never leaking) \u2502 \u2193 static MySingleton.leakedView \u2502 ~~~~~~~~~~ \u251c\u2500 android.widget.TextView instance \u2502 Leaking: YES (View.mContext references a destroyed activity) \u2502 Retaining 46326 bytes in 942 objects \u2502 \u2193 TextView.mContext \u2570\u2192 com.example.MainActivity instance \u200b Leaking: YES (Activity#mDestroyed is true) \u200b Retaining 1432 bytes in 36 objects","title":"Compute retained size within the leak trace"},{"location":"changelog/#disable-leakcanary-from-the-ui","text":"New toggle to disable heap dumping , which can be useful for QA, or when doing a product demo. LeakCanary will still show a notification when an object is retained.","title":"Disable LeakCanary from the UI"},{"location":"changelog/#deobfuscating-hprof-files","text":"The Shark CLI can now deobfuscate heap dumps : brew install leakcanary-shark shark-cli --hprof heapdump.hprof -m mapping.txt deobfuscate-hprof","title":"Deobfuscating hprof files"},{"location":"changelog/#bug-fixes-and-improvements_2","text":"Heap analysis text results now wrap to a max width when sharing them from the LeakCanary activity or printing to logcat. This will make it harder to miss details that are lost at the end of long lines of text. The leak_canary_watcher_auto_install , leak_canary_allow_in_non_debuggable_build and leak_canary_plumber_auto_install resource booleans were meant to be public . We sprinkled a few @JvmStatic to help Java consummers . Fixed crash when no browser installed . Use distinct group for LeakCanary notifications . The heap analysis result now includes the heap dump duration because it looks like Android 11 heap dumps are sometimes super slow . We also added more perf related metrics . Disable logging when AppWatcher runs in release builds. Highlight library leak patterns directly within the leak traces . Improved inspections for Context, View and ContextImpl . For more details, see the 2.5 Milestone and the full diff .","title":"Bug fixes and improvements \ud83d\udc1b\ud83d\udd28"},{"location":"changelog/#version-24-2020-06-10","text":"Please thank @0x109 , @andersu , @antoniomerlin , @bishiboosh , @ckesc , @jrodbx , @LouisCAD , @marcardar , @OlivierGenez , @pyricau , @runningcode , @seljad , @worldsnas for their contributions, bug reports and feature requests.","title":"Version 2.4 (2020-06-10)"},{"location":"changelog/#plumber-android-is-a-new-artifact-that-fixes-known-android-leaks","text":"LeakCanary reports all leaks, including leaks caused by a known bug in 3 rd party code that you do not have control over (reported as Library leaks ). That can be annoying! LeakCanary now ships with a new dependency, plumber-android , which performs hacks at runtime to fix some of these known leaks. This releases has fixes for 11 known leaks , but this is just the beginning. Contributions welcome! \ud83d\ude4f Note that since the leakcanary-android dependency is usually added as a debugImplementation dependency, the plumber-android is transitively added only in debug builds, so it will not fix leaks in your release builds. You can add the dependency directly as implementation to get these fixes in release builds as well: dependencies { implementation 'com.squareup.leakcanary:plumber-android:2.4' } Warning While several of these fixes already ship in release builds of Square apps, this is the first official release of plumber-android , so you should consider it experimental .","title":"plumber-android is a new artifact that fixes known Android leaks \ud83d\udebd\ud83d\udd27"},{"location":"changelog/#analyzing-leaks-from-the-cli-is-easier-than-ever","text":"The Shark CLI can now be installed via Homebrew brew install leakcanary-shark You can then look for leaks in apps on any connected device, for example: $ shark-cli --device emulator-5554 --process com.example.app.debug analyze","title":"Analyzing leaks from the CLI is easier than ever \ud83c\udf7a"},{"location":"changelog/#support-for-android-test-orchestrator","text":"If you set up LeakCanary to report test failures when detecting leaks in instrumentation tests, it now works with Android Test Orchestrator as well. No change required, LeakCanary will automatically detect thatAndroid Test Orchestrator is running and hook into it.","title":"Support for Android Test Orchestrator \ud83c\udfbc"},{"location":"changelog/#no-more-master-branch","text":"The branch name master comes from the master / slave terminology. We renamed the default branch to main , a small step towards making the LeakCanary community a safer space. Here\u2019s a good thread on this topic .","title":"No more master branch"},{"location":"changelog/#bug-fixes-and-improvements_3","text":"URLs in Library Leak descriptions are now clickable Fixed ordering issues causing improper config with manual setup. A related change is that AppWatcher.Config.enabled is now deprecated. Fixed possible OutOfMemoryError failure when computing retained size: we were loading to memory large arrays from the heap dump just to get their size. For more details, see the 2.4 Milestone and the full diff .","title":"Bug fixes and improvements \ud83d\udc1b\ud83d\udd28"},{"location":"changelog/#version-23-2020-04-08","text":"This is a minor release on the feature front, but a large release on the documentation front! Many thanks to @adamfit , @Amokrane , @Armaxis , @artnc , @burakeregar , @ClaasJG , @clementcontet , @ckesc , @cketti , @fbenbassat , @Guneetgstar , @Igorxp5 , @JLLeitschuh , @KidAndroid , @ligi , @mzgreen , @pyricau , @sprintuu , @tevjef , @thrlr123 for the contributions, bug reports and feature requests. We asked for help and immediately started seeing more contributions. Thanks all! Check out the How to help page.","title":"Version 2.3 (2020-04-08)"},{"location":"changelog/#leakcanary-will-now-crash-in-release-builds","text":"Despite the documentation insisting on using debugImplementation , we\u2019ve seen apps ship LeakCanary in release builds . Mistakes happen, so we\u2019ve made that mistake harder to miss by making LeakCanary crash when included in release builds . Learn More: LeakCanary in release builds .","title":"LeakCanary will now crash in release builds"},{"location":"changelog/#doc-site","text":"The doc site content has changed quite a bit! We applied advice from Google\u2019s tech writing guide . If you\u2019ve been confused by Library Leaks before, check out see the new Categorizing leaks section. Take a look around, let us know what you think.","title":"Doc site \ud83d\udec0\ud83d\udca5"},{"location":"changelog/#bug-fixes-and-improvements_4","text":"The new deobfuscation Gradle plugin wasn\u2019t working with Gradle 3.6 , this is now fixed. Also removed the requirement for the plugin to be applied after AGP . Fixed 2 crashes ( #1768 & #1769 ) in the LeakCanary UI found by a sneaky monkey runner \ud83d\ude48. The LeakCanary UI updates immediately when a heap analysis is added or deleted. Fixed a crash when updating from LeakCanary 2.0 . The About section of the LeakCanary now surfaces whether heap dumping is currently enabled . Fixed process not exiting in SharkCLI on Windows. Improved error message when obfuscation mappings appear to be missing. For more details, see the 2.3 Milestone and the full diff .","title":"Bug fixes and improvements \ud83d\ude09"},{"location":"changelog/#version-22-2020-02-05","text":"We\u2019ve got some good stuff for the first release of the decade! Many thanks to @AndroidInternal , @Armaxis , @lic2050 , @mzgreen , @orenktaboola , @personshelldon , @Plastix , @pyricau for the contributions, bug reports and feature requests.","title":"Version 2.2 (2020-02-05)"},{"location":"changelog/#viewmodel-leak-detection","text":"Android ViewModels are really cool! Their lifecycle is much nicer than fragments or activities, but sometimes mistakes happen. LeakCanary will now automatically detect ViewModel leaks and report any ViewModel instance retained after its onCleared() method was called.","title":"ViewModel leak detection"},{"location":"changelog/#android-tv","text":"LeakCanary is finally coming to big screens near you! Best part - no additional setup is required, just enable it like you would for a mobile device . Now whenever there\u2019s a leak - you will see a helpful Toast appear with all the details. Make sure to check out our new Android TV section and chill!","title":"Android TV"},{"location":"changelog/#java-friendly-config-builders","text":"It was brought to our attention that configuring LeakCanary and AppWatcher was a miserable experience from Java code. Well, not anymore! Now you can use LeakCanary.Config.Builder and AppWatcher.Config.Builder to have idiomatic Java when updating the configurations. For example: LeakCanary.Config config = LeakCanary.getConfig().newBuilder() .retainedVisibleThreshold(3) .computeRetainedHeapSize(false) .build(); LeakCanary.setConfig(config); If you notice any other problems when using LeakCanary from Java, please file an issue ! We take Java-interop seriously and will be happy to improve LeakCanary\u2019s API! For more details, see the 2.2 Milestone and the full diff .","title":"Java-friendly Config builders"},{"location":"changelog/#version-21-2019-12-31","text":"A special New Year\u2019s Eve release \ud83e\udd73, the next release will be in another decade \ud83d\ude0e! Many thanks to @adamfit , @alexander-smityuk , @Armaxis , @BraisGabin , @devism , @ditclear , @jrodbx , @jstefanowski , @Maragues , @mzgreen , @pyricau for the contributions, bug reports and feature requests.","title":"Version 2.1 (2019-12-31)"},{"location":"changelog/#a-gradle-plugin-for-obfuscated-apps","text":"It\u2019s fairly common for teams to have a QA build that is tested before making the release build. Usually that build will be obfuscated (via Proguard or R8), but also add LeakCanary to detect leaks during QA. This leads to obfuscated leak traces, which are hard to understand \ud83e\udd2f. Check out our new Gradle deobfuscation plugin and rejoice!","title":"A Gradle plugin for obfuscated apps"},{"location":"changelog/#ui-twix-tweaks","text":"In 2.0 we changed the LeakCanary UI and UX, and built a foundation on which 2.1 extends. Since 2.0, Leaks are grouped by their distinct signature. In 2.1 there\u2019s a New tag that will show until you open up a leak. There\u2019s also a Library Leak tag for leaks that are known to be caused by a bug in the Android Framework or Google libraries, and the library leak description now shows up in the UI. The type of the Java objects (class, instance, array) is now displayed in the LeakTrace, e.g. see FontsContract class and ExampleApplication instance above. The type of the GC root now shows up at the root of the leak trace. Makes sense! The leak result notification has an importance now set to MAX so that it\u2019ll show up right in your face. If you turn it off, the canary will haunt you in your dreams \ud83d\udc24\ud83d\udc7b. To save your sanity and your device battery, automatic heap dumps now won\u2019t happen more often than once per minute. The resource id name for View instances is now displayed in the leak trace. You shouldn\u2019t look at the implementation . \u251c\u2500 android.widget.TextView instance \u2502 View.mID = R.id.helper_text","title":"UI twix tweaks"},{"location":"changelog/#documentation-goodies","text":"The Fundamentals page was entirely rewritten, split into 3 pages and moved to its own tab. Please read it and provide feedback! At Square, we have been uploading leaks to Bugsnag for 3 years now, so that no leak ever gets missed. Follow this recipe ! Did you know you can run LeakCanary in a JVM ?","title":"Documentation goodies"},{"location":"changelog/#api-breaking-bettering-changes","text":"The APIs of the Leak and LeakTrace classes have significantly changed, e.g. all LeakTrace instances with an identical signature are grouped under the same Leak object. Despite these breaking changes, this release version is a minor update. Oh noes, what about semantic versioning \ud83d\ude31? Ask Don Quixote. You can now customize the way LeakCanary finds the leaking objects in the heap dump. For example, here\u2019s the configuration SharkCli uses to find leaks in heap dumps of apps that don\u2019t even have the LeakCanary dependency: LeakCanary . config = LeakCanary . config . copy ( leakingObjectFinder = FilteringLeakingObjectFinder ( AndroidObjectInspectors . appLeakingObjectFilters ) ) LeakCanary automatically disables itself in tests by detecting that the org.junit.Test is in the classpath. Unfortunately, some apps ship Junit in their app debug classpath (e.g. when using OkHttp MockWebServer). You can now customize which class is used to detect tests: <resources> <string name= \"leak_canary_test_class_name\" > assertk.Assert </string> </resources>","title":"API breaking bettering changes"},{"location":"changelog/#interactive-cli","text":"Shark CLI was rewritten on top of Clikt : $ shark-cli Usage: shark-cli [ OPTIONS ] COMMAND [ ARGS ] ... ^ ` . . = \"\" = . ^_ \\ \\ / _ _ \\ \\ \\ { \\ | d b | { \\ / ` ~~~--__ \\ / \\ / { \\_ __----~~ ' `~~-_/' - = \\/ = - '\\, \\ /// a `~. \\ \\ / /~~~~-, ,__. , /// __,,,,) \\ | \\/ \\/ `~~~; ,---~~-_`/ \\ / \\/ / / ' . . ' ' ._. ' _ | ` ~~ ` | _ / | \\ / | \\ Options: -p, --process NAME Full or partial name of a process, e.g. \"example\" would match \"com.example.app\" -d, --device ID device/emulator id -m, --obfuscation-mapping PATH path to obfuscation mapping file --verbose / --no-verbose provide additional details as to what shark-cli is doing -h, --hprof FILE path to a .hprof file --help Show this message and exit Commands: interactive Explore a heap dump. analyze Analyze a heap dump. dump-process Dump the heap and pull the hprof file. strip-hprof Replace all primitive arrays from the provided heap dump with arrays of zeroes and generate a new \"-stripped.hprof\" file. There\u2019s a new interactive command which enables exploring the heap dump from the command line: $ shark-cli -h heapdump.hprof interactive Enter command [ help ] : help Available commands: analyze Analyze the heap dump. class NAME@ID Show class with a matching NAME and Object ID. instance CLASS_NAME@ID Show instance with a matching CLASS_NAME and Object ID. array CLASS_NAME@ID Show array instance with a matching CLASS_NAME and Object ID. ->instance CLASS_NAME@ID Show path from GC Roots to instance. ~>instance CLASS_NAME@ID Show path from GC Roots to instance, highlighting suspect references. help Show this message. exit Exit this interactive prompt. We\u2019re currently exploring the idea of adding support for SQL queries , feedback welcome! For more details, see the 2.1 Milestone and the full diff .","title":"Interactive CLI"},{"location":"changelog/#version-20-2019-11-27","text":"In the past 7 months, LeakCanary went through 3 alphas and 5 betas, encompassing 23 contributors over 493 commits, 35826 insertions and 10156 deletions.","title":"Version 2.0 (2019-11-27)"},{"location":"changelog/#should-i-upgrade","text":"YES! LeakCanary 2 is so much better, it might make you excited when you see a new memory leak. Follow the upgrade guide , you won\u2019t regret it!","title":"Should I upgrade?"},{"location":"changelog/#so-whats-changed-since-163","text":"Everything. The LeakCanary codebase went from ~6000 lines of Java to ~16000 lines of Kotlin, excluding comments & blanks. Isn\u2019t Kotlin supposed to drastically reduce the amount of boilerplate code? Absolutely! And it did. But then, we wrote more code. LeakCanary used to depend on HAHA , a repackaging of perflib , the heap dump parser used by Android Studio. Unfortunately perflib was slow and used too much memory, so LeakCanary now includes its own heap dump parser: Shark . The extra code comes from Shark, but also from having a lot more automated tests, and an improved UI layer. One major difference: when the app is in foreground, LeakCanary 2 will not trigger on every retained instance. Instead it will wait until the app goes in background or to reach a threashold of 5 retained instances in foreground. The analysis will then find all the leaks at once, and group identical leaks in the results UI. Please read the Fundamentals section to learn more!","title":"So, what's changed since 1.6.3?"},{"location":"changelog/#random-facts","text":"You can customize the Leaks launcher icon and label: learn more here . If you ` press on your main activity launcher icon, you should see a LeakCanary dynamic shortcut. You can then long press that to drop it on your home screen, and the launcher shows that it\u2019s the leaks launcher for your app. Out of the box, LeakCanary tracks all fragments flavors: AOSP, Support Library and Android X. From within the leak screen, you can share a leak to stack overflow. You can also share a heap dump, or import and analyze a heap dump from another device. You can run LeakCanary from your computer command line, on any debuggable app even if that app doesn\u2019t have LeakCanary: learn more here . The new documentation is fully searchable and includes the API documentation. Try the search bar \u2934. A large 160Mb heap dump uses 2Gb memory when opening it in Android Studio, but only 40Mb with Shark.","title":"Random facts"},{"location":"changelog/#changes-since-20-beta-5","text":"Shark CLI supports multiple connected devices #1642 Fixed missing sources from Maven Central #1643 Updated notification icon to avoid confusion with Twitter DM notifications, and added icons to bottom navigation bar #1648 Automatic leak detection for support library fragments #1611 Many thanks to @AndreasBoehm , @jrodbx , @pyricau for the contributions, bug reports and feature requests. For more details, see the 2.0 Milestone and the full diff .","title":"Changes since 2.0 Beta 5"},{"location":"changelog/#version-20-beta-5-2019-11-25","text":"Major bugfix: native gc roots were accidentally ignored in Beta 4, as a result some leaks were not found #1634 Fixed Lint warning ( leak_canary_about_message string triggered multiple substitutions warning) #1630 Many thanks to @DanEdgarTarget , @msfjarvis , @PaulWoitaschek , @pyricau , @ZacSweers for the contributions, bug reports and feature requests. For more details, see the 2.0-beta-5 Milestone and the full diff .","title":"Version 2.0 Beta 5 (2019-11-25)"},{"location":"changelog/#version-20-beta-4-2019-11-18","text":"Improved string rendering for heap analysis results UX redesign #1445 Support for pattern matching of native reference leaks #1562 Added support for deobfuscation using Proguard mapping files in Shark #1499 . This isn\u2019t directly supported in LeakCanary yet. Added support for extracting metadata from the heap dump (see the recipe ) #1519 Improved auto disabling of LeakCanary in Unit and UI tests #1552 Several performance improvements when parsing heap dumps Fixed several bugs and crashes Added new known leak patterns Many thanks to @Armaxis , @BraisGabin , @bric3 , @elihart , @fernandospr , @flickator , @gabrysgab , @JorgeDLS , @lannyf77 , @msfjarvis , @mzgreen , @ozmium , @PaulWoitaschek , @pyricau , @shelpy , @vRallev , @ZacSweers for the contributions, bug reports and feature requests. For more details, see the 2.0-beta-4 Milestone and the full diff .","title":"Version 2.0 Beta 4 (2019-11-18)"},{"location":"changelog/#version-20-beta-3-2019-08-22","text":"Baseline memory usage for large hprofs divided by 3 and removed memory spikes #1543 Fixed crash when LeakCanary is initialized from another process #1529 Java local references are deprioritized to look for longer alternative paths #1525 Fixed JavaLocalPattern not matching on Lollipop #1524 Many thanks to @Armaxis , @elihart , @emartynov , @hmcgreevy-instil , @pyricau for the contributions, bug reports and feature requests. For more details, see the 2.0-beta-3 Milestone and the full diff .","title":"Version 2.0 Beta 3 (2019-08-22)"},{"location":"changelog/#version-20-beta-2-2019-08-02","text":"Fixed Leak analysis failed: Object id not found in heap dump. #1516 10x speed increase of hprof indexing on large heap dumps #1520 Many thanks to @kolphi , @pyricau , @ZacSweers for the contributions, bug reports and feature requests. For more details, see the 2.0-beta-2 Milestone and the full diff .","title":"Version 2.0 Beta 2 (2019-08-02)"},{"location":"changelog/#version-20-beta-1-2019-07-30","text":"New standalone library! Shark is the heap analyzer that powers LeakCanary 2, and it can run in any Java VM. It comes with a CLI : you can now run shark-cli analyze-process com.example.myapp from your computer. New Heap Explorer directly on device! Open a Heap Analysis in LeakCanary, tap the options menu and select \u201cHeap Explorer\u201d. This is still experimental and not very user friendly, contributions welcome! Large API rewrite to improve usability. If you used the alpha with a customized configuration, there are breaking changes. Of note: LeakSentry became AppWatcher , RefWatcher became ObjectWatcher , AndroidExcludedRefs became AndroidReferenceMatchers , AnalysisResultListener became OnHeapAnalyzedListener , AndroidLeakTraceInspectors became AndroidObjectInspectors . The entire API surface is now documented and the documentation is available on this website: see the LeakCanary API tab at the top. Removed the dependency on Android X . No more configuration issues! #1462 Added Proguard rules for LeakCanary and ObjectWatcher. #1500 Display LeakCanary version in the About screen. #1448 Bug fixes, new reference matchers and object inspectors Many thanks to @arctouch-carlosottoboni , @jemaystermind , @kushagrakumar27 , @pyricau , @snkashis for the contributions, bug reports and feature requests. For more details, see the 2.0-beta-1 Milestone and the full diff .","title":"Version 2.0 Beta 1 (2019-07-30)"},{"location":"changelog/#version-20-alpha-3-2019-07-04","text":"#1401 LeakCanary can now import all hprof files created from prior LeakCanary versions. #1414 New API: RefWatcher.retainedInstances which returns the instances that are currently considered retained. #1419 New APIs: LeakCanary.Config.maxStoredHeapDumps (default 7) and LeakCanary.Config.requestWriteExternalStoragePermission (default false). LeakCanary won\u2019t ask for the external storage permission anymore by default. #1338 API change: LeakCanary.Config.exclusionsFactory replaced with LeakCanary.Config.knownReferences (simpler use), LeakCanary.Config.leakInspectors and LeakCanary.Config.labelers merged into LeakCanary.Config.leakTraceInspectors which provides access to the entire leak trace as well as a new graph oriented API that replaces the low level hprof parser API. #1382 LeakCanary now disables automatic heap dumping when running in AndroidX UI tests. #1424 API rename: RefWatcher.hasRetainedReferences => RefWatcher.hasRetainedInstances , RefWatcher.retainedReferenceCount => RefWatcher.retainedInstanceCount , RefWatcher.hasWatchedReferences => RefWatcher.hasWatchedInstances , RefWatcher.removeKeysRetainedBeforeHeapDump => RefWatcher.removeInstancesRetainedBeforeHeapDump , RefWatcher.clearWatchedReferences => RefWatcher.clearWatchedInstances . #1432 #1438 #1440 New \u201cwon\u2019t fix\u201d leaks and leak trace inspectors #1374 #1364 #1366 #1417 #1399 #1416 #1407 #1427 #1385 Bug and crash fixes Many thanks to @1step2hell , @afollestad , @ansman , @bjdodson , @BraisGabin , @EBfVince , @jaredsburrows , @pforhan , @pyricau , @tellypresence , @wiyarmir for the contributions, bug reports and feature requests. For more details, see the 2.0-alpha-3 Milestone and the full diff .","title":"Version 2.0 Alpha 3 (2019-07-04)"},{"location":"changelog/#version-20-alpha-2-2019-05-21","text":"#1040 Import and analyze hprof files from other devices #1344 Computing retained size #1325 New notification showing current count of retained instances #1079 \u201cExcluded\u201d leaks have been renamed to \u201cWon\u2019t fix\u201d leaks to clarify meaning. #1328 New leaks are called out in the UI. #1327 LeakSentry can be enabled / disabled and is automatically disabled in non debuggable builds. #1173 Experimental: now reporting leaks that only go through weak references (previously reported as \u201cno path to instance\u201d) #1339 Readded support for Thread name based exclusions #1312 Fixed bug causing LeakCanary to stop detecting leaks after the app is killed. #1310 #1313 #1314 #1340 #1337 Many API changes #1296 #1293 #1306 #1336 Fixed several crashes. Many thanks to @forrestbice , @Foso , @Goddchen , @marcosholgado , @orionlee , @pyricau , @satoshun , @ZacSweers for the contributions! For more details, see the 2.0-alpha-2 Milestone and the full diff .","title":"Version 2.0 Alpha 2 (2019-05-21)"},{"location":"changelog/#version-20-alpha-1-2019-04-23","text":"New logo , thanks @flickator ! Entirely rewritten to 100% Kotlin Multiple leaks detected in one analysis The heap is dumped when the app goes in the background, or when a minimum of 5 leaks is reached in the foreground. Leak grouping Leaks that share similar causes are grouped in the UI. New screens to see the list of groups and each group. Improved leaktrace strings to highlight leak causes. Leaks can be shared to Stack Overflow New library: LeakSentry . Detects when objects are leaking and triggers LeakCanary Can be used independently in production, for instance to report the number of leaking instances on an OutOfMemoryError crash. New heap parser Uses 90% less memory and 6 times faster than the prior heap parser. Runs in the same process as the app on a low priority thread. No more dependency on Perflib and TroveJ. New dependency on Okio. The old parser is still available as leakcanary-android-perflib but will be removed after alpha. Labelers can add any string content to leak elements 0 code setup, just add the one debug dependency. Simpler configuration options Updated from support library to Android X Many thanks to @BraisGabin , @colinmarsch , @jrodbx , @flickator , @JakeWharton , @pyricau , @WhatsEmo for the contributions! For more details, see the 2.0-alpha-1 Milestone and the full diff .","title":"Version 2.0 Alpha 1 (2019-04-23)"},{"location":"changelog/#version-163-2019-01-10","text":"#1163 Fixed leaks being incorrectly classified as \u201cno leak\u201d due to missed GC Roots. #1153 LeakCanary.isInAnalyzerProcess now correctly returns true in the analyzer process prior to any first leak (could be triggered by starting the leak result activity). #1158 Stopped enabling DisplayLeakActivity when not using DisplayLeakService. #1135 Fixed IndexOutOfBoundsException for leak traces of size 1. #1163 Keep \u201cno leak\u201d heap dumps. Many thanks to @KMaragh , @pyricau , @SebRut for the code contributions! For more details, see the 1.6.3 Milestone and the full diff .","title":"Version 1.6.3 (2019-01-10)"},{"location":"changelog/#version-162-2018-10-16","text":"#1067 Fixed TransactionTooLargeException crash (leak analysis would never complete). #1061 Detection of Fragment view leaks after Fragment#onDestroyView(). #1076 Added the FOREGROUND_SERVICE permission for Android P. #1062 The LeakCanary toast now always shows correctly. It doesn\u2019t show if there is no activity in foreground. #1115 Reenabled the DisplayLeakActivity icon on fresh installs. #1100 Added nullability annotations to improve Kotlin support. Updates to excluded leaks ( commits ). Updates to reachability inspectors ( commits ). Many thanks to @fractalwrench , @ZacSweers , @Goddchen , @igokoro , @IlyaGulya , @JakeWharton , @javmarina , @jokermonn , @jrodbx , @Parseus , @pyricau , @scottkennedy for the code contributions!","title":"Version 1.6.2 (2018-10-16)"},{"location":"changelog/#public-api-changes","text":"Subclasses of AbstractAnalysisResultService should now override onHeapAnalyzed(@NonNull AnalyzedHeap analyzedHeap) instead of onHeapAnalyzed(@NonNull HeapDump heapDump, @NonNull AnalysisResult result) For more details, see the 1.6.2 Milestone and the full diff .","title":"Public API changes"},{"location":"changelog/#version-161-2018-06-21","text":"#727 Improved leak analysis: LeakCanary now identifies and highlights the potential causes of the leak. #1011 We noticed that computing the retained heap size could take a long time, so it\u2019s now optional and off by default. #633 Support for detecting leaks in instrumentation tests ( see the wiki ). #985 Ability to convert leak traces into stack traces for easy remote reporting ( see the wiki ). #983 Support for watching destroyed Fragments. #846 LeakCanary now uses foreground services and displays a notification when the analysis is in progress. This also fixes crashes when analyzing in background on O+. The LeakCanary icon (to start to DisplayLeakActivity) is now hidden by default, and only enabled after the first leak is found. #775 Fixed crash when sharing heap dumps on O+ and added a dependency to the support-core-utils library. #930 DisplayLeakActivity has a responsive icon. #685 Stopped doing IO on main thread in DisplayLeakActivity (fixes StrictMode errors). #999 Updated HAHA to 2.0.4, which uses Trove4j as an external dependency (from jcenter) instead of rebundling it. This is to clarify licences (Apache v2 vs LGPL 2.1). Several bug and crash fixes. Many thanks to @AdityaAnand1 , @alhah , @christxph , @csoon03 , @daqi , @JakeWharton , @jankovd , @jrodbx , @kurtisnelson , @NightlyNexus , @pyricau , @SalvatoreT , @shmuelr , @tokou , @xueqiushi for the code contributions! Note: we made a 1.6 release but quickly followed up with 1.6.1 due to #1058 .","title":"Version 1.6.1 (2018-06-21)"},{"location":"changelog/#public-api-changes_1","text":"The installed ref watcher singleton is now available via LeakCanary.installedRefWatcher() AnalysisResult.leakTraceAsFakeException() returns an exception that can be used to report and group leak traces to a tool like Bugsnag or Crashlytics. New InstrumentationLeakDetector and FailTestOnLeakRunListener APIs for detecting leaks in instrumentation tests. New Reachability.Inspector and RefWatcherBuilder.stethoscopeClasses() API to establish reachability and help identify leak causes. Watching activities can be disabled with AndroidRefWatcherBuilder.watchActivities(false) , watching fragments can be disabled with AndroidRefWatcherBuilder.watchFragments(false) LeakCanary.setDisplayLeakActivityDirectoryProvider() is deprecated and replaced with LeakCanary.setLeakDirectoryProvider() New RefWatcherBuilder.computeRetainedHeapSize() API to enable the computing of the retained heap size (off by default). For more details, see the 1.6.1 Milestone and the full diff .","title":"Public API changes"},{"location":"changelog/#version-154-2017-09-22","text":"Restore Java 7 compatibility in leakcanary-watcher","title":"Version 1.5.4 (2017-09-22)"},{"location":"changelog/#version-153-2017-09-17","text":"Fix broken 1.5.2 build Convert leakcanary-watcher from Android library to Java library Disable finish animations in RequestStoragePermissionActivity Corrected README sample for Robolectric tests For more details, see the full diff .","title":"Version 1.5.3 (2017-09-17)"},{"location":"changelog/#version-152-2017-08-09","text":"New excluded leaks Move Leakcanary UI into leak analyzer process Ignore computing retained sizes for bitmaps on O+ Add notification channel for persistent messages on O+ Exclude permission activity from recents menu Updated README and sample for handling Robolectric tests For more details, see the full diff .","title":"Version 1.5.2 (2017-08-09)"},{"location":"changelog/#version-151-2017-04-25","text":"New excluded leaks Fix java.util.MissingFormatArgumentException in DisplayLeakService Separate task affinities for different apps Bump minSdk to 14 Fix HahaHelper for O Preview For more details, see the full diff .","title":"Version 1.5.1 (2017-04-25)"},{"location":"changelog/#version-15-2016-09-28","text":"New excluded leaks Added LeakCanary.isInAnalyzerProcess() to the no-op jar Fixed several file access issues: No more cleanup on startup, we rotate the heap dump files on every new heap dump. LeakCanary now falls back to the app directory until it can write to the external storage. Leak notifications now each use a distinct notification instead of erasing each other. If LeakCanary can\u2019t perform a heap dump for any reason (e.g. analysis in progress, debugger attached), it retries later with an exponential backoff. Added confirmation dialog when user deletes all leaks. Replace the two LeakCanary configuration methods with a builder that provides more flexibility, see LeakCanary.refWatcher() . For more details, see the full diff .","title":"Version 1.5 (2016-09-28)"},{"location":"changelog/#public-api-changes_2","text":"New HeapAnalyzer.findTrackedReferences() method for headless analysis when you have no context on what leaked. Added LeakCanary.isInAnalyzerProcess() to the no-op jar Added LeakCanary.refWatcher() which returns an AndroidRefWatcherBuilder that extends RefWatcherBuilder and lets you fully customize the RefWatcher instance. Removed LeakCanary.install(Application, Class) and LeakCanary.androidWatcher(Context, HeapDump.Listener, ExcludedRefs) . Removed R.integer.leak_canary_max_stored_leaks and R.integer.leak_canary_watch_delay_millis , those can now be set via LeakCanary.refWatcher() . Updated the LeakDirectoryProvider API to centralize all file related responsibilities. RefWatcher is now constructed with a WatchExecutor which executes a Retryable , instead of an Executor that executes a Runnable . HeapDumper.NO_DUMP was renamed HeapDumper.RETRY_LATER","title":"Public API changes"},{"location":"changelog/#version-14-2016-09-11","text":"Fix false negative where GC root is of type android.os.Binder #482 Update HAHA to 2.0.3; clear compiler warnings #563 Correct some mistakes in German translation #516 Don\u2019t loop when storage permission denied #422 Remove old references to \u201c__\u201d prefixed resources #477 Fix permission crash for DisplayLeakActivity on M #382 Fix NPE when thread name not found in heap dump #417 Add version info to stacktrace #473","title":"Version 1.4 (2016-09-11)"},{"location":"changelog/#version-14-beta2-2016-03-23","text":"Add reason for ignoring to analysis result #365 . Lower memory usage when parsing heap dumps on M #223 . Fix NPE in LeakCanaryInternals.isInServiceProcess() #449 . New ignored Android SDK leaks #297 , #322 . Use leakcanary-android-no-op in test builds #143 . Fixes to allow LeakCanary to work with ProGuard #398 . Optimize png assets #406 . Fix delete button not working on error views #408 . Add German translation #437 .","title":"Version 1.4-beta2 (2016-03-23)"},{"location":"changelog/#version-14-beta1-2016-01-08","text":"Switched to HAHA 2.0.2 with uses Perflib instead of MAT under the hood #219 . This fixes crashes and improves speed a lot. We can now parse Android M heap dumps #267 , although there are still memory issues (see #223 ). Excluded leaks are now reported as well and available in the display leak activity. Added ProGuard configuration for #132 . Many new ignored Android SDK leaks. Added excluded leaks to text report #119 . Added LeakCanary SHA to text report #120 . Added CanaryLog API to replace the logger: #201 . Renamed all resources to begin with leak_canary_ instead of __leak_canary #161 No crash when heap dump fails #226 . Add retained size to leak reports #162 .","title":"Version 1.4-beta1 (2016-01-08)"},{"location":"changelog/#public-api-changes_3","text":"AnalysisResult.failure is now a Throwable instead of an Exception . Main goal is to catch and correctly report OOMs while parsing. Added ARRAY_ENTRY to LeakTraceElement.Type for references through array entries. Renamed ExcludedRefs fields. Each ExcludedRef entry can now be ignored entirely or \u201ckept only if no other path\u201d. Added support for ignoring all fields (static and non static) for a given class.","title":"Public API changes"},{"location":"changelog/#version-131-2015-05-16","text":"Heap dumps and analysis results are now saved on the sd card: #21 . ExcludedRef and AndroidExcludedRefs are customizable: #12 #73 . 7 new ignored Android SDK leaks: #1 #4 #32 #89 #82 #97 . Fixed 3 crashes in LeakCanary: #37 #46 #66 . Fixed StrictMode thread policy violations: #15 . Updated minSdkVersion from 9 to 8 : #57 . Added LeakCanary version name to LeakCanary.leakInfo() : #49 . leakcanary-android-no-op is lighter, it does not depend on leakcanary-watcher anymore, only 2 classes now: #74 . Adding field state details to the text leak trace. A Toast is displayed while the heap dump is in progress to warn that the UI will freeze: #20 . You can customize the toast by providing your own layout named __leak_canary_heap_dump_toast.xml (e.g. you could make it an empty layout). If the analysis fails, the result and heap dump are kept so that it can be reported to LeakCanary: #102 . Update to HAHA 1.3 to fix a 2 crashes #3 46","title":"Version 1.3.1 (2015-05-16)"},{"location":"changelog/#public-api-changes_4","text":"When upgrading from 1.3 to 1.3.1, previously saved heap dumps will not be readable any more, but they won\u2019t be removed from the app directory. You should probably uninstall your app. Added android.permission.WRITE_EXTERNAL_STORAGE to leakcanary-android artifact. LeakCanary.androidWatcher() parameter types have changed (+ExcludedRefs). LeakCanary.leakInfo() parameter types have changed (+boolean) ExcludedRef is now serializable and immutable, instances can be created using ExcludedRef.Builder . ExcludedRef is available in HeapDump AndroidExcludedRefs is an enum, you can now pick the leaks you want to ignore in AndroidExcludedRefs by creating an EnumSet and calling AndroidExcludedRefs.createBuilder() . AndroidExcludedRefs.createAppDefaults() & AndroidExcludedRefs.createAndroidDefaults() return a ExcludedRef.Builder . ExcludedRef moved from leakcanary-analyzer to leakcanary-watcher","title":"Public API changes"},{"location":"changelog/#version-13-2015-05-08","text":"Initial release.","title":"Version 1.3 (2015-05-08)"},{"location":"changelog/#dependencies","text":"","title":"Dependencies"},{"location":"code_of_conduct/","text":"Open Source Code of Conduct \u00b6 At Square, we are committed to contributing to the open source community and simplifying the process of releasing and managing open source software. We\u2019ve seen incredible support and enthusiasm from thousands of people who have already contributed to our projects\u200a\u2014\u200aand we want to ensure our community continues to be truly open for everyone. This code of conduct outlines our expectations for participants, as well as steps to reporting unacceptable behavior. We are committed to providing a welcoming and inspiring community for all and expect our code of conduct to be honored. Square\u2019s open source community strives to: Be open : We invite anyone to participate in any aspect of our projects. Our community is open, and any responsibility can be carried by a contributor who demonstrates the required capacity and competence. Be considerate : People use our work, and we depend on the work of others. Consider users and colleagues before taking action. For example, changes to code, infrastructure, policy, and documentation may negatively impact others. Be respectful : We expect people to work together to resolve conflict, assume good intentions, and act with empathy. Do not turn disagreements into personal attacks. Be collaborative : Collaboration reduces redundancy and improves the quality of our work. We strive for transparency within our open source community, and we work closely with upstream developers and others in the free software community to coordinate our efforts. Be pragmatic : Questions are encouraged and should be asked early in the process to avoid problems later. Be thoughtful and considerate when seeking out the appropriate forum for your questions. Those who are asked should be responsive and helpful. Step down considerately : Members of every project come and go. When somebody leaves or disengages from the project, they should make it known and take the proper steps to ensure that others can pick up where they left off. This code is not exhaustive or complete. It serves to distill our common understanding of a collaborative, shared environment, and goals. We expect it to be followed in spirit as much as in the letter. Diversity Statement \u00b6 We encourage everyone to participate and are committed to building a community for all. Although we may not be able to satisfy everyone, we all agree that everyone is equal. Whenever a participant has made a mistake, we expect them to take responsibility for it. If someone has been harmed or offended, it is our responsibility to listen carefully and respectfully, and do our best to right the wrong. Although this list cannot be exhaustive, we explicitly honor diversity in age, culture, ethnicity, gender identity or expression, language, national origin, political beliefs, profession, race, religion, sexual orientation, socioeconomic status, and technical ability. We will not tolerate discrimination based on any of the protected characteristics above, including participants with disabilities. Reporting Issues \u00b6 If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . For more details, please see our Reporting Guidelines below. Thanks \u00b6 Some of the ideas and wording for the statements and guidelines above were based on work by the Twitter , Ubuntu , GDC , and Django communities. We are thankful for their work. Reporting Guide \u00b6 If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . All reports will be handled with discretion. In your report please include: Your contact information. Names (real, nicknames, or pseudonyms) of any individuals involved. If there are additional witnesses, please include them as well. Your account of what occurred, and if you believe the incident is ongoing. If there is a publicly available record (e.g. a mailing list archive or a public IRC logger), please include a link. Any additional information that may be helpful. After filing a report, a representative from the Square Code of Conduct committee will contact you personally. The committee will then review the incident, follow up with any additional questions, and make a decision as to how to respond. Anyone asked to stop unacceptable behavior is expected to comply immediately. If an individual engages in unacceptable behavior, the Square Code of Conduct committee may take any action they deem appropriate, up to and including a permanent ban from all of Square spaces without warning.","title":"Code of Conduct"},{"location":"code_of_conduct/#open-source-code-of-conduct","text":"At Square, we are committed to contributing to the open source community and simplifying the process of releasing and managing open source software. We\u2019ve seen incredible support and enthusiasm from thousands of people who have already contributed to our projects\u200a\u2014\u200aand we want to ensure our community continues to be truly open for everyone. This code of conduct outlines our expectations for participants, as well as steps to reporting unacceptable behavior. We are committed to providing a welcoming and inspiring community for all and expect our code of conduct to be honored. Square\u2019s open source community strives to: Be open : We invite anyone to participate in any aspect of our projects. Our community is open, and any responsibility can be carried by a contributor who demonstrates the required capacity and competence. Be considerate : People use our work, and we depend on the work of others. Consider users and colleagues before taking action. For example, changes to code, infrastructure, policy, and documentation may negatively impact others. Be respectful : We expect people to work together to resolve conflict, assume good intentions, and act with empathy. Do not turn disagreements into personal attacks. Be collaborative : Collaboration reduces redundancy and improves the quality of our work. We strive for transparency within our open source community, and we work closely with upstream developers and others in the free software community to coordinate our efforts. Be pragmatic : Questions are encouraged and should be asked early in the process to avoid problems later. Be thoughtful and considerate when seeking out the appropriate forum for your questions. Those who are asked should be responsive and helpful. Step down considerately : Members of every project come and go. When somebody leaves or disengages from the project, they should make it known and take the proper steps to ensure that others can pick up where they left off. This code is not exhaustive or complete. It serves to distill our common understanding of a collaborative, shared environment, and goals. We expect it to be followed in spirit as much as in the letter.","title":"Open Source Code of Conduct"},{"location":"code_of_conduct/#diversity-statement","text":"We encourage everyone to participate and are committed to building a community for all. Although we may not be able to satisfy everyone, we all agree that everyone is equal. Whenever a participant has made a mistake, we expect them to take responsibility for it. If someone has been harmed or offended, it is our responsibility to listen carefully and respectfully, and do our best to right the wrong. Although this list cannot be exhaustive, we explicitly honor diversity in age, culture, ethnicity, gender identity or expression, language, national origin, political beliefs, profession, race, religion, sexual orientation, socioeconomic status, and technical ability. We will not tolerate discrimination based on any of the protected characteristics above, including participants with disabilities.","title":"Diversity Statement"},{"location":"code_of_conduct/#reporting-issues","text":"If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . For more details, please see our Reporting Guidelines below.","title":"Reporting Issues"},{"location":"code_of_conduct/#thanks","text":"Some of the ideas and wording for the statements and guidelines above were based on work by the Twitter , Ubuntu , GDC , and Django communities. We are thankful for their work.","title":"Thanks"},{"location":"code_of_conduct/#reporting-guide","text":"If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . All reports will be handled with discretion. In your report please include: Your contact information. Names (real, nicknames, or pseudonyms) of any individuals involved. If there are additional witnesses, please include them as well. Your account of what occurred, and if you believe the incident is ongoing. If there is a publicly available record (e.g. a mailing list archive or a public IRC logger), please include a link. Any additional information that may be helpful. After filing a report, a representative from the Square Code of Conduct committee will contact you personally. The committee will then review the incident, follow up with any additional questions, and make a decision as to how to respond. Anyone asked to stop unacceptable behavior is expected to comply immediately. If an individual engages in unacceptable behavior, the Square Code of Conduct committee may take any action they deem appropriate, up to and including a permanent ban from all of Square spaces without warning.","title":"Reporting Guide"},{"location":"dev-env/","text":"Dev Environment for LeakCanary contributors \u00b6 Setup \u00b6 Download Android Studio . We use two spaces code indentation, use SquareAndroid code style settings from https://github.com/square/java-code-styles . Build with ./gradlew build . Running the failing UI tests to confirm leak detection correctly fails UI tests: ./gradlew leakcanary-android-sample:connectedCheck . Normal UI tests: ./gradlew leakcanary-android-core:connectedCheck . Static Code Analysis \u00b6 LeakCanary uses Detekt for static Code analysis. Analyze the entire project with ./gradlew check or particular modules with ./gradlew :module-name:check . Detekt will fail the build if any ruleset violations are found. You should fix all issues before pushing the branch to remote . There\u2019s also a git pre-push hook that will run analysis automatically before pushing a branch to the remote. If there are any violations - it will prevent the push. Fix the issues! You can bypass the git hook though; Travis CI will still run checks and will fail if any violations are found. Detekt report will be printed in the console and saved to /moduleDir/build/reports/ . Deploying locally \u00b6 To deploy LeakCanary to your local maven repository, run the following command, changing the path to the path of your local repository: ./gradlew uploadArchives -PSNAPSHOT_REPOSITORY_URL=file:///Users/py/.m2/repository Then add the SNAPSHOT dependency and mavenLocal() repository to your project: dependencies { debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.11-SNAPSHOT' } repositories { mavenLocal() } Deploying the docs locally \u00b6 Installing the markdownextradata plugin: pip install mkdocs-markdownextradata-plugin Deploying locally mkdocs serve","title":"Dev Environment"},{"location":"dev-env/#dev-environment-for-leakcanary-contributors","text":"","title":"Dev Environment for LeakCanary contributors"},{"location":"dev-env/#setup","text":"Download Android Studio . We use two spaces code indentation, use SquareAndroid code style settings from https://github.com/square/java-code-styles . Build with ./gradlew build . Running the failing UI tests to confirm leak detection correctly fails UI tests: ./gradlew leakcanary-android-sample:connectedCheck . Normal UI tests: ./gradlew leakcanary-android-core:connectedCheck .","title":"Setup"},{"location":"dev-env/#static-code-analysis","text":"LeakCanary uses Detekt for static Code analysis. Analyze the entire project with ./gradlew check or particular modules with ./gradlew :module-name:check . Detekt will fail the build if any ruleset violations are found. You should fix all issues before pushing the branch to remote . There\u2019s also a git pre-push hook that will run analysis automatically before pushing a branch to the remote. If there are any violations - it will prevent the push. Fix the issues! You can bypass the git hook though; Travis CI will still run checks and will fail if any violations are found. Detekt report will be printed in the console and saved to /moduleDir/build/reports/ .","title":"Static Code Analysis"},{"location":"dev-env/#deploying-locally","text":"To deploy LeakCanary to your local maven repository, run the following command, changing the path to the path of your local repository: ./gradlew uploadArchives -PSNAPSHOT_REPOSITORY_URL=file:///Users/py/.m2/repository Then add the SNAPSHOT dependency and mavenLocal() repository to your project: dependencies { debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.11-SNAPSHOT' } repositories { mavenLocal() }","title":"Deploying locally"},{"location":"dev-env/#deploying-the-docs-locally","text":"Installing the markdownextradata plugin: pip install mkdocs-markdownextradata-plugin Deploying locally mkdocs serve","title":"Deploying the docs locally"},{"location":"faq/","text":"FAQ \u00b6 Can a leak be caused by the Android SDK? \u00b6 Yes. There are a number of known memory leaks that have been fixed over time in AOSP as well as in manufacturer implementations. When such a leak occurs, there is little you can do as an app developer to fix it. For that reason, LeakCanary has a built-in list of known Android leaks to recognize, called Library Leaks (see Categorizing leaks ). If you find a new one, please create an issue (choose \ud83e\udd16Leak in Android SDK / support library ) and follow these steps: Provide the entire leak trace information (including metadata), and use backticks (`) for formatting. Read the AOSP source for that version of Android, and try to figure out why it happens. You can easily navigate through SDK versions by switching branches on the GitHub mirror: android/platform_frameworks_base . Check if it happens on the latest version of Android, and otherwise use blame to find when it was fixed. If it\u2019s still happening, build a simple repro case. File an issue on b.android.com with the leak trace and the repro case. Please remember to follow up the issue when there are new responses. b/176886060 is a good example of effective and respectful communication. Create a PR in LeakCanary to update AndroidReferenceMatchers . Optional: if you find a hack to clear that leak on previous versions of Android, feel free to document it. How do I know if LeakCanary is running? \u00b6 You can confirm that LeakCanary starts correctly by filtering on the LeakCanary tag in Logcat: $ adb logcat | grep LeakCanary D/LeakCanary: Installing AppWatcher If you do not see Installing AppWatcher in the logs, check your dependencies ( ./gradlew app:dependencies ) and make sure LeakCanary is there. Note that LeakCanary is automatically disabled in tests (see LeakCanary test environment detection ): $ adb logcat | grep LeakCanary D/LeakCanary: Installing AppWatcher D/LeakCanary: JUnit detected in classpath, app is running tests => disabling heap dumping & analysis D/LeakCanary: Updated LeakCanary.config: Config(dumpHeap=false) Where does LeakCanary store heap dumps? \u00b6 The default behavior is to store heap dumps in a leakcanary folder under the app directory. If the app has been granted the android.permission.WRITE_EXTERNAL_STORAGE permission, then heap dumps will be stored in a leakcanary-com.example folder (where com.example is your app package name) under the Download folder of the external storage. If the app has not been granted the android.permission.WRITE_EXTERNAL_STORAGE permission but that permission is listed in AndroidManifest.xml then LeakCanary will show a notification that can be tapped to grant permission. How can I dig beyond the leak trace? \u00b6 Sometimes the leak trace isn\u2019t enough and you need to dig into a heap dump with MAT or YourKit . Go to a heap analysis screen, click the overflow menu and select Share Heap Dump . Here\u2019s how you can find the leaking instance in the heap dump: Look for all instances of leakcanary.KeyedWeakReference . For each of these, look at the key field. Find the KeyedWeakReference that has a key field equal to the reference key reported by LeakCanary. The referent field of that KeyedWeakReference is your leaking object. From then on, the matter is in your hands. A good start is to look at the shortest path to GC Roots (excluding weak references). How does LeakCanary get installed by only adding a dependency? \u00b6 On Android, content providers are created after the Application instance is created but before Application.onCreate() is called. The leakcanary-object-watcher-android artifact has a non exported ContentProvider defined in its AndroidManifest.xml file. When that ContentProvider is installed, it adds activity and fragment lifecycle listeners to the application. How many methods does LeakCanary add? \u00b6 0 . LeakCanary is a debug only library. How do I use the SNAPSHOT version? \u00b6 Update your dependencies to the latest SNAPSHOT (see build.gradle ): dependencies { debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.11-SNAPSHOT' } Add Sonatype\u2019s snapshots repository: repositories { mavenCentral() maven { url 'https://s01.oss.sonatype.org/content/repositories/snapshots/' } } Status of the snapshot build: Who\u2019s behind LeakCanary? \u00b6 LeakCanary was created and open sourced by @pyricau , with many contributions from the community. Why is it called LeakCanary? \u00b6 The name LeakCanary is a reference to the expression canary in a coal mine , because LeakCanary is a sentinel used to detect risks by providing advance warning of a danger. Props to @edenman for suggesting it! Who made the logo? \u00b6 @pyricau quickly made the first version of the logo. It was based on cliparts from Android Asset Studio , mixed with the selection from a photo of a Canary. The exclamation mark means danger, the shield stands for protection, and the bird, well, is a canary. @romainguy turned the ugly logo into a nice vector asset . @flickator designed a much nicer logo for LeakCanary 2.0!","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#can-a-leak-be-caused-by-the-android-sdk","text":"Yes. There are a number of known memory leaks that have been fixed over time in AOSP as well as in manufacturer implementations. When such a leak occurs, there is little you can do as an app developer to fix it. For that reason, LeakCanary has a built-in list of known Android leaks to recognize, called Library Leaks (see Categorizing leaks ). If you find a new one, please create an issue (choose \ud83e\udd16Leak in Android SDK / support library ) and follow these steps: Provide the entire leak trace information (including metadata), and use backticks (`) for formatting. Read the AOSP source for that version of Android, and try to figure out why it happens. You can easily navigate through SDK versions by switching branches on the GitHub mirror: android/platform_frameworks_base . Check if it happens on the latest version of Android, and otherwise use blame to find when it was fixed. If it\u2019s still happening, build a simple repro case. File an issue on b.android.com with the leak trace and the repro case. Please remember to follow up the issue when there are new responses. b/176886060 is a good example of effective and respectful communication. Create a PR in LeakCanary to update AndroidReferenceMatchers . Optional: if you find a hack to clear that leak on previous versions of Android, feel free to document it.","title":"Can a leak be caused by the Android SDK?"},{"location":"faq/#how-do-i-know-if-leakcanary-is-running","text":"You can confirm that LeakCanary starts correctly by filtering on the LeakCanary tag in Logcat: $ adb logcat | grep LeakCanary D/LeakCanary: Installing AppWatcher If you do not see Installing AppWatcher in the logs, check your dependencies ( ./gradlew app:dependencies ) and make sure LeakCanary is there. Note that LeakCanary is automatically disabled in tests (see LeakCanary test environment detection ): $ adb logcat | grep LeakCanary D/LeakCanary: Installing AppWatcher D/LeakCanary: JUnit detected in classpath, app is running tests => disabling heap dumping & analysis D/LeakCanary: Updated LeakCanary.config: Config(dumpHeap=false)","title":"How do I know if LeakCanary is running?"},{"location":"faq/#where-does-leakcanary-store-heap-dumps","text":"The default behavior is to store heap dumps in a leakcanary folder under the app directory. If the app has been granted the android.permission.WRITE_EXTERNAL_STORAGE permission, then heap dumps will be stored in a leakcanary-com.example folder (where com.example is your app package name) under the Download folder of the external storage. If the app has not been granted the android.permission.WRITE_EXTERNAL_STORAGE permission but that permission is listed in AndroidManifest.xml then LeakCanary will show a notification that can be tapped to grant permission.","title":"Where does LeakCanary store heap dumps?"},{"location":"faq/#how-can-i-dig-beyond-the-leak-trace","text":"Sometimes the leak trace isn\u2019t enough and you need to dig into a heap dump with MAT or YourKit . Go to a heap analysis screen, click the overflow menu and select Share Heap Dump . Here\u2019s how you can find the leaking instance in the heap dump: Look for all instances of leakcanary.KeyedWeakReference . For each of these, look at the key field. Find the KeyedWeakReference that has a key field equal to the reference key reported by LeakCanary. The referent field of that KeyedWeakReference is your leaking object. From then on, the matter is in your hands. A good start is to look at the shortest path to GC Roots (excluding weak references).","title":"How can I dig beyond the leak trace?"},{"location":"faq/#how-does-leakcanary-get-installed-by-only-adding-a-dependency","text":"On Android, content providers are created after the Application instance is created but before Application.onCreate() is called. The leakcanary-object-watcher-android artifact has a non exported ContentProvider defined in its AndroidManifest.xml file. When that ContentProvider is installed, it adds activity and fragment lifecycle listeners to the application.","title":"How does LeakCanary get installed by only adding a dependency?"},{"location":"faq/#how-many-methods-does-leakcanary-add","text":"0 . LeakCanary is a debug only library.","title":"How many methods does LeakCanary add?"},{"location":"faq/#how-do-i-use-the-snapshot-version","text":"Update your dependencies to the latest SNAPSHOT (see build.gradle ): dependencies { debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.11-SNAPSHOT' } Add Sonatype\u2019s snapshots repository: repositories { mavenCentral() maven { url 'https://s01.oss.sonatype.org/content/repositories/snapshots/' } } Status of the snapshot build:","title":"How do I use the SNAPSHOT version?"},{"location":"faq/#whos-behind-leakcanary","text":"LeakCanary was created and open sourced by @pyricau , with many contributions from the community.","title":"Who's behind LeakCanary?"},{"location":"faq/#why-is-it-called-leakcanary","text":"The name LeakCanary is a reference to the expression canary in a coal mine , because LeakCanary is a sentinel used to detect risks by providing advance warning of a danger. Props to @edenman for suggesting it!","title":"Why is it called LeakCanary?"},{"location":"faq/#who-made-the-logo","text":"@pyricau quickly made the first version of the logo. It was based on cliparts from Android Asset Studio , mixed with the selection from a photo of a Canary. The exclamation mark means danger, the shield stands for protection, and the bird, well, is a canary. @romainguy turned the ugly logo into a nice vector asset . @flickator designed a much nicer logo for LeakCanary 2.0!","title":"Who made the logo?"},{"location":"fundamentals-fixing-a-memory-leak/","text":"A memory leak is a programming error that causes an application to keep a reference to an object that is no longer needed. Somewhere in the code, there\u2019s a reference that should have been cleared and wasn\u2019t. Follow these 4 steps to fix memory leaks: Find the leak trace. Narrow down the suspect references. Find the reference causing the leak. Fix the leak. LeakCanary helps you with the first two steps. The last two steps are up to you! 1. Find the leak trace \u00b6 A leak trace is a shorter name for the best strong reference path from garbage collection roots to the retained object , ie the path of references that is holding an object in memory, therefore preventing it from being garbage collected. For example, let\u2019s store a helper singleton in a static field: class Helper { } class Utils { public static Helper helper = new Helper (); } Let\u2019s tell LeakCanary that the singleton instance is expected to be garbage collected: AppWatcher.objectWatcher.watch(Utils.helper) The leak trace for that singleton looks like this: \u252c\u2500\u2500\u2500 \u2502 GC Root: Local variable in native code \u2502 \u251c\u2500 dalvik.system.PathClassLoader instance \u2502 \u2193 PathClassLoader.runtimeInternalObjects \u251c\u2500 java.lang.Object[] array \u2502 \u2193 Object[].[43] \u251c\u2500 com.example.Utils class \u2502 \u2193 static Utils.helper \u2570\u2192 java.example.Helper Let\u2019s break it down! At the top, a PathClassLoader instance is held by a garbage collection (GC) root , more specifically a local variable in native code. GC roots are special objects that are always reachable, ie they cannot be garbage collected. There are 4 main types of GC root: Local variables , which belong to the stack of a thread. Instances of active Java threads . System Classes , which never unload. Native references , which are controlled by native code. \u252c\u2500\u2500\u2500 \u2502 GC Root: Local variable in native code \u2502 \u251c\u2500 dalvik.system.PathClassLoader instance A line starting with \u251c\u2500 represents a Java object (either a class, an object array or an instance), and a line starting with \u2502 \u2193 represents a reference to the Java object on the next line. PathClassLoader has a runtimeInternalObjects field that is a reference to an array of Object : \u251c\u2500 dalvik.system.PathClassLoader instance \u2502 \u2193 PathClassLoader.runtimeInternalObjects \u251c\u2500 java.lang.Object[] array The element at position 43 in that array of Object is a reference to the Utils class. \u251c\u2500 java.lang.Object[] array \u2502 \u2193 Object[].[43] \u251c\u2500 com.example.Utils class A line starting with \u2570\u2192 represents the leaking object, ie the object that is passed to AppWatcher.objectWatcher.watch() . The Utils class has a static helper field which is a reference to the leaking object, which is the Helper singleton instance: \u251c\u2500 com.example.Utils class \u2502 \u2193 static Utils.helper \u2570\u2192 java.example.Helper instance 2. Narrow down the suspect references \u00b6 A leak trace is a path of references. Initially, all references in that path are suspected of causing the leak, but LeakCanary can automatically narrow down the suspect references. To understand what that means, let\u2019s go through that process manually. Here\u2019s an example of bad Android code: class ExampleApplication : Application () { val leakedViews = mutableListOf < View > () } class MainActivity : Activity () { override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) setContentView ( R . layout . main_activity ) val textView = findViewById < View > ( R . id . helper_text ) val app = application as ExampleApplication // This creates a leak, What a Terrible Failure! app . leakedViews . add ( textView ) } } LeakCanary produces a leak trace that looks like this: \u252c\u2500\u2500\u2500 \u2502 GC Root: System class \u2502 \u251c\u2500 android.provider.FontsContract class \u2502 \u2193 static FontsContract.sContext \u251c\u2500 com.example.leakcanary.ExampleApplication instance \u2502 \u2193 ExampleApplication.leakedViews \u251c\u2500 java.util.ArrayList instance \u2502 \u2193 ArrayList.elementData \u251c\u2500 java.lang.Object[] array \u2502 \u2193 Object[].[0] \u251c\u2500 android.widget.TextView instance \u2502 \u2193 TextView.mContext \u2570\u2192 com.example.leakcanary.MainActivity instance Here\u2019s how to read that leak trace: The FontsContract class is a system class (see GC Root: System class ) and has an sContext static field which references an ExampleApplication instance which has a leakedViews field which references an ArrayList instance which references an array (the array backing the array list implementation) which has an element that references a TextView which has an mContext field which references a destroyed instance of MainActivity . LeakCanary highlights all references suspected of causing this leak using ~~~ underlines. Initially, all references are suspect: \u252c\u2500\u2500\u2500 \u2502 GC Root: System class \u2502 \u251c\u2500 android.provider.FontsContract class \u2502 \u2193 static FontsContract.sContext \u2502 ~~~~~~~~ \u251c\u2500 com.example.leakcanary.ExampleApplication instance \u2502 Leaking: NO (Application is a singleton) \u2502 \u2193 ExampleApplication.leakedViews \u2502 ~~~~~~~~~~~ \u251c\u2500 java.util.ArrayList instance \u2502 \u2193 ArrayList.elementData \u2502 ~~~~~~~~~~~ \u251c\u2500 java.lang.Object[] array \u2502 \u2193 Object[].[0] \u2502 ~~~ \u251c\u2500 android.widget.TextView instance \u2502 \u2193 TextView.mContext \u2502 ~~~~~~~~ \u2570\u2192 com.example.leakcanary.MainActivity instance Then, LeakCanary makes deductions about the state and the lifecycle of the objects in the leak trace. In an Android app the Application instance is a singleton that is never garbage collected, so it\u2019s never leaking ( Leaking: NO (Application is a singleton) ). From that, LeakCanary concludes that the leak is not caused by FontsContract.sContext (removal of corresponding ~~~ ). Here\u2019s the updated leak trace: \u252c\u2500\u2500\u2500 \u2502 GC Root: System class \u2502 \u251c\u2500 android.provider.FontsContract class \u2502 \u2193 static FontsContract.sContext \u251c\u2500 com.example.leakcanary.ExampleApplication instance \u2502 Leaking: NO (Application is a singleton) \u2502 \u2193 ExampleApplication.leakedViews \u2502 ~~~~~~~~~~~ \u251c\u2500 java.util.ArrayList instance \u2502 \u2193 ArrayList.elementData \u2502 ~~~~~~~~~~~ \u251c\u2500 java.lang.Object[] array \u2502 \u2193 Object[].[0] \u2502 ~~~ \u251c\u2500 android.widget.TextView instance \u2502 \u2193 TextView.mContext \u2502 ~~~~~~~~ \u2570\u2192 com.example.leakcanary.MainActivity instance The TextView instance references the destroyed MainActivity instance via it\u2019s mContext field. Views should not survive the lifecycle of their context, so LeakCanary knows that this TextView instance is leaking ( Leaking: YES (View.mContext references a destroyed activity) ), and therefore that the leak is not caused by TextView.mContext (removal of corresponding ~~~ ). Here\u2019s the updated leak trace: \u252c\u2500\u2500\u2500 \u2502 GC Root: System class \u2502 \u251c\u2500 android.provider.FontsContract class \u2502 \u2193 static FontsContract.sContext \u251c\u2500 com.example.leakcanary.ExampleApplication instance \u2502 Leaking: NO (Application is a singleton) \u2502 \u2193 ExampleApplication.leakedViews \u2502 ~~~~~~~~~~~ \u251c\u2500 java.util.ArrayList instance \u2502 \u2193 ArrayList.elementData \u2502 ~~~~~~~~~~~ \u251c\u2500 java.lang.Object[] array \u2502 \u2193 Object[].[0] \u2502 ~~~ \u251c\u2500 android.widget.TextView instance \u2502 Leaking: YES (View.mContext references a destroyed activity) \u2502 \u2193 TextView.mContext \u2570\u2192 com.example.leakcanary.MainActivity instance To summarize, LeakCanary inspects the state of objects in the leak trace to figure out if these objects are leaking ( Leaking: YES vs Leaking: NO ), and leverages that information to narrow down the suspect references. You can provide custom ObjectInspector implementations to improve how LeakCanary works in your codebase (see Identifying leaking objects and labeling objects ). 3. Find the reference causing the leak \u00b6 In the previous example, LeakCanary narrowed down the suspect references to ExampleApplication.leakedViews , ArrayList.elementData and Object[].[0] : \u252c\u2500\u2500\u2500 \u2502 GC Root: System class \u2502 \u251c\u2500 android.provider.FontsContract class \u2502 \u2193 static FontsContract.sContext \u251c\u2500 com.example.leakcanary.ExampleApplication instance \u2502 Leaking: NO (Application is a singleton) \u2502 \u2193 ExampleApplication.leakedViews \u2502 ~~~~~~~~~~~ \u251c\u2500 java.util.ArrayList instance \u2502 \u2193 ArrayList.elementData \u2502 ~~~~~~~~~~~ \u251c\u2500 java.lang.Object[] array \u2502 \u2193 Object[].[0] \u2502 ~~~ \u251c\u2500 android.widget.TextView instance \u2502 Leaking: YES (View.mContext references a destroyed activity) \u2502 \u2193 TextView.mContext \u2570\u2192 com.example.leakcanary.MainActivity instance ArrayList.elementData and Object[].[0] are implementation details of ArrayList , and it\u2019s unlikely that there\u2019s a bug in the ArrayList implementation, so the reference causing the leak is the only remaining reference: ExampleApplication.leakedViews . 4. Fix the leak \u00b6 Once you find the reference causing the leak, you need to figure out what that reference is about, when it should have been cleared and why it hasn\u2019t been. Sometimes it\u2019s obvious, like in the previous example. Sometimes you need more information to figure it out. You can add labels , or explore the hprof directly (see How can I dig beyond the leak trace? ). Warning Memory leaks cannot be fixed by replacing strong references with weak references. It\u2019s a common solution when attempting to quickly address memory issues, however it never works. The bugs that were causing references to be kept longer than necessary are still there. On top of that, it creates more bugs as some objects will now be garbage collected sooner than they should. It also makes the code much harder to maintain. What\u2019s next? Customize LeakCanary to your needs with code recipes !","title":"Fixing a memory leak"},{"location":"fundamentals-fixing-a-memory-leak/#1-find-the-leak-trace","text":"A leak trace is a shorter name for the best strong reference path from garbage collection roots to the retained object , ie the path of references that is holding an object in memory, therefore preventing it from being garbage collected. For example, let\u2019s store a helper singleton in a static field: class Helper { } class Utils { public static Helper helper = new Helper (); } Let\u2019s tell LeakCanary that the singleton instance is expected to be garbage collected: AppWatcher.objectWatcher.watch(Utils.helper) The leak trace for that singleton looks like this: \u252c\u2500\u2500\u2500 \u2502 GC Root: Local variable in native code \u2502 \u251c\u2500 dalvik.system.PathClassLoader instance \u2502 \u2193 PathClassLoader.runtimeInternalObjects \u251c\u2500 java.lang.Object[] array \u2502 \u2193 Object[].[43] \u251c\u2500 com.example.Utils class \u2502 \u2193 static Utils.helper \u2570\u2192 java.example.Helper Let\u2019s break it down! At the top, a PathClassLoader instance is held by a garbage collection (GC) root , more specifically a local variable in native code. GC roots are special objects that are always reachable, ie they cannot be garbage collected. There are 4 main types of GC root: Local variables , which belong to the stack of a thread. Instances of active Java threads . System Classes , which never unload. Native references , which are controlled by native code. \u252c\u2500\u2500\u2500 \u2502 GC Root: Local variable in native code \u2502 \u251c\u2500 dalvik.system.PathClassLoader instance A line starting with \u251c\u2500 represents a Java object (either a class, an object array or an instance), and a line starting with \u2502 \u2193 represents a reference to the Java object on the next line. PathClassLoader has a runtimeInternalObjects field that is a reference to an array of Object : \u251c\u2500 dalvik.system.PathClassLoader instance \u2502 \u2193 PathClassLoader.runtimeInternalObjects \u251c\u2500 java.lang.Object[] array The element at position 43 in that array of Object is a reference to the Utils class. \u251c\u2500 java.lang.Object[] array \u2502 \u2193 Object[].[43] \u251c\u2500 com.example.Utils class A line starting with \u2570\u2192 represents the leaking object, ie the object that is passed to AppWatcher.objectWatcher.watch() . The Utils class has a static helper field which is a reference to the leaking object, which is the Helper singleton instance: \u251c\u2500 com.example.Utils class \u2502 \u2193 static Utils.helper \u2570\u2192 java.example.Helper instance","title":"1. Find the leak trace"},{"location":"fundamentals-fixing-a-memory-leak/#2-narrow-down-the-suspect-references","text":"A leak trace is a path of references. Initially, all references in that path are suspected of causing the leak, but LeakCanary can automatically narrow down the suspect references. To understand what that means, let\u2019s go through that process manually. Here\u2019s an example of bad Android code: class ExampleApplication : Application () { val leakedViews = mutableListOf < View > () } class MainActivity : Activity () { override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) setContentView ( R . layout . main_activity ) val textView = findViewById < View > ( R . id . helper_text ) val app = application as ExampleApplication // This creates a leak, What a Terrible Failure! app . leakedViews . add ( textView ) } } LeakCanary produces a leak trace that looks like this: \u252c\u2500\u2500\u2500 \u2502 GC Root: System class \u2502 \u251c\u2500 android.provider.FontsContract class \u2502 \u2193 static FontsContract.sContext \u251c\u2500 com.example.leakcanary.ExampleApplication instance \u2502 \u2193 ExampleApplication.leakedViews \u251c\u2500 java.util.ArrayList instance \u2502 \u2193 ArrayList.elementData \u251c\u2500 java.lang.Object[] array \u2502 \u2193 Object[].[0] \u251c\u2500 android.widget.TextView instance \u2502 \u2193 TextView.mContext \u2570\u2192 com.example.leakcanary.MainActivity instance Here\u2019s how to read that leak trace: The FontsContract class is a system class (see GC Root: System class ) and has an sContext static field which references an ExampleApplication instance which has a leakedViews field which references an ArrayList instance which references an array (the array backing the array list implementation) which has an element that references a TextView which has an mContext field which references a destroyed instance of MainActivity . LeakCanary highlights all references suspected of causing this leak using ~~~ underlines. Initially, all references are suspect: \u252c\u2500\u2500\u2500 \u2502 GC Root: System class \u2502 \u251c\u2500 android.provider.FontsContract class \u2502 \u2193 static FontsContract.sContext \u2502 ~~~~~~~~ \u251c\u2500 com.example.leakcanary.ExampleApplication instance \u2502 Leaking: NO (Application is a singleton) \u2502 \u2193 ExampleApplication.leakedViews \u2502 ~~~~~~~~~~~ \u251c\u2500 java.util.ArrayList instance \u2502 \u2193 ArrayList.elementData \u2502 ~~~~~~~~~~~ \u251c\u2500 java.lang.Object[] array \u2502 \u2193 Object[].[0] \u2502 ~~~ \u251c\u2500 android.widget.TextView instance \u2502 \u2193 TextView.mContext \u2502 ~~~~~~~~ \u2570\u2192 com.example.leakcanary.MainActivity instance Then, LeakCanary makes deductions about the state and the lifecycle of the objects in the leak trace. In an Android app the Application instance is a singleton that is never garbage collected, so it\u2019s never leaking ( Leaking: NO (Application is a singleton) ). From that, LeakCanary concludes that the leak is not caused by FontsContract.sContext (removal of corresponding ~~~ ). Here\u2019s the updated leak trace: \u252c\u2500\u2500\u2500 \u2502 GC Root: System class \u2502 \u251c\u2500 android.provider.FontsContract class \u2502 \u2193 static FontsContract.sContext \u251c\u2500 com.example.leakcanary.ExampleApplication instance \u2502 Leaking: NO (Application is a singleton) \u2502 \u2193 ExampleApplication.leakedViews \u2502 ~~~~~~~~~~~ \u251c\u2500 java.util.ArrayList instance \u2502 \u2193 ArrayList.elementData \u2502 ~~~~~~~~~~~ \u251c\u2500 java.lang.Object[] array \u2502 \u2193 Object[].[0] \u2502 ~~~ \u251c\u2500 android.widget.TextView instance \u2502 \u2193 TextView.mContext \u2502 ~~~~~~~~ \u2570\u2192 com.example.leakcanary.MainActivity instance The TextView instance references the destroyed MainActivity instance via it\u2019s mContext field. Views should not survive the lifecycle of their context, so LeakCanary knows that this TextView instance is leaking ( Leaking: YES (View.mContext references a destroyed activity) ), and therefore that the leak is not caused by TextView.mContext (removal of corresponding ~~~ ). Here\u2019s the updated leak trace: \u252c\u2500\u2500\u2500 \u2502 GC Root: System class \u2502 \u251c\u2500 android.provider.FontsContract class \u2502 \u2193 static FontsContract.sContext \u251c\u2500 com.example.leakcanary.ExampleApplication instance \u2502 Leaking: NO (Application is a singleton) \u2502 \u2193 ExampleApplication.leakedViews \u2502 ~~~~~~~~~~~ \u251c\u2500 java.util.ArrayList instance \u2502 \u2193 ArrayList.elementData \u2502 ~~~~~~~~~~~ \u251c\u2500 java.lang.Object[] array \u2502 \u2193 Object[].[0] \u2502 ~~~ \u251c\u2500 android.widget.TextView instance \u2502 Leaking: YES (View.mContext references a destroyed activity) \u2502 \u2193 TextView.mContext \u2570\u2192 com.example.leakcanary.MainActivity instance To summarize, LeakCanary inspects the state of objects in the leak trace to figure out if these objects are leaking ( Leaking: YES vs Leaking: NO ), and leverages that information to narrow down the suspect references. You can provide custom ObjectInspector implementations to improve how LeakCanary works in your codebase (see Identifying leaking objects and labeling objects ).","title":"2. Narrow down the suspect references"},{"location":"fundamentals-fixing-a-memory-leak/#3-find-the-reference-causing-the-leak","text":"In the previous example, LeakCanary narrowed down the suspect references to ExampleApplication.leakedViews , ArrayList.elementData and Object[].[0] : \u252c\u2500\u2500\u2500 \u2502 GC Root: System class \u2502 \u251c\u2500 android.provider.FontsContract class \u2502 \u2193 static FontsContract.sContext \u251c\u2500 com.example.leakcanary.ExampleApplication instance \u2502 Leaking: NO (Application is a singleton) \u2502 \u2193 ExampleApplication.leakedViews \u2502 ~~~~~~~~~~~ \u251c\u2500 java.util.ArrayList instance \u2502 \u2193 ArrayList.elementData \u2502 ~~~~~~~~~~~ \u251c\u2500 java.lang.Object[] array \u2502 \u2193 Object[].[0] \u2502 ~~~ \u251c\u2500 android.widget.TextView instance \u2502 Leaking: YES (View.mContext references a destroyed activity) \u2502 \u2193 TextView.mContext \u2570\u2192 com.example.leakcanary.MainActivity instance ArrayList.elementData and Object[].[0] are implementation details of ArrayList , and it\u2019s unlikely that there\u2019s a bug in the ArrayList implementation, so the reference causing the leak is the only remaining reference: ExampleApplication.leakedViews .","title":"3. Find the reference causing the leak"},{"location":"fundamentals-fixing-a-memory-leak/#4-fix-the-leak","text":"Once you find the reference causing the leak, you need to figure out what that reference is about, when it should have been cleared and why it hasn\u2019t been. Sometimes it\u2019s obvious, like in the previous example. Sometimes you need more information to figure it out. You can add labels , or explore the hprof directly (see How can I dig beyond the leak trace? ). Warning Memory leaks cannot be fixed by replacing strong references with weak references. It\u2019s a common solution when attempting to quickly address memory issues, however it never works. The bugs that were causing references to be kept longer than necessary are still there. On top of that, it creates more bugs as some objects will now be garbage collected sooner than they should. It also makes the code much harder to maintain. What\u2019s next? Customize LeakCanary to your needs with code recipes !","title":"4. Fix the leak"},{"location":"fundamentals-how-leakcanary-works/","text":"Once LeakCanary is installed, it automatically detects and report memory leaks, in 4 steps: Detecting retained objects. Dumping the heap. Analyzing the heap. Categorizing leaks. 1. Detecting retained objects \u00b6 LeakCanary hooks into the Android lifecycle to automatically detect when activities and fragments are destroyed and should be garbage collected. These destroyed objects are passed to an ObjectWatcher , which holds weak references to them. LeakCanary automatically detects leaks for the following objects: destroyed Activity instances destroyed Fragment instances destroyed fragment View instances cleared ViewModel instances You can watch any objects that is no longer needed, for example a detached view or a destroyed presenter: AppWatcher . objectWatcher . watch ( myDetachedView , \"View was detached\" ) If the weak reference held by ObjectWatcher isn\u2019t cleared after waiting 5 seconds and running garbage collection, the watched object is considered retained , and potentially leaking. LeakCanary logs this to Logcat: D LeakCanary: Watching instance of com.example.leakcanary.MainActivity (Activity received Activity#onDestroy() callback) ... 5 seconds later ... D LeakCanary: Scheduling check for retained objects because found new object retained LeakCanary waits for the count of retained objects to reach a threshold before dumping the heap, and displays a notification with the latest count. Figure 1. LeakCanary found 4 retained objects. D LeakCanary: Rescheduling check for retained objects in 2000ms because found only 4 retained objects (< 5 while app visible) Info The default threshold is 5 retained objects when the app is visible , and 1 retained object when the app is not visible . If you see the retained objects notification and then put the app in background (for example by pressing the Home button), then the threshold changes from 5 to 1 and LeakCanary dumps the heap within 5 seconds. Tapping the notification forces LeakCanary to dump the heap immediately. 2. Dumping the heap \u00b6 When the count of retained objects reaches a threshold, LeakCanary dumps the Java heap into a .hprof file (a heap dump ) stored onto the Android file system (see Where does LeakCanary store heap dumps? ). Dumping the heap freezes the app for a short amount of time, during which LeakCanary displays the following toast: Figure 2. LeakCanary shows a toast while dumping the heap. 3. Analyzing the heap \u00b6 LeakCanary parses the .hprof file using Shark and locates the retained objects in that heap dump. Figure 3. LeakCanary finds retained objects in the heap dump. For each retained object, LeakCanary finds the path of references that prevents that retained object from being garbage collected: its leak trace . You will learn to analyze a leak trace in the next section: Fixing a memory leak . Figure 4. LeakCanary computes the leak trace for each retained object. When the analysis is done, LeakCanary displays a notification with a summary, and also prints the result in Logcat . Notice below how the 4 retained objects are grouped as 2 distinct leaks . LeakCanary creates a signature for each leak trace , and groups together leaks that have the same signature, ie leaks that are caused by the same bug. Figure 5. The 4 leak traces turned into 2 distinct leak signatures. ==================================== HEAP ANALYSIS RESULT ==================================== 2 APPLICATION LEAKS Displaying only 1 leak trace out of 2 with the same signature Signature: ce9dee3a1feb859fd3b3a9ff51e3ddfd8efbc6 \u252c\u2500\u2500\u2500 \u2502 GC Root: Local variable in native code \u2502 ... Tapping the notification starts an activity that provides more details. Come back to it again later by tapping the LeakCanary launcher icon: Figure 6. LeakCanary adds a launcher icon for each app it\u2019s installed in. Each row corresponds to a group of leaks with the same signature . LeakCanary marks a row as New the first time the app triggers a leak with that signature. Figure 7. The 4 leaks grouped into 2 rows, one for each distinct leak signature. Tap on a leak to open up a screen with the leak trace. You can toggle between retained objects and their leak trace via a drop down. Figure 8. A screen showing 3 leaks grouped by their common leak signature. The leak signature is the hash of the concatenation of each reference suspected to cause the leak , ie each reference displayed with a red underline : Figure 9. A leak trace with 3 suspect references. These same suspicious references are underlined with ~~~ when the leak trace is shared as text: ... \u2502 \u251c\u2500 com.example.leakcanary.LeakingSingleton class \u2502 Leaking: NO (a class is never leaking) \u2502 \u2193 static LeakingSingleton.leakedViews \u2502 ~~~~~~~~~~~ \u251c\u2500 java.util.ArrayList instance \u2502 Leaking: UNKNOWN \u2502 \u2193 ArrayList.elementData \u2502 ~~~~~~~~~~~ \u251c\u2500 java.lang.Object[] array \u2502 Leaking: UNKNOWN \u2502 \u2193 Object[].[0] \u2502 ~~~ \u251c\u2500 android.widget.TextView instance \u2502 Leaking: YES (View.mContext references a destroyed activity) ... In the example above, the signature of the leak would be computed as: val leakSignature = sha1Hash ( \"com.example.leakcanary.LeakingSingleton.leakedView\" + \"java.util.ArrayList.elementData\" + \"java.lang.Object[].[x]\" ) println ( leakSignature ) // dbfa277d7e5624792e8b60bc950cd164190a11aa 4. Categorizing leaks \u00b6 LeakCanary separates the leaks it finds in your app into two categories: Application Leaks and Library Leaks . A Library Leak is a leak caused by a known bug in 3 rd party code that you do not have control over. This leak is impacting your application, but unfortunately fixing it may not be in your control so LeakCanary separates it out. The two categories are separated in the result printed in Logcat : ==================================== HEAP ANALYSIS RESULT ==================================== 0 APPLICATION LEAKS ==================================== 1 LIBRARY LEAK ... \u252c\u2500\u2500\u2500 \u2502 GC Root: Local variable in native code \u2502 ... LeakCanary marks a row as a Library Leak in its list of leaks: Figure 10. LeakCanary found a Library Leak. LeakCanary ships with a database of known leaks, which it recognizes by pattern matching on reference names. For example: Leak pattern: instance field android.app.Activity$1#this$0 Description: Android Q added a new IRequestFinishCallback$Stub class [...] \u252c\u2500\u2500\u2500 \u2502 GC Root: Global variable in native code \u2502 \u251c\u2500 android.app.Activity$1 instance \u2502 Leaking: UNKNOWN \u2502 Anonymous subclass of android.app.IRequestFinishCallback$Stub \u2502 \u2193 Activity$1.this$0 \u2502 ~~~~~~ \u2570\u2192 com.example.MainActivity instance What did I do to cause this leak? Nothing wrong! You used an API the way it was intended but the implementation has a bug that is causing this leak. Is there anything I can do to prevent it? Maybe! Some Library Leaks can be fixed using reflection, others by exercising a code path that makes the leak go away. This type of fix tends to be hacky, so beware! Your best option might be to find the bug report or file one, and insist that the bug gets fixed. Since I can\u2019t do much about this leak, is there a way I can ask LeakCanary to ignore it? There\u2019s no way for LeakCanary to know whether a leak is a Library Leak prior to dumping the heap and analyzing it. If LeakCanary didn\u2019t show the result notification when a Library Leak is found then you\u2019d start wondering what happened to the LeakCanary analysis after the dumping toast. You can see the full list of known leaks in the AndroidReferenceMatchers class. If you find an Android SDK leak that isn\u2019t recognized, please report it . You can also customize the list of known Library Leaks . What\u2019s next? Learn how to fix a memory leak !","title":"How LeakCanary works"},{"location":"fundamentals-how-leakcanary-works/#1-detecting-retained-objects","text":"LeakCanary hooks into the Android lifecycle to automatically detect when activities and fragments are destroyed and should be garbage collected. These destroyed objects are passed to an ObjectWatcher , which holds weak references to them. LeakCanary automatically detects leaks for the following objects: destroyed Activity instances destroyed Fragment instances destroyed fragment View instances cleared ViewModel instances You can watch any objects that is no longer needed, for example a detached view or a destroyed presenter: AppWatcher . objectWatcher . watch ( myDetachedView , \"View was detached\" ) If the weak reference held by ObjectWatcher isn\u2019t cleared after waiting 5 seconds and running garbage collection, the watched object is considered retained , and potentially leaking. LeakCanary logs this to Logcat: D LeakCanary: Watching instance of com.example.leakcanary.MainActivity (Activity received Activity#onDestroy() callback) ... 5 seconds later ... D LeakCanary: Scheduling check for retained objects because found new object retained LeakCanary waits for the count of retained objects to reach a threshold before dumping the heap, and displays a notification with the latest count. Figure 1. LeakCanary found 4 retained objects. D LeakCanary: Rescheduling check for retained objects in 2000ms because found only 4 retained objects (< 5 while app visible) Info The default threshold is 5 retained objects when the app is visible , and 1 retained object when the app is not visible . If you see the retained objects notification and then put the app in background (for example by pressing the Home button), then the threshold changes from 5 to 1 and LeakCanary dumps the heap within 5 seconds. Tapping the notification forces LeakCanary to dump the heap immediately.","title":"1. Detecting retained objects"},{"location":"fundamentals-how-leakcanary-works/#2-dumping-the-heap","text":"When the count of retained objects reaches a threshold, LeakCanary dumps the Java heap into a .hprof file (a heap dump ) stored onto the Android file system (see Where does LeakCanary store heap dumps? ). Dumping the heap freezes the app for a short amount of time, during which LeakCanary displays the following toast: Figure 2. LeakCanary shows a toast while dumping the heap.","title":"2. Dumping the heap"},{"location":"fundamentals-how-leakcanary-works/#3-analyzing-the-heap","text":"LeakCanary parses the .hprof file using Shark and locates the retained objects in that heap dump. Figure 3. LeakCanary finds retained objects in the heap dump. For each retained object, LeakCanary finds the path of references that prevents that retained object from being garbage collected: its leak trace . You will learn to analyze a leak trace in the next section: Fixing a memory leak . Figure 4. LeakCanary computes the leak trace for each retained object. When the analysis is done, LeakCanary displays a notification with a summary, and also prints the result in Logcat . Notice below how the 4 retained objects are grouped as 2 distinct leaks . LeakCanary creates a signature for each leak trace , and groups together leaks that have the same signature, ie leaks that are caused by the same bug. Figure 5. The 4 leak traces turned into 2 distinct leak signatures. ==================================== HEAP ANALYSIS RESULT ==================================== 2 APPLICATION LEAKS Displaying only 1 leak trace out of 2 with the same signature Signature: ce9dee3a1feb859fd3b3a9ff51e3ddfd8efbc6 \u252c\u2500\u2500\u2500 \u2502 GC Root: Local variable in native code \u2502 ... Tapping the notification starts an activity that provides more details. Come back to it again later by tapping the LeakCanary launcher icon: Figure 6. LeakCanary adds a launcher icon for each app it\u2019s installed in. Each row corresponds to a group of leaks with the same signature . LeakCanary marks a row as New the first time the app triggers a leak with that signature. Figure 7. The 4 leaks grouped into 2 rows, one for each distinct leak signature. Tap on a leak to open up a screen with the leak trace. You can toggle between retained objects and their leak trace via a drop down. Figure 8. A screen showing 3 leaks grouped by their common leak signature. The leak signature is the hash of the concatenation of each reference suspected to cause the leak , ie each reference displayed with a red underline : Figure 9. A leak trace with 3 suspect references. These same suspicious references are underlined with ~~~ when the leak trace is shared as text: ... \u2502 \u251c\u2500 com.example.leakcanary.LeakingSingleton class \u2502 Leaking: NO (a class is never leaking) \u2502 \u2193 static LeakingSingleton.leakedViews \u2502 ~~~~~~~~~~~ \u251c\u2500 java.util.ArrayList instance \u2502 Leaking: UNKNOWN \u2502 \u2193 ArrayList.elementData \u2502 ~~~~~~~~~~~ \u251c\u2500 java.lang.Object[] array \u2502 Leaking: UNKNOWN \u2502 \u2193 Object[].[0] \u2502 ~~~ \u251c\u2500 android.widget.TextView instance \u2502 Leaking: YES (View.mContext references a destroyed activity) ... In the example above, the signature of the leak would be computed as: val leakSignature = sha1Hash ( \"com.example.leakcanary.LeakingSingleton.leakedView\" + \"java.util.ArrayList.elementData\" + \"java.lang.Object[].[x]\" ) println ( leakSignature ) // dbfa277d7e5624792e8b60bc950cd164190a11aa","title":"3. Analyzing the heap"},{"location":"fundamentals-how-leakcanary-works/#4-categorizing-leaks","text":"LeakCanary separates the leaks it finds in your app into two categories: Application Leaks and Library Leaks . A Library Leak is a leak caused by a known bug in 3 rd party code that you do not have control over. This leak is impacting your application, but unfortunately fixing it may not be in your control so LeakCanary separates it out. The two categories are separated in the result printed in Logcat : ==================================== HEAP ANALYSIS RESULT ==================================== 0 APPLICATION LEAKS ==================================== 1 LIBRARY LEAK ... \u252c\u2500\u2500\u2500 \u2502 GC Root: Local variable in native code \u2502 ... LeakCanary marks a row as a Library Leak in its list of leaks: Figure 10. LeakCanary found a Library Leak. LeakCanary ships with a database of known leaks, which it recognizes by pattern matching on reference names. For example: Leak pattern: instance field android.app.Activity$1#this$0 Description: Android Q added a new IRequestFinishCallback$Stub class [...] \u252c\u2500\u2500\u2500 \u2502 GC Root: Global variable in native code \u2502 \u251c\u2500 android.app.Activity$1 instance \u2502 Leaking: UNKNOWN \u2502 Anonymous subclass of android.app.IRequestFinishCallback$Stub \u2502 \u2193 Activity$1.this$0 \u2502 ~~~~~~ \u2570\u2192 com.example.MainActivity instance What did I do to cause this leak? Nothing wrong! You used an API the way it was intended but the implementation has a bug that is causing this leak. Is there anything I can do to prevent it? Maybe! Some Library Leaks can be fixed using reflection, others by exercising a code path that makes the leak go away. This type of fix tends to be hacky, so beware! Your best option might be to find the bug report or file one, and insist that the bug gets fixed. Since I can\u2019t do much about this leak, is there a way I can ask LeakCanary to ignore it? There\u2019s no way for LeakCanary to know whether a leak is a Library Leak prior to dumping the heap and analyzing it. If LeakCanary didn\u2019t show the result notification when a Library Leak is found then you\u2019d start wondering what happened to the LeakCanary analysis after the dumping toast. You can see the full list of known leaks in the AndroidReferenceMatchers class. If you find an Android SDK leak that isn\u2019t recognized, please report it . You can also customize the list of known Library Leaks . What\u2019s next? Learn how to fix a memory leak !","title":"4. Categorizing leaks"},{"location":"fundamentals/","text":"The fundamentals describe how LeakCanary works and how to use it to detect and fix memory leaks. This documentation is designed to help developers of all levels, so please don\u2019t hesitate to report any confusing section. What is a memory leak? \u00b6 In a Java based runtime, a memory leak is a programming error that causes an application to keep a reference to an object that is no longer needed. As a result, the memory allocated for that object cannot be reclaimed, eventually leading to an OutOfMemoryError (OOM) crash. For example, an Android Activity instance is no longer needed after its onDestroy() method is called, and storing a reference to that instance in a static field prevents it from being garbage collected. Common causes for memory leaks \u00b6 Most memory leaks are caused by bugs related to the lifecycle of objects. Here are a few common Android mistakes: Adding a Fragment instance to the backstack without clearing that Fragment\u2019s view fields in Fragment.onDestroyView() (more details in this StackOverflow answer ). Storing an Activity instance as a Context field in an object that survives activity recreation due to configuration changes. Registering a listener, broadcast receiver or RxJava subscription which references an object with lifecycle, and forgetting to unregister when the lifecycle reaches its end. Why should I use LeakCanary? \u00b6 Memory leaks are very common in Android apps and the accumulation of small memory leaks causes apps to run out of memory and crash with an OOM. LeakCanary will help you find and fix these memory leaks during development. When Square engineers first enabled LeakCanary in the Square Point Of Sale app, they were able to fix several leaks and reduced the OOM crash rate by 94% . Info Your crash reporting tool might not correctly report OOMs . When memory is low because of memory leak accumulation, an OOM can be thrown from anywhere in the app code, which means that every OOM has a different stacktrace. So instead of one crash entry with a 1000 crashes, OOMs get reported as 1000 distinct crashes and hide in the long tail of low occurring crashes. What\u2019s next? Learn how LeakCanary works !","title":"Introduction"},{"location":"fundamentals/#what-is-a-memory-leak","text":"In a Java based runtime, a memory leak is a programming error that causes an application to keep a reference to an object that is no longer needed. As a result, the memory allocated for that object cannot be reclaimed, eventually leading to an OutOfMemoryError (OOM) crash. For example, an Android Activity instance is no longer needed after its onDestroy() method is called, and storing a reference to that instance in a static field prevents it from being garbage collected.","title":"What is a memory leak?"},{"location":"fundamentals/#common-causes-for-memory-leaks","text":"Most memory leaks are caused by bugs related to the lifecycle of objects. Here are a few common Android mistakes: Adding a Fragment instance to the backstack without clearing that Fragment\u2019s view fields in Fragment.onDestroyView() (more details in this StackOverflow answer ). Storing an Activity instance as a Context field in an object that survives activity recreation due to configuration changes. Registering a listener, broadcast receiver or RxJava subscription which references an object with lifecycle, and forgetting to unregister when the lifecycle reaches its end.","title":"Common causes for memory leaks"},{"location":"fundamentals/#why-should-i-use-leakcanary","text":"Memory leaks are very common in Android apps and the accumulation of small memory leaks causes apps to run out of memory and crash with an OOM. LeakCanary will help you find and fix these memory leaks during development. When Square engineers first enabled LeakCanary in the Square Point Of Sale app, they were able to fix several leaks and reduced the OOM crash rate by 94% . Info Your crash reporting tool might not correctly report OOMs . When memory is low because of memory leak accumulation, an OOM can be thrown from anywhere in the app code, which means that every OOM has a different stacktrace. So instead of one crash entry with a 1000 crashes, OOMs get reported as 1000 distinct crashes and hide in the long tail of low occurring crashes. What\u2019s next? Learn how LeakCanary works !","title":"Why should I use LeakCanary?"},{"location":"getting_started/","text":"Getting started \u00b6 To use LeakCanary, add the leakcanary-android dependency to your app\u2019s build.gradle file: dependencies { // debugImplementation because LeakCanary should only run in debug builds. debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.10' } That\u2019s it, there is no code change needed! Confirm that LeakCanary is running on startup by filtering on the LeakCanary tag in Logcat : D LeakCanary: LeakCanary is running and ready to detect leaks Info LeakCanary automatically detects leaks of the following objects: destroyed Activity instances destroyed Fragment instances destroyed fragment View instances cleared ViewModel instances destroyed Service instance What\u2019s next? Learn the Fundamentals !","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"To use LeakCanary, add the leakcanary-android dependency to your app\u2019s build.gradle file: dependencies { // debugImplementation because LeakCanary should only run in debug builds. debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.10' } That\u2019s it, there is no code change needed! Confirm that LeakCanary is running on startup by filtering on the LeakCanary tag in Logcat : D LeakCanary: LeakCanary is running and ready to detect leaks Info LeakCanary automatically detects leaks of the following objects: destroyed Activity instances destroyed Fragment instances destroyed fragment View instances cleared ViewModel instances destroyed Service instance What\u2019s next? Learn the Fundamentals !","title":"Getting started"},{"location":"how_to_help/","text":"How to help \u00b6 \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f LeakCanary is maintained by volunteers. Your help is welcome and will benefit the entire Android community! Here\u2019s how you can help: Contribute to Help Wanted issues. Answer StackOverflow questions . Provide feedback on pull requests . Contribute code by forking the repository on GitHub and sending a pull request. Please read Dev Environment for LeakCanary contributors . When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible.","title":"How to help"},{"location":"how_to_help/#how-to-help","text":"\ud83d\ude4f\ud83d\ude4f\ud83d\ude4f LeakCanary is maintained by volunteers. Your help is welcome and will benefit the entire Android community! Here\u2019s how you can help: Contribute to Help Wanted issues. Answer StackOverflow questions . Provide feedback on pull requests . Contribute code by forking the repository on GitHub and sending a pull request. Please read Dev Environment for LeakCanary contributors . When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible.","title":"How to help"},{"location":"leakcanary-for-releases/","text":"LeakCanary for releases \u00b6 Fixing leaks found in debug builds helps reduce Application Not Responding freezes and OutfOfMemoryError error crashes, but only scratches the surface of all the leaks that can happen. For the leaks that are found in debug builds, it\u2019s hard to determine which leaks to fix first. This situation is very similar to debug crashes, where we are often unable to make an accurate assessment of their future impact in a production environment nor find all crashes that will happen in production. For crashes, apps typically monitor a crash rate by having a release crash reporting pipeline, with counts to prioritize fixes. LeakCanary for releases exposes APIs to run a heap analysis in release builds, in production. Danger Everything about this is experimental. Running a heap analysis in production is not a very common thing to do, and we\u2019re still learning and experimenting with this. Also, both the artifact name and the APIs may change. Getting started \u00b6 LeakCanary provides an artifact dedicated to detecting leaks in release builds: dependencies { // LeakCanary for releases releaseImplementation 'com.squareup.leakcanary:leakcanary-android-release:2.10' // Optional: detect retained objects. This helps but is not required. releaseImplementation 'com.squareup.leakcanary:leakcanary-object-watcher-android:2.10' } Here\u2019s a code example that runs a heap analysis when the screen is turned off or the app enters background, checking first if a Firebase Remote Config flag is turned on, and uploading the result to Bugsnag: import android.os.Process.THREAD_PRIORITY_BACKGROUND import java.util.concurrent.Executors import kotlin.concurrent.thread import leakcanary.BackgroundTrigger import leakcanary.HeapAnalysisClient import leakcanary.HeapAnalysisConfig import leakcanary.HeapAnalysisInterceptor import leakcanary.HeapAnalysisInterceptor.Chain import leakcanary.HeapAnalysisJob import leakcanary.HeapAnalysisJob.Result.Done import leakcanary.ScreenOffTrigger class ReleaseExampleApplication : ExampleApplication () { override fun onCreate () { super . onCreate () // Delete any remaining heap dump (if we crashed) analysisExecutor . execute { analysisClient . deleteHeapDumpFiles () } // Starts heap analysis on background importance BackgroundTrigger ( application = this , analysisClient = analysisClient , analysisExecutor = analysisExecutor , analysisCallback = analysisCallback ). start () // Starts heap analysis when screen off ScreenOffTrigger ( application = this , analysisClient = analysisClient , analysisExecutor = analysisExecutor , analysisCallback = analysisCallback ). start () } /** * Call this to trigger heap analysis manually, e.g. from * a help button. * * This method returns a `HeapAnalysisJob` on which you can * call `HeapAnalysisJob.cancel()` at any time. */ fun triggerHeapAnalysisNow (): HeapAnalysisJob { val job = analysisClient . newJob () analysisExecutor . execute { val result = job . execute () analysisCallback ( result ) } return job } private val analysisClient by lazy { HeapAnalysisClient ( // Use private app storage. cacheDir is never backed up which is important. heapDumpDirectoryProvider = { cacheDir }, // stripHeapDump: remove all user data from hprof before analysis. config = HeapAnalysisConfig ( stripHeapDump = true ), // Default interceptors may cancel analysis for several other reasons. interceptors = listOf ( flagInterceptor ) + HeapAnalysisClient . defaultInterceptors ( this ) ) } // Cancels heap analysis if \"heap_analysis_flag\" is false. private val flagInterceptor = object : HeapAnalysisInterceptor { val remoteConfig by lazy { FirebaseRemoteConfig . getInstance () } override fun intercept ( chain : Chain ): HeapAnalysisJob . Result { if ( remoteConfig . getBoolean ( \"heap_analysis_flag\" )) { chain . job . cancel ( \"heap_analysis_flag false\" ) } return chain . proceed () } } private val analysisExecutor = Executors . newSingleThreadExecutor { thread ( start = false , name = \"Heap analysis executor\" ) { android . os . Process . setThreadPriority ( THREAD_PRIORITY_BACKGROUND ) it . run () } } private val analysisCallback : ( HeapAnalysisJob . Result ) -> Unit = { result -> if ( result is Done ) { uploader . upload ( result . analysis ) } } private val uploader by lazy { BugsnagLeakUploader ( this @ReleaseExampleApplication ) } } Here\u2019s the BugsnagLeakUploader : import android.app.Application import com.bugsnag.android.Bugsnag import com.bugsnag.android.Configuration import com.bugsnag.android.ErrorTypes import com.bugsnag.android.Event import com.bugsnag.android.ThreadSendPolicy import shark.HeapAnalysis import shark.HeapAnalysisFailure import shark.HeapAnalysisSuccess import shark.Leak import shark.LeakTrace import shark.LeakTraceReference import shark.LibraryLeak class BugsnagLeakUploader ( applicationContext : Application ) { private val bugsnagClient = Bugsnag . start ( applicationContext , Configuration ( \"YOUR_BUGSNAG_API_KEY\" ). apply { enabledErrorTypes = ErrorTypes ( anrs = false , ndkCrashes = false , unhandledExceptions = false , unhandledRejections = false ) sendThreads = ThreadSendPolicy . NEVER } ) fun upload ( heapAnalysis : HeapAnalysis ) { when ( heapAnalysis ) { is HeapAnalysisSuccess -> { val allLeakTraces = heapAnalysis . allLeaks . toList () . flatMap { leak -> leak . leakTraces . map { leakTrace -> leak to leakTrace } } if ( allLeakTraces . isEmpty ()) { // Track how often we perform a heap analysis that yields no result. bugsnagClient . notify ( NoLeakException ()) { event -> event . addHeapAnalysis ( heapAnalysis ) true } } else { allLeakTraces . forEach { ( leak , leakTrace ) -> val message = \"Memory leak: ${ leak . shortDescription } . See LEAK tab.\" val exception = leakTrace . asFakeException ( message ) bugsnagClient . notify ( exception ) { event -> event . addHeapAnalysis ( heapAnalysis ) event . addLeak ( leak ) event . addLeakTrace ( leakTrace ) event . groupingHash = leak . signature true } } } } is HeapAnalysisFailure -> { // Please file any reported failure to // https://github.com/square/leakcanary/issues bugsnagClient . notify ( heapAnalysis . exception ) } } } class NoLeakException : RuntimeException () private fun Event . addHeapAnalysis ( heapAnalysis : HeapAnalysisSuccess ) { addMetadata ( \"Leak\" , \"heapDumpPath\" , heapAnalysis . heapDumpFile . absolutePath ) heapAnalysis . metadata . forEach { ( key , value ) -> addMetadata ( \"Leak\" , key , value ) } addMetadata ( \"Leak\" , \"analysisDurationMs\" , heapAnalysis . analysisDurationMillis ) } private fun Event . addLeak ( leak : Leak ) { addMetadata ( \"Leak\" , \"libraryLeak\" , leak is LibraryLeak ) if ( leak is LibraryLeak ) { addMetadata ( \"Leak\" , \"libraryLeakPattern\" , leak . pattern . toString ()) addMetadata ( \"Leak\" , \"libraryLeakDescription\" , leak . description ) } } private fun Event . addLeakTrace ( leakTrace : LeakTrace ) { addMetadata ( \"Leak\" , \"retainedHeapByteSize\" , leakTrace . retainedHeapByteSize ) addMetadata ( \"Leak\" , \"signature\" , leakTrace . signature ) addMetadata ( \"Leak\" , \"leakTrace\" , leakTrace . toString ()) } private fun LeakTrace . asFakeException ( message : String ): RuntimeException { val exception = RuntimeException ( message ) val stackTrace = mutableListOf < StackTraceElement > () stackTrace . add ( StackTraceElement ( \"GcRoot\" , gcRootType . name , \"GcRoot.kt\" , 42 )) for ( cause in referencePath ) { stackTrace . add ( buildStackTraceElement ( cause )) } exception . stackTrace = stackTrace . toTypedArray () return exception } private fun buildStackTraceElement ( reference : LeakTraceReference ): StackTraceElement { val file = reference . owningClassName . substringAfterLast ( \".\" ) + \".kt\" return StackTraceElement ( reference . owningClassName , reference . referenceDisplayName , file , 42 ) } }","title":"LeakCanary for releases"},{"location":"leakcanary-for-releases/#leakcanary-for-releases","text":"Fixing leaks found in debug builds helps reduce Application Not Responding freezes and OutfOfMemoryError error crashes, but only scratches the surface of all the leaks that can happen. For the leaks that are found in debug builds, it\u2019s hard to determine which leaks to fix first. This situation is very similar to debug crashes, where we are often unable to make an accurate assessment of their future impact in a production environment nor find all crashes that will happen in production. For crashes, apps typically monitor a crash rate by having a release crash reporting pipeline, with counts to prioritize fixes. LeakCanary for releases exposes APIs to run a heap analysis in release builds, in production. Danger Everything about this is experimental. Running a heap analysis in production is not a very common thing to do, and we\u2019re still learning and experimenting with this. Also, both the artifact name and the APIs may change.","title":"LeakCanary for releases"},{"location":"leakcanary-for-releases/#getting-started","text":"LeakCanary provides an artifact dedicated to detecting leaks in release builds: dependencies { // LeakCanary for releases releaseImplementation 'com.squareup.leakcanary:leakcanary-android-release:2.10' // Optional: detect retained objects. This helps but is not required. releaseImplementation 'com.squareup.leakcanary:leakcanary-object-watcher-android:2.10' } Here\u2019s a code example that runs a heap analysis when the screen is turned off or the app enters background, checking first if a Firebase Remote Config flag is turned on, and uploading the result to Bugsnag: import android.os.Process.THREAD_PRIORITY_BACKGROUND import java.util.concurrent.Executors import kotlin.concurrent.thread import leakcanary.BackgroundTrigger import leakcanary.HeapAnalysisClient import leakcanary.HeapAnalysisConfig import leakcanary.HeapAnalysisInterceptor import leakcanary.HeapAnalysisInterceptor.Chain import leakcanary.HeapAnalysisJob import leakcanary.HeapAnalysisJob.Result.Done import leakcanary.ScreenOffTrigger class ReleaseExampleApplication : ExampleApplication () { override fun onCreate () { super . onCreate () // Delete any remaining heap dump (if we crashed) analysisExecutor . execute { analysisClient . deleteHeapDumpFiles () } // Starts heap analysis on background importance BackgroundTrigger ( application = this , analysisClient = analysisClient , analysisExecutor = analysisExecutor , analysisCallback = analysisCallback ). start () // Starts heap analysis when screen off ScreenOffTrigger ( application = this , analysisClient = analysisClient , analysisExecutor = analysisExecutor , analysisCallback = analysisCallback ). start () } /** * Call this to trigger heap analysis manually, e.g. from * a help button. * * This method returns a `HeapAnalysisJob` on which you can * call `HeapAnalysisJob.cancel()` at any time. */ fun triggerHeapAnalysisNow (): HeapAnalysisJob { val job = analysisClient . newJob () analysisExecutor . execute { val result = job . execute () analysisCallback ( result ) } return job } private val analysisClient by lazy { HeapAnalysisClient ( // Use private app storage. cacheDir is never backed up which is important. heapDumpDirectoryProvider = { cacheDir }, // stripHeapDump: remove all user data from hprof before analysis. config = HeapAnalysisConfig ( stripHeapDump = true ), // Default interceptors may cancel analysis for several other reasons. interceptors = listOf ( flagInterceptor ) + HeapAnalysisClient . defaultInterceptors ( this ) ) } // Cancels heap analysis if \"heap_analysis_flag\" is false. private val flagInterceptor = object : HeapAnalysisInterceptor { val remoteConfig by lazy { FirebaseRemoteConfig . getInstance () } override fun intercept ( chain : Chain ): HeapAnalysisJob . Result { if ( remoteConfig . getBoolean ( \"heap_analysis_flag\" )) { chain . job . cancel ( \"heap_analysis_flag false\" ) } return chain . proceed () } } private val analysisExecutor = Executors . newSingleThreadExecutor { thread ( start = false , name = \"Heap analysis executor\" ) { android . os . Process . setThreadPriority ( THREAD_PRIORITY_BACKGROUND ) it . run () } } private val analysisCallback : ( HeapAnalysisJob . Result ) -> Unit = { result -> if ( result is Done ) { uploader . upload ( result . analysis ) } } private val uploader by lazy { BugsnagLeakUploader ( this @ReleaseExampleApplication ) } } Here\u2019s the BugsnagLeakUploader : import android.app.Application import com.bugsnag.android.Bugsnag import com.bugsnag.android.Configuration import com.bugsnag.android.ErrorTypes import com.bugsnag.android.Event import com.bugsnag.android.ThreadSendPolicy import shark.HeapAnalysis import shark.HeapAnalysisFailure import shark.HeapAnalysisSuccess import shark.Leak import shark.LeakTrace import shark.LeakTraceReference import shark.LibraryLeak class BugsnagLeakUploader ( applicationContext : Application ) { private val bugsnagClient = Bugsnag . start ( applicationContext , Configuration ( \"YOUR_BUGSNAG_API_KEY\" ). apply { enabledErrorTypes = ErrorTypes ( anrs = false , ndkCrashes = false , unhandledExceptions = false , unhandledRejections = false ) sendThreads = ThreadSendPolicy . NEVER } ) fun upload ( heapAnalysis : HeapAnalysis ) { when ( heapAnalysis ) { is HeapAnalysisSuccess -> { val allLeakTraces = heapAnalysis . allLeaks . toList () . flatMap { leak -> leak . leakTraces . map { leakTrace -> leak to leakTrace } } if ( allLeakTraces . isEmpty ()) { // Track how often we perform a heap analysis that yields no result. bugsnagClient . notify ( NoLeakException ()) { event -> event . addHeapAnalysis ( heapAnalysis ) true } } else { allLeakTraces . forEach { ( leak , leakTrace ) -> val message = \"Memory leak: ${ leak . shortDescription } . See LEAK tab.\" val exception = leakTrace . asFakeException ( message ) bugsnagClient . notify ( exception ) { event -> event . addHeapAnalysis ( heapAnalysis ) event . addLeak ( leak ) event . addLeakTrace ( leakTrace ) event . groupingHash = leak . signature true } } } } is HeapAnalysisFailure -> { // Please file any reported failure to // https://github.com/square/leakcanary/issues bugsnagClient . notify ( heapAnalysis . exception ) } } } class NoLeakException : RuntimeException () private fun Event . addHeapAnalysis ( heapAnalysis : HeapAnalysisSuccess ) { addMetadata ( \"Leak\" , \"heapDumpPath\" , heapAnalysis . heapDumpFile . absolutePath ) heapAnalysis . metadata . forEach { ( key , value ) -> addMetadata ( \"Leak\" , key , value ) } addMetadata ( \"Leak\" , \"analysisDurationMs\" , heapAnalysis . analysisDurationMillis ) } private fun Event . addLeak ( leak : Leak ) { addMetadata ( \"Leak\" , \"libraryLeak\" , leak is LibraryLeak ) if ( leak is LibraryLeak ) { addMetadata ( \"Leak\" , \"libraryLeakPattern\" , leak . pattern . toString ()) addMetadata ( \"Leak\" , \"libraryLeakDescription\" , leak . description ) } } private fun Event . addLeakTrace ( leakTrace : LeakTrace ) { addMetadata ( \"Leak\" , \"retainedHeapByteSize\" , leakTrace . retainedHeapByteSize ) addMetadata ( \"Leak\" , \"signature\" , leakTrace . signature ) addMetadata ( \"Leak\" , \"leakTrace\" , leakTrace . toString ()) } private fun LeakTrace . asFakeException ( message : String ): RuntimeException { val exception = RuntimeException ( message ) val stackTrace = mutableListOf < StackTraceElement > () stackTrace . add ( StackTraceElement ( \"GcRoot\" , gcRootType . name , \"GcRoot.kt\" , 42 )) for ( cause in referencePath ) { stackTrace . add ( buildStackTraceElement ( cause )) } exception . stackTrace = stackTrace . toTypedArray () return exception } private fun buildStackTraceElement ( reference : LeakTraceReference ): StackTraceElement { val file = reference . owningClassName . substringAfterLast ( \".\" ) + \".kt\" return StackTraceElement ( reference . owningClassName , reference . referenceDisplayName , file , 42 ) } }","title":"Getting started"},{"location":"recipes/","text":"Code Recipes \u00b6 This page contains code recipes to customize LeakCanary to your needs. Read through the section titles and cook your own meal! Also don\u2019t forget to check out the FAQ . Bug If you think a recipe might be missing or you\u2019re not sure that what you\u2019re trying to achieve is possible with the current APIs, please file an issue . Your feedback helps us make LeakCanary better for the entire community. Watching objects with a lifecycle \u00b6 The default configuration of LeakCanary will automatically watch Activity, Fragment, Fragment View and ViewModel instances. In your application, you may have other objects with a lifecycle, such as services, Dagger components, etc. Use AppWatcher.objectWatcher to watch instances that should be garbage collected: class MyService : Service { // ... override fun onDestroy () { super . onDestroy () AppWatcher . objectWatcher . watch ( watchedObject = this , description = \"MyService received Service#onDestroy() callback\" ) } } Configuration \u00b6 LeakCanary has a default configuration that works well for most apps. You can also customize it to your needs. The LeakCanary configuration is held by two singleton objects ( AppWatcher and LeakCanary ) and can be updated at any time. Most developers configure LeakCanary in their debug Application class: class DebugExampleApplication : ExampleApplication () { override fun onCreate () { super . onCreate () AppWatcher . config = AppWatcher . config . copy ( watchFragmentViews = false ) } } Info Create a debug application class in your src/debug/java folder. Don\u2019t forget to also register it in src/debug/AndroidManifest.xml . To customize the detection of retained objects at runtime, specify the watchers you wish to install via AppWatcher.manualInstall() : val watchersToInstall = AppWatcher . appDefaultWatchers ( this ) . filter { it !is FragmentAndViewModelWatcher } AppWatcher . manualInstall ( application = this , watchersToInstall = watchersToInstall ) To customize the heap dumping & analysis, update LeakCanary.config : LeakCanary . config = LeakCanary . config . copy ( retainedVisibleThreshold = 3 ) Java In Java, use LeakCanary.Config.Builder instead: LeakCanary . Config config = LeakCanary . getConfig (). newBuilder () . retainedVisibleThreshold ( 3 ) . build (); LeakCanary . setConfig ( config ); Configure the LeakCanary UI by overriding the following resources: mipmap/leak_canary_icon see Icon and label string/leak_canary_display_activity_label see Icon and label bool/leak_canary_add_dynamic_shortcut see Disabling LeakCanary bool/leak_canary_add_launcher_icon see Disabling LeakCanary layout/leak_canary_heap_dump_toast the layout for the toast shown when the heap is dumped Disabling LeakCanary \u00b6 Sometimes it\u2019s necessary to disable LeakCanary temporarily, for example for a product demo or when running performance tests. You have different options, depending on what you\u2019re trying to achieve: Create a build variant that does not include the LeakCanary dependencies, see Setting up LeakCanary for different product flavors . Disable the heap dumping & analysis: LeakCanary.config = LeakCanary.config.copy(dumpHeap = false) . Hide the leak display activity launcher icon: override R.bool.leak_canary_add_launcher_icon or call LeakCanary.showLeakDisplayActivityLauncherIcon(false) Info When you set LeakCanary.Config.dumpHeap to false , AppWatcher.objectWatcher will still keep track of retained objects, and LeakCanary will look for these objects when you change LeakCanary.Config.dumpHeap back to true . LeakCanary test environment detection \u00b6 By default, LeakCanary will look for the org.junit.Test class in your classpath and if found, will disable itself to avoid running in tests. However, some apps may ship JUnit in their debug classpaths (for example, when using OkHttp\u2019s MockWebServer) so we offer a way to customise the class that is used to determine that the app is running in a test environment. <resources> <string name= \"leak_canary_test_class_name\" > assertk.Assert </string> </resources> Counting retained instances in release builds \u00b6 The com.squareup.leakcanary:leakcanary-android dependency should only be used in debug builds. It depends on com.squareup.leakcanary:leakcanary-object-watcher-android which you can use in release builds to track and count retained instances. In your build.gradle : dependencies { implementation 'com.squareup.leakcanary:leakcanary-object-watcher-android:2.10' } In your leak reporting code: val retainedInstanceCount = AppWatcher . objectWatcher . retainedObjectCount LeakCanary in release builds \u00b6 We do not recommend including LeakCanary in release builds, as it could negatively impact the experience of your customers. To avoid accidentally including the com.squareup.leakcanary:leakcanary-android dependency in a release build, LeakCanary crashes during initialization if the APK is not debuggable. You may have a good reason to create a non debuggable build that includes LeakCanary, for example for a QA build. If necessary, the crashing check can be disabled by overriding the bool/leak_canary_allow_in_non_debuggable_build resource, e.g. by creating a file under res/values with the following contents: <?xml version=\"1.0\" encoding=\"utf-8\"?> <resources> <bool name= \"leak_canary_allow_in_non_debuggable_build\" > true </bool> </resources> Android TV \u00b6 LeakCanary works on Android TV devices (FireTV, Nexus player, Nvidia Shield, MiBox, etc.) without any additional setup. However, there are couple things you need to be aware of: Android TV doesn\u2019t have notifications. LeakCanary will display Toast messages when objects become retained and when leak analysis completes. You can also check Logcat for more details. Due to lack of notifications, the only way to manually trigger a heap dump is to background the app. There\u2019s a bug on API 26+ devices that prevents the activity that displays leaks from appearing in apps list. As a workaround, LeakCanary prints an adb shell command in Logcat after heap dump analysis that launches leak list activity: adb shell am start -n \"com.your.package.name/leakcanary.internal.activity.LeakLauncherActivity\" Some Android TV devices have very little memory available per app process and this might impact LeakCanary. Running the LeakCanary analysis in a separate process might help in such cases. Icon and label \u00b6 The activity that displays leaks comes with a default icon and label, which you can change by providing R.mipmap.leak_canary_icon and R.string.leak_canary_display_activity_label in your app: res/ mipmap-hdpi/ leak_canary_icon.png mipmap-mdpi/ leak_canary_icon.png mipmap-xhdpi/ leak_canary_icon.png mipmap-xxhdpi/ leak_canary_icon.png mipmap-xxxhdpi/ leak_canary_icon.png mipmap-anydpi-v26/ leak_canary_icon.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <resources> <string name= \"leak_canary_display_activity_label\" > MyLeaks </string> </resources> Matching known library leaks \u00b6 Set LeakCanary.Config.referenceMatchers to a list that builds on top of AndroidReferenceMatchers.appDefaults : class DebugExampleApplication : ExampleApplication () { override fun onCreate () { super . onCreate () LeakCanary . config = LeakCanary . config . copy ( referenceMatchers = AndroidReferenceMatchers . appDefaults + AndroidReferenceMatchers . staticFieldLeak ( className = \"com.samsing.SomeSingleton\" , fieldName = \"sContext\" , description = \"SomeSingleton has a static field leaking a context.\" , patternApplies = { manufacturer == \"Samsing\" && sdkInt == 26 } ) ) } } Ignoring specific activities or fragment classes \u00b6 Sometimes a 3 rd party library provides its own activities or fragments which contain a number of bugs leading to leaks of those specific 3 rd party activities and fragments. You should push hard on that library to fix their memory leaks as it\u2019s directly impacting your application. That being said, until those are fixed, you have two options: Add the specific leaks as known library leaks (see Matching known library leaks ). LeakCanary will run when those leaks are detected and then report them as known library leaks. Disable LeakCanary automatic activity or fragment watching (e.g. AppWatcher.config = AppWatcher.config.copy(watchActivities = false) ) and then manually pass objects to AppWatcher.objectWatcher.watch . Identifying leaking objects and labeling objects \u00b6 class DebugExampleApplication : ExampleApplication () { override fun onCreate () { super . onCreate () val addEntityIdLabel = ObjectInspector { reporter -> reporter . whenInstanceOf ( \"com.example.DbEntity\" ) { instance -> val databaseIdField = instance [ \"com.example.DbEntity\" , \"databaseId\" ]!! val databaseId = databaseIdField . value . asInt !! labels += \"DbEntity.databaseId = $ databaseId \" } } val singletonsInspector = AppSingletonInspector ( \"com.example.MySingleton\" , \"com.example.OtherSingleton\" ) val mmvmInspector = ObjectInspector { reporter -> reporter . whenInstanceOf ( \"com.mmvm.SomeViewModel\" ) { instance -> val destroyedField = instance [ \"com.mmvm.SomeViewModel\" , \"destroyed\" ]!! if ( destroyedField . value . asBoolean !! ) { leakingReasons += \"SomeViewModel.destroyed is true\" } else { notLeakingReasons += \"SomeViewModel.destroyed is false\" } } } LeakCanary . config = LeakCanary . config . copy ( objectInspectors = AndroidObjectInspectors . appDefaults + listOf ( addObjectIdLabel , singletonsInspector , mmvmInspector ) ) } } Running the LeakCanary analysis in a separate process \u00b6 LeakCanary runs in your main app process. LeakCanary 2 is optimized to keep memory usage low while analysing and runs in a background thread with priority Process.THREAD_PRIORITY_BACKGROUND . If you find that LeakCanary is still using too much memory or impacting the app process performance, you can configure it to run the analysis in a separate process. All you have to do is replace the leakcanary-android dependency with leakcanary-android-process : dependencies { // debugImplementation 'com.squareup.leakcanary:leakcanary-android:${version}' debugImplementation 'com.squareup.leakcanary:leakcanary-android-process:${version}' } You can call LeakCanaryProcess.isInAnalyzerProcess to check if your Application class is being created in the LeakCanary process. This is useful when configuring libraries like Firebase that may crash when running in an unexpected process. Setting up LeakCanary for different product flavors \u00b6 You can setup LeakCanary to run in a specific product flavors of your app. For example, create: android { flavorDimensions \"default\" productFlavors { prod { // ... } qa { // ... } dev { // ... } } } Then, define a custom configuration for the flavor for which you want to enable LeakCanary: android { // ... } configurations { devDebugImplementation {} } You can now add the LeakCanary dependency for that configuration: dependencies { devDebugImplementation \"com.squareup.leakcanary:leakcanary-android:${version}\" } Extracting metadata from the heap dump \u00b6 LeakCanary.Config.metadataExtractor extracts metadata from a heap dump. The metadata is then available in HeapAnalysisSuccess.metadata . LeakCanary.Config.metadataExtractor defaults to AndroidMetadataExtractor but you can replace it to extract additional metadata from the hprof. For example, if you want to include the app version name in your heap analysis reports, you need to first store it in memory (e.g. in a static field) and then you can retrieve it in MetadataExtractor . class DebugExampleApplication : ExampleApplication () { companion object { @JvmStatic lateinit var savedVersionName : String } override fun onCreate () { super . onCreate () val packageInfo = packageManager . getPackageInfo ( packageName , 0 ) savedVersionName = packageInfo . versionName LeakCanary . config = LeakCanary . config . copy ( metadataExtractor = MetadataExtractor { graph -> val companionClass = graph . findClassByName ( \"com.example.DebugExampleApplication\" ) !! val versionNameField = companionClass [ \"savedVersionName\" ]!! val versionName = versionNameField . valueAsInstance !! . readAsJavaString () !! val defaultMetadata = AndroidMetadataExtractor . extractMetadata ( graph ) mapOf ( \"App Version Name\" to versionName ) + defaultMetadata }) } } Using LeakCanary with obfuscated apps \u00b6 If obfuscation is turned on then leak traces will be obfuscated. It\u2019s possible to automatically deobfuscate leak traces by using a deobfuscation gradle plugin provided by LeakCanary. You have to add a plugin dependency in your root build.gradle file: buildscript { dependencies { classpath 'com.squareup.leakcanary:leakcanary-deobfuscation-gradle-plugin:${version}' } } And then you need to apply and configure the plugin in your app (or library) specific build.gradle file: apply plugin: 'com.android.application' apply plugin: 'com.squareup.leakcanary.deobfuscation' leakCanary { // LeakCanary needs to know which variants have obfuscation turned on filterObfuscatedVariants { variant -> variant . name == \"debug\" } } Now you can run LeakCanary on an obfuscated app and leak traces will be automatically deobfuscated. Important: never use this plugin on a release variant. This plugin copies obfuscation mapping file and puts it inside the .apk, so if you use it on release build then the obfuscation becomes pointless because the code can be easily deobfuscated using mapping file. Warning: R8 (Google Proguard replacement) can now understand Kotlin language constructs but the side effect is that mapping files can get very large (a couple dozen megabytes). It means that the size of .apk containing copied mapping file will increase as well. This is another reason for not using this plugin on a release variant. Detecting leaks in JVM applications \u00b6 While LeakCanary was designed to work out of the box on Android, it can run on any JVM with a bit of configuration. Add the ObjectWatcher and Shark dependencies to your build file: dependencies { implementation 'com.squareup.leakcanary:leakcanary-object-watcher:2.10' implementation 'com.squareup.leakcanary:shark:2.10' } Define a HotSpotHeapDumper to dump the heap: import com.sun.management.HotSpotDiagnosticMXBean import java.lang.management.ManagementFactory object HotSpotHeapDumper { private val mBean : HotSpotDiagnosticMXBean by lazy { val server = ManagementFactory . getPlatformMBeanServer () ManagementFactory . newPlatformMXBeanProxy ( server , \"com.sun.management:type=HotSpotDiagnostic\" , HotSpotDiagnosticMXBean :: class . java ) } fun dumpHeap ( fileName : String ) { mBean . dumpHeap ( fileName , LIVE ) } private const val LIVE = true } Define a JvmHeapAnalyzer to analyze the heap when objects are retained and print the result to the console: import leakcanary.GcTrigger import leakcanary.ObjectWatcher import leakcanary.OnObjectRetainedListener import java.io.File import java.text.SimpleDateFormat import java.util.Date import java.util.Locale.US class JvmHeapAnalyzer ( private val objectWatcher : ObjectWatcher ) : OnObjectRetainedListener { private val fileNameFormat = SimpleDateFormat ( DATE_PATTERN , US ) override fun onObjectRetained () { GcTrigger . Default . runGc () if ( objectWatcher . retainedObjectCount == 0 ) { return } val fileName = fileNameFormat . format ( Date ()) val hprofFile = File ( fileName ) println ( \"Dumping the heap to ${ hprofFile . absolutePath } \" ) HotSpotHeapDumper . dumpHeap ( hprofFile . absolutePath ) val analyzer = HeapAnalyzer ( OnAnalysisProgressListener { step -> println ( \"Analysis in progress, working on: ${ step . name } \" ) }) val heapDumpAnalysis = analyzer . analyze ( heapDumpFile = hprofFile , leakingObjectFinder = KeyedWeakReferenceFinder , computeRetainedHeapSize = true , objectInspectors = ObjectInspectors . jdkDefaults ) println ( heapDumpAnalysis ) } companion object { private const val DATE_PATTERN = \"yyyy-MM-dd_HH-mm-ss_SSS'.hprof'\" } } Create an ObjectWatcher instance and configure it to watch objects for 5 seconds before notifying a JvmHeapAnalyzer instance: val scheduledExecutor = Executors . newSingleThreadScheduledExecutor () val objectWatcher = ObjectWatcher ( clock = Clock { System . currentTimeMillis () }, checkRetainedExecutor = Executor { command -> scheduledExecutor . schedule ( command , 5 , SECONDS ) } ) val heapAnalyzer = JvmHeapAnalyzer ( objectWatcher ) objectWatcher . addOnObjectRetainedListener ( heapAnalyzer ) Pass objects that you expect to be garbage collected (e.g. closed resources) to the ObjectWatcher instance: objectWatcher . watch ( watchedObject = closedResource , description = \" $ closedResource is closed and should be garbage collected\" ) If you end up using LeakCanary on a JVM, the community will definitely benefit from your experience, so don\u2019t hesitate to let us know ! PackageManager.getLaunchIntentForPackage() returns LeakLauncherActivity \u00b6 LeakCanary adds a main activity that has a Intent#CATEGORY_LAUNCHER category. PackageManager.getLaunchIntentForPackage() looks for a main activity in the category Intent#CATEGORY_INFO , and next for a main activity in the category Intent#CATEGORY_LAUNCHER . PackageManager.getLaunchIntentForPackage() returns the first activity that matches in the merged manifest of your app. If your app relies on PackageManager.getLaunchIntentForPackage() , you have two options: Add Intent#CATEGORY_INFO to your main activity intent filter, so that it gets picked up first. This is what the Android documentation recommends. Disable the leakcanary launcher activity by setting the leak_canary_add_launcher_icon resource boolean to false.","title":"Code recipes"},{"location":"recipes/#code-recipes","text":"This page contains code recipes to customize LeakCanary to your needs. Read through the section titles and cook your own meal! Also don\u2019t forget to check out the FAQ . Bug If you think a recipe might be missing or you\u2019re not sure that what you\u2019re trying to achieve is possible with the current APIs, please file an issue . Your feedback helps us make LeakCanary better for the entire community.","title":"Code Recipes"},{"location":"recipes/#watching-objects-with-a-lifecycle","text":"The default configuration of LeakCanary will automatically watch Activity, Fragment, Fragment View and ViewModel instances. In your application, you may have other objects with a lifecycle, such as services, Dagger components, etc. Use AppWatcher.objectWatcher to watch instances that should be garbage collected: class MyService : Service { // ... override fun onDestroy () { super . onDestroy () AppWatcher . objectWatcher . watch ( watchedObject = this , description = \"MyService received Service#onDestroy() callback\" ) } }","title":"Watching objects with a lifecycle"},{"location":"recipes/#configuration","text":"LeakCanary has a default configuration that works well for most apps. You can also customize it to your needs. The LeakCanary configuration is held by two singleton objects ( AppWatcher and LeakCanary ) and can be updated at any time. Most developers configure LeakCanary in their debug Application class: class DebugExampleApplication : ExampleApplication () { override fun onCreate () { super . onCreate () AppWatcher . config = AppWatcher . config . copy ( watchFragmentViews = false ) } } Info Create a debug application class in your src/debug/java folder. Don\u2019t forget to also register it in src/debug/AndroidManifest.xml . To customize the detection of retained objects at runtime, specify the watchers you wish to install via AppWatcher.manualInstall() : val watchersToInstall = AppWatcher . appDefaultWatchers ( this ) . filter { it !is FragmentAndViewModelWatcher } AppWatcher . manualInstall ( application = this , watchersToInstall = watchersToInstall ) To customize the heap dumping & analysis, update LeakCanary.config : LeakCanary . config = LeakCanary . config . copy ( retainedVisibleThreshold = 3 ) Java In Java, use LeakCanary.Config.Builder instead: LeakCanary . Config config = LeakCanary . getConfig (). newBuilder () . retainedVisibleThreshold ( 3 ) . build (); LeakCanary . setConfig ( config ); Configure the LeakCanary UI by overriding the following resources: mipmap/leak_canary_icon see Icon and label string/leak_canary_display_activity_label see Icon and label bool/leak_canary_add_dynamic_shortcut see Disabling LeakCanary bool/leak_canary_add_launcher_icon see Disabling LeakCanary layout/leak_canary_heap_dump_toast the layout for the toast shown when the heap is dumped","title":"Configuration"},{"location":"recipes/#disabling-leakcanary","text":"Sometimes it\u2019s necessary to disable LeakCanary temporarily, for example for a product demo or when running performance tests. You have different options, depending on what you\u2019re trying to achieve: Create a build variant that does not include the LeakCanary dependencies, see Setting up LeakCanary for different product flavors . Disable the heap dumping & analysis: LeakCanary.config = LeakCanary.config.copy(dumpHeap = false) . Hide the leak display activity launcher icon: override R.bool.leak_canary_add_launcher_icon or call LeakCanary.showLeakDisplayActivityLauncherIcon(false) Info When you set LeakCanary.Config.dumpHeap to false , AppWatcher.objectWatcher will still keep track of retained objects, and LeakCanary will look for these objects when you change LeakCanary.Config.dumpHeap back to true .","title":"Disabling LeakCanary"},{"location":"recipes/#leakcanary-test-environment-detection","text":"By default, LeakCanary will look for the org.junit.Test class in your classpath and if found, will disable itself to avoid running in tests. However, some apps may ship JUnit in their debug classpaths (for example, when using OkHttp\u2019s MockWebServer) so we offer a way to customise the class that is used to determine that the app is running in a test environment. <resources> <string name= \"leak_canary_test_class_name\" > assertk.Assert </string> </resources>","title":"LeakCanary test environment detection"},{"location":"recipes/#counting-retained-instances-in-release-builds","text":"The com.squareup.leakcanary:leakcanary-android dependency should only be used in debug builds. It depends on com.squareup.leakcanary:leakcanary-object-watcher-android which you can use in release builds to track and count retained instances. In your build.gradle : dependencies { implementation 'com.squareup.leakcanary:leakcanary-object-watcher-android:2.10' } In your leak reporting code: val retainedInstanceCount = AppWatcher . objectWatcher . retainedObjectCount","title":"Counting retained instances in release builds"},{"location":"recipes/#leakcanary-in-release-builds","text":"We do not recommend including LeakCanary in release builds, as it could negatively impact the experience of your customers. To avoid accidentally including the com.squareup.leakcanary:leakcanary-android dependency in a release build, LeakCanary crashes during initialization if the APK is not debuggable. You may have a good reason to create a non debuggable build that includes LeakCanary, for example for a QA build. If necessary, the crashing check can be disabled by overriding the bool/leak_canary_allow_in_non_debuggable_build resource, e.g. by creating a file under res/values with the following contents: <?xml version=\"1.0\" encoding=\"utf-8\"?> <resources> <bool name= \"leak_canary_allow_in_non_debuggable_build\" > true </bool> </resources>","title":"LeakCanary in release builds"},{"location":"recipes/#android-tv","text":"LeakCanary works on Android TV devices (FireTV, Nexus player, Nvidia Shield, MiBox, etc.) without any additional setup. However, there are couple things you need to be aware of: Android TV doesn\u2019t have notifications. LeakCanary will display Toast messages when objects become retained and when leak analysis completes. You can also check Logcat for more details. Due to lack of notifications, the only way to manually trigger a heap dump is to background the app. There\u2019s a bug on API 26+ devices that prevents the activity that displays leaks from appearing in apps list. As a workaround, LeakCanary prints an adb shell command in Logcat after heap dump analysis that launches leak list activity: adb shell am start -n \"com.your.package.name/leakcanary.internal.activity.LeakLauncherActivity\" Some Android TV devices have very little memory available per app process and this might impact LeakCanary. Running the LeakCanary analysis in a separate process might help in such cases.","title":"Android TV"},{"location":"recipes/#icon-and-label","text":"The activity that displays leaks comes with a default icon and label, which you can change by providing R.mipmap.leak_canary_icon and R.string.leak_canary_display_activity_label in your app: res/ mipmap-hdpi/ leak_canary_icon.png mipmap-mdpi/ leak_canary_icon.png mipmap-xhdpi/ leak_canary_icon.png mipmap-xxhdpi/ leak_canary_icon.png mipmap-xxxhdpi/ leak_canary_icon.png mipmap-anydpi-v26/ leak_canary_icon.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <resources> <string name= \"leak_canary_display_activity_label\" > MyLeaks </string> </resources>","title":"Icon and label"},{"location":"recipes/#matching-known-library-leaks","text":"Set LeakCanary.Config.referenceMatchers to a list that builds on top of AndroidReferenceMatchers.appDefaults : class DebugExampleApplication : ExampleApplication () { override fun onCreate () { super . onCreate () LeakCanary . config = LeakCanary . config . copy ( referenceMatchers = AndroidReferenceMatchers . appDefaults + AndroidReferenceMatchers . staticFieldLeak ( className = \"com.samsing.SomeSingleton\" , fieldName = \"sContext\" , description = \"SomeSingleton has a static field leaking a context.\" , patternApplies = { manufacturer == \"Samsing\" && sdkInt == 26 } ) ) } }","title":"Matching known library leaks"},{"location":"recipes/#ignoring-specific-activities-or-fragment-classes","text":"Sometimes a 3 rd party library provides its own activities or fragments which contain a number of bugs leading to leaks of those specific 3 rd party activities and fragments. You should push hard on that library to fix their memory leaks as it\u2019s directly impacting your application. That being said, until those are fixed, you have two options: Add the specific leaks as known library leaks (see Matching known library leaks ). LeakCanary will run when those leaks are detected and then report them as known library leaks. Disable LeakCanary automatic activity or fragment watching (e.g. AppWatcher.config = AppWatcher.config.copy(watchActivities = false) ) and then manually pass objects to AppWatcher.objectWatcher.watch .","title":"Ignoring specific activities or fragment classes"},{"location":"recipes/#identifying-leaking-objects-and-labeling-objects","text":"class DebugExampleApplication : ExampleApplication () { override fun onCreate () { super . onCreate () val addEntityIdLabel = ObjectInspector { reporter -> reporter . whenInstanceOf ( \"com.example.DbEntity\" ) { instance -> val databaseIdField = instance [ \"com.example.DbEntity\" , \"databaseId\" ]!! val databaseId = databaseIdField . value . asInt !! labels += \"DbEntity.databaseId = $ databaseId \" } } val singletonsInspector = AppSingletonInspector ( \"com.example.MySingleton\" , \"com.example.OtherSingleton\" ) val mmvmInspector = ObjectInspector { reporter -> reporter . whenInstanceOf ( \"com.mmvm.SomeViewModel\" ) { instance -> val destroyedField = instance [ \"com.mmvm.SomeViewModel\" , \"destroyed\" ]!! if ( destroyedField . value . asBoolean !! ) { leakingReasons += \"SomeViewModel.destroyed is true\" } else { notLeakingReasons += \"SomeViewModel.destroyed is false\" } } } LeakCanary . config = LeakCanary . config . copy ( objectInspectors = AndroidObjectInspectors . appDefaults + listOf ( addObjectIdLabel , singletonsInspector , mmvmInspector ) ) } }","title":"Identifying leaking objects and labeling objects"},{"location":"recipes/#running-the-leakcanary-analysis-in-a-separate-process","text":"LeakCanary runs in your main app process. LeakCanary 2 is optimized to keep memory usage low while analysing and runs in a background thread with priority Process.THREAD_PRIORITY_BACKGROUND . If you find that LeakCanary is still using too much memory or impacting the app process performance, you can configure it to run the analysis in a separate process. All you have to do is replace the leakcanary-android dependency with leakcanary-android-process : dependencies { // debugImplementation 'com.squareup.leakcanary:leakcanary-android:${version}' debugImplementation 'com.squareup.leakcanary:leakcanary-android-process:${version}' } You can call LeakCanaryProcess.isInAnalyzerProcess to check if your Application class is being created in the LeakCanary process. This is useful when configuring libraries like Firebase that may crash when running in an unexpected process.","title":"Running the LeakCanary analysis in a separate process"},{"location":"recipes/#setting-up-leakcanary-for-different-product-flavors","text":"You can setup LeakCanary to run in a specific product flavors of your app. For example, create: android { flavorDimensions \"default\" productFlavors { prod { // ... } qa { // ... } dev { // ... } } } Then, define a custom configuration for the flavor for which you want to enable LeakCanary: android { // ... } configurations { devDebugImplementation {} } You can now add the LeakCanary dependency for that configuration: dependencies { devDebugImplementation \"com.squareup.leakcanary:leakcanary-android:${version}\" }","title":"Setting up LeakCanary for different product flavors"},{"location":"recipes/#extracting-metadata-from-the-heap-dump","text":"LeakCanary.Config.metadataExtractor extracts metadata from a heap dump. The metadata is then available in HeapAnalysisSuccess.metadata . LeakCanary.Config.metadataExtractor defaults to AndroidMetadataExtractor but you can replace it to extract additional metadata from the hprof. For example, if you want to include the app version name in your heap analysis reports, you need to first store it in memory (e.g. in a static field) and then you can retrieve it in MetadataExtractor . class DebugExampleApplication : ExampleApplication () { companion object { @JvmStatic lateinit var savedVersionName : String } override fun onCreate () { super . onCreate () val packageInfo = packageManager . getPackageInfo ( packageName , 0 ) savedVersionName = packageInfo . versionName LeakCanary . config = LeakCanary . config . copy ( metadataExtractor = MetadataExtractor { graph -> val companionClass = graph . findClassByName ( \"com.example.DebugExampleApplication\" ) !! val versionNameField = companionClass [ \"savedVersionName\" ]!! val versionName = versionNameField . valueAsInstance !! . readAsJavaString () !! val defaultMetadata = AndroidMetadataExtractor . extractMetadata ( graph ) mapOf ( \"App Version Name\" to versionName ) + defaultMetadata }) } }","title":"Extracting metadata from the heap dump"},{"location":"recipes/#using-leakcanary-with-obfuscated-apps","text":"If obfuscation is turned on then leak traces will be obfuscated. It\u2019s possible to automatically deobfuscate leak traces by using a deobfuscation gradle plugin provided by LeakCanary. You have to add a plugin dependency in your root build.gradle file: buildscript { dependencies { classpath 'com.squareup.leakcanary:leakcanary-deobfuscation-gradle-plugin:${version}' } } And then you need to apply and configure the plugin in your app (or library) specific build.gradle file: apply plugin: 'com.android.application' apply plugin: 'com.squareup.leakcanary.deobfuscation' leakCanary { // LeakCanary needs to know which variants have obfuscation turned on filterObfuscatedVariants { variant -> variant . name == \"debug\" } } Now you can run LeakCanary on an obfuscated app and leak traces will be automatically deobfuscated. Important: never use this plugin on a release variant. This plugin copies obfuscation mapping file and puts it inside the .apk, so if you use it on release build then the obfuscation becomes pointless because the code can be easily deobfuscated using mapping file. Warning: R8 (Google Proguard replacement) can now understand Kotlin language constructs but the side effect is that mapping files can get very large (a couple dozen megabytes). It means that the size of .apk containing copied mapping file will increase as well. This is another reason for not using this plugin on a release variant.","title":"Using LeakCanary with obfuscated apps"},{"location":"recipes/#detecting-leaks-in-jvm-applications","text":"While LeakCanary was designed to work out of the box on Android, it can run on any JVM with a bit of configuration. Add the ObjectWatcher and Shark dependencies to your build file: dependencies { implementation 'com.squareup.leakcanary:leakcanary-object-watcher:2.10' implementation 'com.squareup.leakcanary:shark:2.10' } Define a HotSpotHeapDumper to dump the heap: import com.sun.management.HotSpotDiagnosticMXBean import java.lang.management.ManagementFactory object HotSpotHeapDumper { private val mBean : HotSpotDiagnosticMXBean by lazy { val server = ManagementFactory . getPlatformMBeanServer () ManagementFactory . newPlatformMXBeanProxy ( server , \"com.sun.management:type=HotSpotDiagnostic\" , HotSpotDiagnosticMXBean :: class . java ) } fun dumpHeap ( fileName : String ) { mBean . dumpHeap ( fileName , LIVE ) } private const val LIVE = true } Define a JvmHeapAnalyzer to analyze the heap when objects are retained and print the result to the console: import leakcanary.GcTrigger import leakcanary.ObjectWatcher import leakcanary.OnObjectRetainedListener import java.io.File import java.text.SimpleDateFormat import java.util.Date import java.util.Locale.US class JvmHeapAnalyzer ( private val objectWatcher : ObjectWatcher ) : OnObjectRetainedListener { private val fileNameFormat = SimpleDateFormat ( DATE_PATTERN , US ) override fun onObjectRetained () { GcTrigger . Default . runGc () if ( objectWatcher . retainedObjectCount == 0 ) { return } val fileName = fileNameFormat . format ( Date ()) val hprofFile = File ( fileName ) println ( \"Dumping the heap to ${ hprofFile . absolutePath } \" ) HotSpotHeapDumper . dumpHeap ( hprofFile . absolutePath ) val analyzer = HeapAnalyzer ( OnAnalysisProgressListener { step -> println ( \"Analysis in progress, working on: ${ step . name } \" ) }) val heapDumpAnalysis = analyzer . analyze ( heapDumpFile = hprofFile , leakingObjectFinder = KeyedWeakReferenceFinder , computeRetainedHeapSize = true , objectInspectors = ObjectInspectors . jdkDefaults ) println ( heapDumpAnalysis ) } companion object { private const val DATE_PATTERN = \"yyyy-MM-dd_HH-mm-ss_SSS'.hprof'\" } } Create an ObjectWatcher instance and configure it to watch objects for 5 seconds before notifying a JvmHeapAnalyzer instance: val scheduledExecutor = Executors . newSingleThreadScheduledExecutor () val objectWatcher = ObjectWatcher ( clock = Clock { System . currentTimeMillis () }, checkRetainedExecutor = Executor { command -> scheduledExecutor . schedule ( command , 5 , SECONDS ) } ) val heapAnalyzer = JvmHeapAnalyzer ( objectWatcher ) objectWatcher . addOnObjectRetainedListener ( heapAnalyzer ) Pass objects that you expect to be garbage collected (e.g. closed resources) to the ObjectWatcher instance: objectWatcher . watch ( watchedObject = closedResource , description = \" $ closedResource is closed and should be garbage collected\" ) If you end up using LeakCanary on a JVM, the community will definitely benefit from your experience, so don\u2019t hesitate to let us know !","title":"Detecting leaks in JVM applications"},{"location":"recipes/#packagemanagergetlaunchintentforpackage-returns-leaklauncheractivity","text":"LeakCanary adds a main activity that has a Intent#CATEGORY_LAUNCHER category. PackageManager.getLaunchIntentForPackage() looks for a main activity in the category Intent#CATEGORY_INFO , and next for a main activity in the category Intent#CATEGORY_LAUNCHER . PackageManager.getLaunchIntentForPackage() returns the first activity that matches in the merged manifest of your app. If your app relies on PackageManager.getLaunchIntentForPackage() , you have two options: Add Intent#CATEGORY_INFO to your main activity intent filter, so that it gets picked up first. This is what the Android documentation recommends. Disable the leakcanary launcher activity by setting the leak_canary_add_launcher_icon resource boolean to false.","title":"PackageManager.getLaunchIntentForPackage() returns LeakLauncherActivity"},{"location":"recorded-presentations/","text":"Live leak investigations , investigating leaks on Stack Overflow and fixes for AOSP leaks Fixing leaks in Firefox Shark: Diving into the guts of LeakCanary\u2019s Hprof parser LeakCanary 2: Leaner, Better, Faster, Kotliner! LeakCanary, then what? Nuking Nasty Memory Leaks Memory Leak Hunt , a live investigation. Installing LeakCanary (LeakCanary 1.5) How to use LeakCanary Your presentation should be here, please update this list! Any technical level welcome.","title":"Recorded Presentations"},{"location":"releasing/","text":"Releasing LeakCanary \u00b6 Preparing the release environment \u00b6 Set up your Sonatype OSSRH account \u00b6 Create a Sonatype OSSRH JIRA account . Create a ticket to request access to the com.squareup.leakcanary project. Here\u2019s an example: OSSRH-54959 . Then ask someone with deployer role from the LeakCanary team to confirm access. Set up your signing key \u00b6 # Create a new key gpg --gen-key # List local keys. Key id is last 8 characters gpg -K cd ~/.gnupg # Export key locally gpg --export-secret-keys -o secring.gpg # Upload key to Ubuntu servers gpg --send-keys --keyserver keyserver.ubuntu.com <KEY ID> # Confirm the key can now be found gpg --recv-keys --keyserver keyserver.ubuntu.com <KEY ID> Set up your home gradle.properties \u00b6 Add this to your ~/.gradle/gradle.properties : signing.keyId=<KEY ID> signing.password=<KEY PASSWORD> signing.secretKeyRingFile=/Users/YOUR_USERNAME_/.gnupg/secring.gpg SONATYPE_NEXUS_USERNAME=<SONATYPE_USERNAME> SONATYPE_NEXUS_PASSWORD=<SONATYPE_PASSWORD> Set up the Google Analytics docs key \u00b6 Add this to your ~/.bashrc : export LEAKCANARY_GOOGLE_ANALYTICS_KEY = \"UA-142834539-1\" Set up GitHub CLI \u00b6 Install GitHub CLI brew install gh Install jq, a CLI Json processor brew install jq Set up aliases for milestone management: gh alias set listOpenMilestones \"api graphql -F owner=':owner' -F name=':repo' -f query=' query ListOpenMilestones(\\$name: String\\!, \\$owner: String\\!) { repository(owner: \\$owner, name: \\$name) { milestones(first: 100, states: OPEN) { nodes { title number description dueOn url state closed closedAt updatedAt } } } } '\" gh alias set --shell createMilestone \"gh api --method POST repos/:owner/:repo/milestones --input - | jq '{ html_url: .html_url, state: .state, created_at: .created_at }'\" gh alias set --shell closeMilestone \"echo '{\\\"state\\\": \\\"closed\\\"}' | gh api --method PATCH repos/:owner/:repo/milestones/\\$1 --input - | jq '{ html_url: .html_url, state: .state, closed_at: .closed_at }'\" Install the doc generation dependencies \u00b6 pip3 install mkdocs-material mkdocs-markdownextradata-plugin Releasing \u00b6 Create a local release branch from main git checkout main && \\ git pull && \\ git checkout -b release_2.11 Update VERSION_NAME in gradle.properties (remove -SNAPSHOT ) sed -i '' 's/VERSION_NAME=2.11-SNAPSHOT/VERSION_NAME=2.11/' gradle.properties Update the current version and next version in mkdocs.yml sed -i '' 's/2.11/NEXT/' mkdocs.yml sed -i '' 's/2.10/2.11/' mkdocs.yml Create the release git commit -am \"Prepare 2.11 release\" && \\ ./gradlew clean && \\ ./gradlew build && \\ git tag v2.11 && \\ git push origin v2.11 && \\ ./gradlew publish --no-daemon --no-parallel && \\ ./gradlew closeAndReleaseRepository && \\ ./gradlew shark-cli:distZip Note: if anything goes wrong, you can manually drop the release at https://s01.oss.sonatype.org/ Merge back to main git checkout main && \\ git pull && \\ git merge --no-ff release_2.11 Update VERSION_NAME in gradle.properties (increase version and add -SNAPSHOT ) sed -i '' 's/VERSION_NAME=2.11/VERSION_NAME=NEXT-SNAPSHOT/' gradle.properties Generate the Dokka docs rm -rf docs/api && \\ ./gradlew leakcanary-android-core:dokkaGfm leakcanary-android-instrumentation:dokkaGfm leakcanary-android-process:dokkaGfm leakcanary-object-watcher-android-core:dokkaGfm leakcanary-object-watcher:dokkaGfm shark-android:dokkaGfm shark-graph:dokkaGfm shark-hprof:dokkaGfm shark-log:dokkaGfm shark:dokkaGfm plumber-android:dokkaGfm leakcanary-android-release:dokkaGfm Update the changelog ( commit list ) mate docs/changelog.md Deploy the docs locally then open the changelog and check everything looks good mkdocs serve Finish up the release git commit -am \"Prepare for next development iteration\" && \\ git push && \\ gh listOpenMilestones | jq '.data.repository.milestones.nodes[0].number' | xargs gh closeMilestone && \\ echo '{ \"title\": \"REPLACE_WITH_NEXT_VERSION_NUMBER\", \"state\": \"open\", \"description\": \"\" }' | gh createMilestone && \\ mkdocs gh-deploy gh release create v2.11 ./shark-cli/build/distributions/shark-cli-2.11.zip --title v2.11 --notes 'See [Change Log](https://square.github.io/leakcanary/changelog)' Open the v2.11 release to confirm everything looks good. Upload shark-cli to brew : brew bump-formula-pr --url https://github.com/square/leakcanary/releases/download/v2.11/shark-cli-2.11.zip leakcanary-shark Wait for the release to be available on Maven Central . Tell your friends, update all of your apps, and tweet the new release. As a nice extra touch, mention external contributions.","title":"Releasing"},{"location":"releasing/#releasing-leakcanary","text":"","title":"Releasing LeakCanary"},{"location":"releasing/#preparing-the-release-environment","text":"","title":"Preparing the release environment"},{"location":"releasing/#set-up-your-sonatype-ossrh-account","text":"Create a Sonatype OSSRH JIRA account . Create a ticket to request access to the com.squareup.leakcanary project. Here\u2019s an example: OSSRH-54959 . Then ask someone with deployer role from the LeakCanary team to confirm access.","title":"Set up your Sonatype OSSRH account"},{"location":"releasing/#set-up-your-signing-key","text":"# Create a new key gpg --gen-key # List local keys. Key id is last 8 characters gpg -K cd ~/.gnupg # Export key locally gpg --export-secret-keys -o secring.gpg # Upload key to Ubuntu servers gpg --send-keys --keyserver keyserver.ubuntu.com <KEY ID> # Confirm the key can now be found gpg --recv-keys --keyserver keyserver.ubuntu.com <KEY ID>","title":"Set up your signing key"},{"location":"releasing/#set-up-your-home-gradleproperties","text":"Add this to your ~/.gradle/gradle.properties : signing.keyId=<KEY ID> signing.password=<KEY PASSWORD> signing.secretKeyRingFile=/Users/YOUR_USERNAME_/.gnupg/secring.gpg SONATYPE_NEXUS_USERNAME=<SONATYPE_USERNAME> SONATYPE_NEXUS_PASSWORD=<SONATYPE_PASSWORD>","title":"Set up your home gradle.properties"},{"location":"releasing/#set-up-the-google-analytics-docs-key","text":"Add this to your ~/.bashrc : export LEAKCANARY_GOOGLE_ANALYTICS_KEY = \"UA-142834539-1\"","title":"Set up the Google Analytics docs key"},{"location":"releasing/#set-up-github-cli","text":"Install GitHub CLI brew install gh Install jq, a CLI Json processor brew install jq Set up aliases for milestone management: gh alias set listOpenMilestones \"api graphql -F owner=':owner' -F name=':repo' -f query=' query ListOpenMilestones(\\$name: String\\!, \\$owner: String\\!) { repository(owner: \\$owner, name: \\$name) { milestones(first: 100, states: OPEN) { nodes { title number description dueOn url state closed closedAt updatedAt } } } } '\" gh alias set --shell createMilestone \"gh api --method POST repos/:owner/:repo/milestones --input - | jq '{ html_url: .html_url, state: .state, created_at: .created_at }'\" gh alias set --shell closeMilestone \"echo '{\\\"state\\\": \\\"closed\\\"}' | gh api --method PATCH repos/:owner/:repo/milestones/\\$1 --input - | jq '{ html_url: .html_url, state: .state, closed_at: .closed_at }'\"","title":"Set up GitHub CLI"},{"location":"releasing/#install-the-doc-generation-dependencies","text":"pip3 install mkdocs-material mkdocs-markdownextradata-plugin","title":"Install the doc generation dependencies"},{"location":"releasing/#releasing","text":"Create a local release branch from main git checkout main && \\ git pull && \\ git checkout -b release_2.11 Update VERSION_NAME in gradle.properties (remove -SNAPSHOT ) sed -i '' 's/VERSION_NAME=2.11-SNAPSHOT/VERSION_NAME=2.11/' gradle.properties Update the current version and next version in mkdocs.yml sed -i '' 's/2.11/NEXT/' mkdocs.yml sed -i '' 's/2.10/2.11/' mkdocs.yml Create the release git commit -am \"Prepare 2.11 release\" && \\ ./gradlew clean && \\ ./gradlew build && \\ git tag v2.11 && \\ git push origin v2.11 && \\ ./gradlew publish --no-daemon --no-parallel && \\ ./gradlew closeAndReleaseRepository && \\ ./gradlew shark-cli:distZip Note: if anything goes wrong, you can manually drop the release at https://s01.oss.sonatype.org/ Merge back to main git checkout main && \\ git pull && \\ git merge --no-ff release_2.11 Update VERSION_NAME in gradle.properties (increase version and add -SNAPSHOT ) sed -i '' 's/VERSION_NAME=2.11/VERSION_NAME=NEXT-SNAPSHOT/' gradle.properties Generate the Dokka docs rm -rf docs/api && \\ ./gradlew leakcanary-android-core:dokkaGfm leakcanary-android-instrumentation:dokkaGfm leakcanary-android-process:dokkaGfm leakcanary-object-watcher-android-core:dokkaGfm leakcanary-object-watcher:dokkaGfm shark-android:dokkaGfm shark-graph:dokkaGfm shark-hprof:dokkaGfm shark-log:dokkaGfm shark:dokkaGfm plumber-android:dokkaGfm leakcanary-android-release:dokkaGfm Update the changelog ( commit list ) mate docs/changelog.md Deploy the docs locally then open the changelog and check everything looks good mkdocs serve Finish up the release git commit -am \"Prepare for next development iteration\" && \\ git push && \\ gh listOpenMilestones | jq '.data.repository.milestones.nodes[0].number' | xargs gh closeMilestone && \\ echo '{ \"title\": \"REPLACE_WITH_NEXT_VERSION_NUMBER\", \"state\": \"open\", \"description\": \"\" }' | gh createMilestone && \\ mkdocs gh-deploy gh release create v2.11 ./shark-cli/build/distributions/shark-cli-2.11.zip --title v2.11 --notes 'See [Change Log](https://square.github.io/leakcanary/changelog)' Open the v2.11 release to confirm everything looks good. Upload shark-cli to brew : brew bump-formula-pr --url https://github.com/square/leakcanary/releases/download/v2.11/shark-cli-2.11.zip leakcanary-shark Wait for the release to be available on Maven Central . Tell your friends, update all of your apps, and tweet the new release. As a nice extra touch, mention external contributions.","title":"Releasing"},{"location":"shark/","text":"Shark \ud83e\udd88 \u00b6 Shark : S m a r t H e a p A n a l y s i s R e p o r t s f o r K o t l i n Shark is the heap analyzer that powers LeakCanary 2. It\u2019s a Kotlin standalone heap analysis library that runs at high speed with a low memory footprint . Shark is released in layers: Shark Hprof : Read and write records in hprof files. Shark Graph : Navigate the heap object graph. Shark : Generate heap analysis reports. Shark Android : Android heuristics to generate tailored heap analysis reports. Shark CLI : Analyze the heap of debuggable apps installed on an Android device connected to your desktop. The output is similar to the output of LeakCanary, except you don\u2019t have to add the LeakCanary dependency to your app. LeakCanary : Builds on top. It automatically watches destroyed activities and fragments, triggers a heap dump, runs Shark Android and then displays the result. A few more things: Shark is built on top of Okio. Okio makes it easy to parse heap dumps efficiently. Shark is a 100% Kotlin library, and Kotlin is essential to its design, because Shark relies heavily on sealed classes and sequences to save memory. Shark has the unique ability to help narrow down the cause of memory leaks through platform specific heuristics . Shark is heavily tested (80% test coverage). Shark can run in both Java and Android VMs, with no other dependency than Okio and Kotlin. Shark can analyze both Java and Android VM hprof files. Shark can deobfuscate hprof records if it has access to obfuscation mapping file. Shark CLI \u00b6 The Shark Command Line Interface (CLI) enables you to analyze heaps directly from your computer. It can dump the heap of an app installed on a connected Android device, analyze it, and even strip a heap dump of any sensitive data (e.g. PII, passwords or encryption keys) which is useful when sharing a heap dump. Install it via Homebrew : brew install leakcanary-shark You can also download it here . You can then look for leaks in apps on any connected device, for example: $ shark-cli --device emulator-5554 --process com.example.app.debug analyze Info shark-cli works with all debuggable apps, even if they don\u2019t include the leakcanary-android dependency. Run shark-cli to see usage instructions: $ shark-cli Usage: shark-cli [OPTIONS] COMMAND [ARGS]... ^`. .=\"\"=. ^_ \\ \\ / _ _ \\ \\ \\ { \\ | d b | { \\ / `~~~--__ \\ /\\ / { \\___----~~' `~~-_/'-=\\/=-'\\, \\ /// a `~. \\ \\ / /~~~~-, ,__. , /// __,,,,) \\ | \\/ \\/ `~~~; ,---~~-_`/ \\ / \\/ / / '. .' '._.' _|`~~`|_ /|\\ /|\\ Options: -p, --process TEXT Full or partial name of a process, e.g. \"example\" would match \"com.example.app\" -d, --device ID device/emulator id -m, --obfuscation-mapping PATH path to obfuscation mapping file --verbose / --no-verbose provide additional details as to what shark-cli is doing -h, --hprof FILE path to a .hprof file --help Show this message and exit Commands: interactive Explore a heap dump. analyze Analyze a heap dump. dump-process Dump the heap and pull the hprof file. strip-hprof Replace all primitive arrays from the provided heap dump with arrays of zeroes and generate a new \"-stripped.hprof\" file. Shark code examples \u00b6 Reading records in a hprof file \u00b6 dependencies { implementation 'com.squareup.leakcanary:shark-hprof:$sharkVersion' } // Prints all class and field names Hprof . open ( heapDumpFile ) . use { hprof -> hprof . reader . readHprofRecords ( recordTypes = setOf ( StringRecord :: class ), listener = OnHprofRecordListener { position , record -> println (( record as StringRecord ). string ) }) } Navigating the heap object graph \u00b6 dependencies { implementation 'com.squareup.leakcanary:shark-graph:$sharkVersion' } // Prints all thread names Hprof . open ( heapDumpFile ) . use { hprof -> val heapGraph = HprofHeapGraph . indexHprof ( hprof ) val threadClass = heapGraph . findClassByName ( \"java.lang.Thread\" ) !! val threadNames : Sequence < String > = threadClass . instances . map { instance -> val nameField = instance [ \"java.lang.Thread\" , \"name\" ]!! nameField . value . readAsJavaString () !! } threadNames . forEach { println ( it ) } } Generating a heap analysis report \u00b6 dependencies { implementation 'com.squareup.leakcanary:shark:$sharkVersion' } // Marks any instance of com.example.ThingWithLifecycle with // ThingWithLifecycle.destroyed=true as leaking val leakingObjectFilter = object : LeakingObjectFilter { override fun isLeakingObject ( heapObject : HeapObject ): Boolean { return if ( heapObject instanceOf \"com.example.ThingWithLifecycle\" ) { val instance = heapObject as HeapInstance val destroyedField = instance [ \"com.example.ThingWithLifecycle\" , \"destroyed\" ]!! destroyedField . value . asBoolean !! } else false } } val leakingObjectFinder = FilteringLeakingObjectFinder ( listOf ( leakingObjectFilter )) val heapAnalysis = Hprof . open ( heapDumpFile ) . use { hprof -> val heapGraph = HprofHeapGraph . indexHprof ( hprof ) val heapAnalyzer = HeapAnalyzer ( AnalyzerProgressListener . NONE ) heapAnalyzer . analyze ( heapDumpFile = heapDumpFile , graph = heapGraph , leakingObjectFinder = leakingObjectFinder , ) } println ( analysis ) Generating an Android heap analysis report \u00b6 dependencies { implementation 'com.squareup.leakcanary:shark-android:$sharkVersion' } val heapAnalyzer = HeapAnalyzer ( AnalyzerProgressListener . NONE ) val analysis = heapAnalyzer . checkForLeaks ( heapDumpFile = heapDumpFile , referenceMatchers = AndroidReferenceMatchers . appDefaults , objectInspectors = AndroidObjectInspectors . appDefaults ) println ( analysis )","title":"Overview"},{"location":"shark/#shark","text":"Shark : S m a r t H e a p A n a l y s i s R e p o r t s f o r K o t l i n Shark is the heap analyzer that powers LeakCanary 2. It\u2019s a Kotlin standalone heap analysis library that runs at high speed with a low memory footprint . Shark is released in layers: Shark Hprof : Read and write records in hprof files. Shark Graph : Navigate the heap object graph. Shark : Generate heap analysis reports. Shark Android : Android heuristics to generate tailored heap analysis reports. Shark CLI : Analyze the heap of debuggable apps installed on an Android device connected to your desktop. The output is similar to the output of LeakCanary, except you don\u2019t have to add the LeakCanary dependency to your app. LeakCanary : Builds on top. It automatically watches destroyed activities and fragments, triggers a heap dump, runs Shark Android and then displays the result. A few more things: Shark is built on top of Okio. Okio makes it easy to parse heap dumps efficiently. Shark is a 100% Kotlin library, and Kotlin is essential to its design, because Shark relies heavily on sealed classes and sequences to save memory. Shark has the unique ability to help narrow down the cause of memory leaks through platform specific heuristics . Shark is heavily tested (80% test coverage). Shark can run in both Java and Android VMs, with no other dependency than Okio and Kotlin. Shark can analyze both Java and Android VM hprof files. Shark can deobfuscate hprof records if it has access to obfuscation mapping file.","title":"Shark \ud83e\udd88"},{"location":"shark/#shark-cli","text":"The Shark Command Line Interface (CLI) enables you to analyze heaps directly from your computer. It can dump the heap of an app installed on a connected Android device, analyze it, and even strip a heap dump of any sensitive data (e.g. PII, passwords or encryption keys) which is useful when sharing a heap dump. Install it via Homebrew : brew install leakcanary-shark You can also download it here . You can then look for leaks in apps on any connected device, for example: $ shark-cli --device emulator-5554 --process com.example.app.debug analyze Info shark-cli works with all debuggable apps, even if they don\u2019t include the leakcanary-android dependency. Run shark-cli to see usage instructions: $ shark-cli Usage: shark-cli [OPTIONS] COMMAND [ARGS]... ^`. .=\"\"=. ^_ \\ \\ / _ _ \\ \\ \\ { \\ | d b | { \\ / `~~~--__ \\ /\\ / { \\___----~~' `~~-_/'-=\\/=-'\\, \\ /// a `~. \\ \\ / /~~~~-, ,__. , /// __,,,,) \\ | \\/ \\/ `~~~; ,---~~-_`/ \\ / \\/ / / '. .' '._.' _|`~~`|_ /|\\ /|\\ Options: -p, --process TEXT Full or partial name of a process, e.g. \"example\" would match \"com.example.app\" -d, --device ID device/emulator id -m, --obfuscation-mapping PATH path to obfuscation mapping file --verbose / --no-verbose provide additional details as to what shark-cli is doing -h, --hprof FILE path to a .hprof file --help Show this message and exit Commands: interactive Explore a heap dump. analyze Analyze a heap dump. dump-process Dump the heap and pull the hprof file. strip-hprof Replace all primitive arrays from the provided heap dump with arrays of zeroes and generate a new \"-stripped.hprof\" file.","title":"Shark CLI"},{"location":"shark/#shark-code-examples","text":"","title":"Shark code examples"},{"location":"shark/#reading-records-in-a-hprof-file","text":"dependencies { implementation 'com.squareup.leakcanary:shark-hprof:$sharkVersion' } // Prints all class and field names Hprof . open ( heapDumpFile ) . use { hprof -> hprof . reader . readHprofRecords ( recordTypes = setOf ( StringRecord :: class ), listener = OnHprofRecordListener { position , record -> println (( record as StringRecord ). string ) }) }","title":"Reading records in a hprof file"},{"location":"shark/#navigating-the-heap-object-graph","text":"dependencies { implementation 'com.squareup.leakcanary:shark-graph:$sharkVersion' } // Prints all thread names Hprof . open ( heapDumpFile ) . use { hprof -> val heapGraph = HprofHeapGraph . indexHprof ( hprof ) val threadClass = heapGraph . findClassByName ( \"java.lang.Thread\" ) !! val threadNames : Sequence < String > = threadClass . instances . map { instance -> val nameField = instance [ \"java.lang.Thread\" , \"name\" ]!! nameField . value . readAsJavaString () !! } threadNames . forEach { println ( it ) } }","title":"Navigating the heap object graph"},{"location":"shark/#generating-a-heap-analysis-report","text":"dependencies { implementation 'com.squareup.leakcanary:shark:$sharkVersion' } // Marks any instance of com.example.ThingWithLifecycle with // ThingWithLifecycle.destroyed=true as leaking val leakingObjectFilter = object : LeakingObjectFilter { override fun isLeakingObject ( heapObject : HeapObject ): Boolean { return if ( heapObject instanceOf \"com.example.ThingWithLifecycle\" ) { val instance = heapObject as HeapInstance val destroyedField = instance [ \"com.example.ThingWithLifecycle\" , \"destroyed\" ]!! destroyedField . value . asBoolean !! } else false } } val leakingObjectFinder = FilteringLeakingObjectFinder ( listOf ( leakingObjectFilter )) val heapAnalysis = Hprof . open ( heapDumpFile ) . use { hprof -> val heapGraph = HprofHeapGraph . indexHprof ( hprof ) val heapAnalyzer = HeapAnalyzer ( AnalyzerProgressListener . NONE ) heapAnalyzer . analyze ( heapDumpFile = heapDumpFile , graph = heapGraph , leakingObjectFinder = leakingObjectFinder , ) } println ( analysis )","title":"Generating a heap analysis report"},{"location":"shark/#generating-an-android-heap-analysis-report","text":"dependencies { implementation 'com.squareup.leakcanary:shark-android:$sharkVersion' } val heapAnalyzer = HeapAnalyzer ( AnalyzerProgressListener . NONE ) val analysis = heapAnalyzer . checkForLeaks ( heapDumpFile = heapDumpFile , referenceMatchers = AndroidReferenceMatchers . appDefaults , objectInspectors = AndroidObjectInspectors . appDefaults ) println ( analysis )","title":"Generating an Android heap analysis report"},{"location":"support/","text":"LeakCanary Support \u00b6 If you\u2019re looking for help with LeakCanary: Learn the Fundamentals Try the code recipes Read the FAQ Watch recorded presentations Read blog articles Ask a question on StackOverflow","title":"Support"},{"location":"support/#leakcanary-support","text":"If you\u2019re looking for help with LeakCanary: Learn the Fundamentals Try the code recipes Read the FAQ Watch recorded presentations Read blog articles Ask a question on StackOverflow","title":"LeakCanary Support"},{"location":"ui-tests/","text":"Leak detection in UI tests \u00b6 Running leak detection in UI tests means you can detect memory leaks automatically in Continuous Integration prior to new leaks being merged into the codebase. Test environment detection In debug builds, LeakCanary looks for retained instances continuously, freezes the VM to take a heap dump after a watched object has been retained for 5 seconds, then performs the analysis in a background thread and reports the result using notifications. That behavior isn\u2019t well suited for UI tests, so LeakCanary is automatically disabled when JUnit is on the runtime classpath (see test environment detection ). Getting started \u00b6 LeakCanary provides an artifact dedicated to detecting leaks in UI tests: androidTestImplementation \"com.squareup.leakcanary:leakcanary-android-instrumentation:${leakCanaryVersion}\" You can then call LeakAssertions.assertNoLeak() at any point in your tests to check for leaks: class CartTest { @Test fun addItemToCart () { // ... LeakAssertions . assertNoLeak () } } If retained instances are detected, LeakCanary will dump and analyze the heap. If application leaks are found, LeakAssertions.assertNoLeak() will throw a NoLeakAssertionFailedError . leakcanary.NoLeakAssertionFailedError: Application memory leaks were detected: ==================================== HEAP ANALYSIS RESULT ==================================== 1 APPLICATION LEAKS \u252c\u2500\u2500\u2500 \u2502 GC Root: System class \u2502 \u251c\u2500 com.example.MySingleton class \u2502 Leaking: NO (a class is never leaking) \u2502 \u2193 static MySingleton.leakedView \u2502 ~~~~~~~~~~ \u251c\u2500 android.widget.TextView instance \u2502 Leaking: YES (View.mContext references a destroyed activity) \u2502 \u2193 TextView.mContext \u2570\u2192 com.example.MainActivity instance Leaking: YES (Activity#mDestroyed is true) ==================================== at leakcanary.AndroidDetectLeaksAssert.assertNoLeaks(AndroidDetectLeaksAssert.kt:34) at leakcanary.LeakAssertions.assertNoLeaks(LeakAssertions.kt:21) at com.example.CartTest.addItemToCart(TuPeuxPasTest.kt:41) Obfuscated instrumentation tests When running instrumentation tests against obfuscated release builds, the LeakCanary classes end up spread over the test APK and the main APK. Unfortunately there is a bug in the Android Gradle Plugin that leads to runtime crashes when running tests, because code from the main APK is changed without the using code in the test APK being updated accordingly. If you run into this issue, setting up the Keeper plugin should fix it. Test rule \u00b6 You can use the DetectLeaksAfterTestSuccess test rule to automatically call LeakAssertions.assertNoLeak() at the end of a test: class CartTest { @get : Rule val rule = DetectLeaksAfterTestSuccess () @Test fun addItemToCart () { // ... } } You can call also LeakAssertions.assertNoLeak() as many times as you want in a single test: class CartTest { @get : Rule val rule = DetectLeaksAfterTestSuccess () // This test has 3 leak assertions (2 in the test + 1 from the rule). @Test fun addItemToCart () { // ... LeakAssertions . assertNoLeak () // ... LeakAssertions . assertNoLeak () // ... } } Skipping leak detection \u00b6 Use @SkipLeakDetection to disable LeakAssertions.assertNoLeak() calls: class CartTest { @get : Rule val rule = DetectLeaksAfterTestSuccess () // This test will not perform any leak assertion. @SkipLeakDetection ( \"See issue #1234\" ) @Test fun addItemToCart () { // ... LeakAssertions . assertNoLeak () // ... LeakAssertions . assertNoLeak () // ... } } You can use tags to identify each LeakAssertions.assertNoLeak() call and disable only a subset of these calls: class CartTest { @get : Rule val rule = DetectLeaksAfterTestSuccess ( tag = \"EndOfTest\" ) // This test will only perform the second leak assertion. @SkipLeakDetection ( \"See issue #1234\" , \"First Assertion\" , \"EndOfTest\" ) @Test fun addItemToCart () { // ... LeakAssertions . assertNoLeak ( tag = \"First Assertion\" ) // ... LeakAssertions . assertNoLeak ( tag = \"Second Assertion\" ) // ... } } Tags can be retrieved by calling HeapAnalysisSuccess.assertionTag and are also reported in the heap analysis result metadata: ==================================== METADATA Please include this in bug reports and Stack Overflow questions. Build.VERSION.SDK_INT: 23 ... assertionTag: Second Assertion Test rule chains \u00b6 // Example test rule chain @get : Rule val rule = RuleChain . outerRule ( LoginRule ()) . around ( ActivityScenarioRule ( CartActivity :: class . java )) . around ( LoadingScreenRule ()) If you use a test rule chain, the position of the DetectLeaksAfterTestSuccess rule in that chain could be significant. For example, if you use an ActivityScenarioRule that automatically finishes the activity at the end of a test, having DetectLeaksAfterTestSuccess around ActivityScenarioRule will detect leaks after the activity is destroyed and therefore detect any activity leak. But then DetectLeaksAfterTestSuccess will not detect fragment leaks that go away when the activity is destroyed. @get : Rule val rule = RuleChain . outerRule ( LoginRule ()) // Detect leaks AFTER activity is destroyed . around ( DetectLeaksAfterTestSuccess ( tag = \"AfterActivityDestroyed\" )) . around ( ActivityScenarioRule ()) . around ( LoadingScreenRule ()) If instead you set up ActivityScenarioRule around DetectLeaksAfterTestSuccess , destroyed activity leaks will not be detected as the activity will still be created when the leak assertion rule runs, but more fragment leaks might be detected. @get : Rule val rule = RuleChain . outerRule ( LoginRule ()) . around ( ActivityScenarioRule ( CartActivity :: class . java )) // Detect leaks BEFORE activity is destroyed . around ( DetectLeaksAfterTestSuccess ( tag = \"BeforeActivityDestroyed\" )) . around ( LoadingScreenRule ()) To detect all leaks, the best option is to set up the DetectLeaksAfterTestSuccess rule twice, before and after the ActivityScenarioRule rule. // Detect leaks BEFORE and AFTER activity is destroyed @get : Rule val rule = RuleChain . outerRule ( LoginRule ()) . around ( DetectLeaksAfterTestSuccess ( tag = \"AfterActivityDestroyed\" )) . around ( ActivityScenarioRule ( CartActivity :: class . java )) . around ( DetectLeaksAfterTestSuccess ( tag = \"BeforeActivityDestroyed\" )) . around ( LoadingScreenRule ()) RuleChain.detectLeaksAfterTestSuccessWrapping() is a helper for doing just that: // Detect leaks BEFORE and AFTER activity is destroyed @get : Rule val rule = RuleChain . outerRule ( LoginRule ()) . around ( DetectLeaksAfterTestSuccess ( CartActivity :: class . java )) // The tag will be suffixed with \"Before\" and \"After\". . detectLeaksAfterTestSuccessWrapping ( tag = \"ActivitiesDestroyed\" ) { around ( ActivityScenarioRule ( CartActivity :: class . java )) } . around ( LoadingScreenRule ()) Customizing assertNoLeak() \u00b6 LeakAssertions.assertNoLeak() delegates calls to a global DetectLeaksAssert implementation, which by default is an instance of AndroidDetectLeaksAssert . You can change the DetectLeaksAssert implementation by calling DetectLeaksAssert.update(customLeaksAssert) . The AndroidDetectLeaksAssert implementation performs a heap dump when retained instances are detected, analyzes the heap, then passes the result to a HeapAnalysisReporter . The default HeapAnalysisReporter is NoLeakAssertionFailedError.throwOnApplicationLeaks() which throws a NoLeakAssertionFailedError if an application leak is detected. You could provide a custom implementation to also upload heap analysis results to a central place before failing the test: val throwingReporter = NoLeakAssertionFailedError . throwOnApplicationLeaks () DetectLeaksAssert . update ( AndroidDetectLeaksAssert ( heapAnalysisReporter = { heapAnalysis -> // Upload the heap analysis result heapAnalysisUploader . upload ( heapAnalysis ) // Fail the test if there are application leaks throwingReporter . reportHeapAnalysis ( heapAnalysis ) } ))","title":"Leak detection in UI tests"},{"location":"ui-tests/#leak-detection-in-ui-tests","text":"Running leak detection in UI tests means you can detect memory leaks automatically in Continuous Integration prior to new leaks being merged into the codebase. Test environment detection In debug builds, LeakCanary looks for retained instances continuously, freezes the VM to take a heap dump after a watched object has been retained for 5 seconds, then performs the analysis in a background thread and reports the result using notifications. That behavior isn\u2019t well suited for UI tests, so LeakCanary is automatically disabled when JUnit is on the runtime classpath (see test environment detection ).","title":"Leak detection in UI tests"},{"location":"ui-tests/#getting-started","text":"LeakCanary provides an artifact dedicated to detecting leaks in UI tests: androidTestImplementation \"com.squareup.leakcanary:leakcanary-android-instrumentation:${leakCanaryVersion}\" You can then call LeakAssertions.assertNoLeak() at any point in your tests to check for leaks: class CartTest { @Test fun addItemToCart () { // ... LeakAssertions . assertNoLeak () } } If retained instances are detected, LeakCanary will dump and analyze the heap. If application leaks are found, LeakAssertions.assertNoLeak() will throw a NoLeakAssertionFailedError . leakcanary.NoLeakAssertionFailedError: Application memory leaks were detected: ==================================== HEAP ANALYSIS RESULT ==================================== 1 APPLICATION LEAKS \u252c\u2500\u2500\u2500 \u2502 GC Root: System class \u2502 \u251c\u2500 com.example.MySingleton class \u2502 Leaking: NO (a class is never leaking) \u2502 \u2193 static MySingleton.leakedView \u2502 ~~~~~~~~~~ \u251c\u2500 android.widget.TextView instance \u2502 Leaking: YES (View.mContext references a destroyed activity) \u2502 \u2193 TextView.mContext \u2570\u2192 com.example.MainActivity instance Leaking: YES (Activity#mDestroyed is true) ==================================== at leakcanary.AndroidDetectLeaksAssert.assertNoLeaks(AndroidDetectLeaksAssert.kt:34) at leakcanary.LeakAssertions.assertNoLeaks(LeakAssertions.kt:21) at com.example.CartTest.addItemToCart(TuPeuxPasTest.kt:41) Obfuscated instrumentation tests When running instrumentation tests against obfuscated release builds, the LeakCanary classes end up spread over the test APK and the main APK. Unfortunately there is a bug in the Android Gradle Plugin that leads to runtime crashes when running tests, because code from the main APK is changed without the using code in the test APK being updated accordingly. If you run into this issue, setting up the Keeper plugin should fix it.","title":"Getting started"},{"location":"ui-tests/#test-rule","text":"You can use the DetectLeaksAfterTestSuccess test rule to automatically call LeakAssertions.assertNoLeak() at the end of a test: class CartTest { @get : Rule val rule = DetectLeaksAfterTestSuccess () @Test fun addItemToCart () { // ... } } You can call also LeakAssertions.assertNoLeak() as many times as you want in a single test: class CartTest { @get : Rule val rule = DetectLeaksAfterTestSuccess () // This test has 3 leak assertions (2 in the test + 1 from the rule). @Test fun addItemToCart () { // ... LeakAssertions . assertNoLeak () // ... LeakAssertions . assertNoLeak () // ... } }","title":"Test rule"},{"location":"ui-tests/#skipping-leak-detection","text":"Use @SkipLeakDetection to disable LeakAssertions.assertNoLeak() calls: class CartTest { @get : Rule val rule = DetectLeaksAfterTestSuccess () // This test will not perform any leak assertion. @SkipLeakDetection ( \"See issue #1234\" ) @Test fun addItemToCart () { // ... LeakAssertions . assertNoLeak () // ... LeakAssertions . assertNoLeak () // ... } } You can use tags to identify each LeakAssertions.assertNoLeak() call and disable only a subset of these calls: class CartTest { @get : Rule val rule = DetectLeaksAfterTestSuccess ( tag = \"EndOfTest\" ) // This test will only perform the second leak assertion. @SkipLeakDetection ( \"See issue #1234\" , \"First Assertion\" , \"EndOfTest\" ) @Test fun addItemToCart () { // ... LeakAssertions . assertNoLeak ( tag = \"First Assertion\" ) // ... LeakAssertions . assertNoLeak ( tag = \"Second Assertion\" ) // ... } } Tags can be retrieved by calling HeapAnalysisSuccess.assertionTag and are also reported in the heap analysis result metadata: ==================================== METADATA Please include this in bug reports and Stack Overflow questions. Build.VERSION.SDK_INT: 23 ... assertionTag: Second Assertion","title":"Skipping leak detection"},{"location":"ui-tests/#test-rule-chains","text":"// Example test rule chain @get : Rule val rule = RuleChain . outerRule ( LoginRule ()) . around ( ActivityScenarioRule ( CartActivity :: class . java )) . around ( LoadingScreenRule ()) If you use a test rule chain, the position of the DetectLeaksAfterTestSuccess rule in that chain could be significant. For example, if you use an ActivityScenarioRule that automatically finishes the activity at the end of a test, having DetectLeaksAfterTestSuccess around ActivityScenarioRule will detect leaks after the activity is destroyed and therefore detect any activity leak. But then DetectLeaksAfterTestSuccess will not detect fragment leaks that go away when the activity is destroyed. @get : Rule val rule = RuleChain . outerRule ( LoginRule ()) // Detect leaks AFTER activity is destroyed . around ( DetectLeaksAfterTestSuccess ( tag = \"AfterActivityDestroyed\" )) . around ( ActivityScenarioRule ()) . around ( LoadingScreenRule ()) If instead you set up ActivityScenarioRule around DetectLeaksAfterTestSuccess , destroyed activity leaks will not be detected as the activity will still be created when the leak assertion rule runs, but more fragment leaks might be detected. @get : Rule val rule = RuleChain . outerRule ( LoginRule ()) . around ( ActivityScenarioRule ( CartActivity :: class . java )) // Detect leaks BEFORE activity is destroyed . around ( DetectLeaksAfterTestSuccess ( tag = \"BeforeActivityDestroyed\" )) . around ( LoadingScreenRule ()) To detect all leaks, the best option is to set up the DetectLeaksAfterTestSuccess rule twice, before and after the ActivityScenarioRule rule. // Detect leaks BEFORE and AFTER activity is destroyed @get : Rule val rule = RuleChain . outerRule ( LoginRule ()) . around ( DetectLeaksAfterTestSuccess ( tag = \"AfterActivityDestroyed\" )) . around ( ActivityScenarioRule ( CartActivity :: class . java )) . around ( DetectLeaksAfterTestSuccess ( tag = \"BeforeActivityDestroyed\" )) . around ( LoadingScreenRule ()) RuleChain.detectLeaksAfterTestSuccessWrapping() is a helper for doing just that: // Detect leaks BEFORE and AFTER activity is destroyed @get : Rule val rule = RuleChain . outerRule ( LoginRule ()) . around ( DetectLeaksAfterTestSuccess ( CartActivity :: class . java )) // The tag will be suffixed with \"Before\" and \"After\". . detectLeaksAfterTestSuccessWrapping ( tag = \"ActivitiesDestroyed\" ) { around ( ActivityScenarioRule ( CartActivity :: class . java )) } . around ( LoadingScreenRule ())","title":"Test rule chains"},{"location":"ui-tests/#customizing-assertnoleak","text":"LeakAssertions.assertNoLeak() delegates calls to a global DetectLeaksAssert implementation, which by default is an instance of AndroidDetectLeaksAssert . You can change the DetectLeaksAssert implementation by calling DetectLeaksAssert.update(customLeaksAssert) . The AndroidDetectLeaksAssert implementation performs a heap dump when retained instances are detected, analyzes the heap, then passes the result to a HeapAnalysisReporter . The default HeapAnalysisReporter is NoLeakAssertionFailedError.throwOnApplicationLeaks() which throws a NoLeakAssertionFailedError if an application leak is detected. You could provide a custom implementation to also upload heap analysis results to a central place before failing the test: val throwingReporter = NoLeakAssertionFailedError . throwOnApplicationLeaks () DetectLeaksAssert . update ( AndroidDetectLeaksAssert ( heapAnalysisReporter = { heapAnalysis -> // Upload the heap analysis result heapAnalysisUploader . upload ( heapAnalysis ) // Fail the test if there are application leaks throwingReporter . reportHeapAnalysis ( heapAnalysis ) } ))","title":"Customizing assertNoLeak()"},{"location":"upgrading-to-leakcanary-2.0/","text":"LeakCanary 2 is a major rewrite. High level changes: New heap analyzer, reimplemented from scratch to use 10 times less memory ( see Shark ). APIs updated to simplify configuration and provide access to the new heap analyzer. Internals rewritten to 100% Kotlin. Multiple leaks detected in one analysis, grouped per leak type Dependencies \u00b6 Before \u00b6 dependencies { debugImplementation 'com.squareup.leakcanary:leakcanary-android:1.6.3' releaseImplementation 'com.squareup.leakcanary:leakcanary-android-no-op:1.6.3' // Optional, if you use support library fragments: debugImplementation 'com.squareup.leakcanary:leakcanary-support-fragment:1.6.3' } Now \u00b6 dependencies { debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.10' } Worth noting \u00b6 The leakcanary-android-no-op artifact is gone. If you have compile errors, see below. Question : if there\u2019s no no-op anymore, how do I ensure none of this runs during release builds? Answer : as long as you add leakcanary-android as debugImplementation , there won\u2019t be any code referencing LeakCanary in your release builds. LeakCanary does not depend on the support library anymore, and it doesn\u2019t depend on AndroidX either. Detection of AndroidX fragments is automatic if you have the AndroidX fragments dependency. Default setup code \u00b6 Before \u00b6 public class ExampleApplication extends Application { @Override public void onCreate () { super . onCreate (); if ( LeakCanary . isInAnalyzerProcess ( this )) { // This process is dedicated to LeakCanary for heap analysis. // You should not init your app in this process. return ; } LeakCanary . install ( this ); // Normal app init code... } } Now \u00b6 There is no more code for default setup. Worth noting \u00b6 LeakCanary auto installs itself LeakCanary analysis now runs in the main process so there is no need to call LeakCanary.isInAnalyzerProcess() . Retrieve the RefWatcher \u00b6 Before \u00b6 val refWatcher : RefWatcher = LeakCanary . installedRefWatcher () Now \u00b6 val objectWatcher : ObjectWatcher = AppWatcher . objectWatcher Compile errors because RefWatcher is used in release code \u00b6 If you were using RefWatcher in non debug code, you now get a compile error because the no-op artifact is gone. ObjectWatcher now lives in the object-watcher artifact, which is suitable for release builds. You have two options: Option 1: Add object-watcher-android to release builds. \u00b6 dependencies { implementation 'com.squareup.leakcanary:leakcanary-object-watcher-android:2.10' } It will automatically keep weak references to destroyed activities, fragments, and any instance you pass to AppWatcher.objectWatcher . It will not trigger heap dumps or anything else that LeakCanary does. It\u2019s very little code and should have a no impact on your release app. You can use it to count how many objects are retained, for example to add metadata to OutOfMemoryError crashes: val retainedObjectCount = AppWatcher . objectWatcher . retainedObjectCount Option 2: Make your own ObjectWatcher interface \u00b6 // In shared code interface MaybeObjectWatcher { fun watch ( watchedObject : Any , description : String ) object None : MaybeObjectWatcher { override fun watch ( watchedObject : Any , description : String ) { } } } // In debug code class RealObjectWatcher : MaybeObjectWatcher { override fun watch ( watchedObject : Any , description : String ) { AppWatcher . objectWatcher . watch ( watchedObject , description ) } } Use MaybeObjectWatcher.None in release code and RealObjectWatcher in debug code. Configuring LeakCanary \u00b6 Before \u00b6 public class DebugExampleApplication extends ExampleApplication { @Override protected void installLeakCanary () { RefWatcher refWatcher = LeakCanary . refWatcher ( this ) . watchActivities ( false ) . buildAndInstall (); } } Now \u00b6 AppWatcher is in charge of detecting retained objects. Its configuration can be updated at any time by replacing AppWatcher.config : class DebugExampleApplication : ExampleApplication () { override fun onCreate () { super . onCreate () AppWatcher . config = AppWatcher . config . copy ( watchFragmentViews = false ) } } LeakCanary is in charge of taking heap dumps and analyzing them. Its configuration can be updated at any time by replacing LeakCanary.config : disableLeakCanaryButton . setOnClickListener { LeakCanary . config = LeakCanary . config . copy ( dumpHeap = false ) } Running LeakCanary in instrumentation tests \u00b6 Before \u00b6 In your build.gradle file: dependencies { androidTestImplementation \"com.squareup.leakcanary:leakcanary-android-instrumentation:${leakCanaryVersion}\" } android { defaultConfig { // ... testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\" testInstrumentationRunnerArgument \"listener\" , \"com.squareup.leakcanary.FailTestOnLeakRunListener\" } } In your test Application class: public class InstrumentationTestExampleApplication extends DebugExampleApplication { @Override protected void installLeakCanary () { InstrumentationLeakDetector . instrumentationRefWatcher ( this ) . buildAndInstall (); } } Now \u00b6 Remove all the previous test related leak detection code then follow Leak detection in UI tests . Analysis listener / uploading to a server \u00b6 Before \u00b6 public class LeakUploadService extends DisplayLeakService { @Override protected void afterDefaultHandling ( HeapDump heapDump , AnalysisResult result , String leakInfo ) { // TODO Upload result to server } } RefWatcher refWatcher = LeakCanary . refWatcher ( this ) . listenerServiceClass ( LeakUploadService . class ) . buildAndInstall (); <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android= \"http://schemas.android.com/apk/res/android\" > <application android:name= \"com.example.DebugExampleApplication\" > <service android:name= \"com.example.LeakUploadService\" /> </application> </manifest> Now \u00b6 class LeakUploader : OnHeapAnalyzedListener { val defaultListener = DefaultOnHeapAnalyzedListener . create () override fun onHeapAnalyzed ( heapAnalysis : HeapAnalysis ) { TODO ( \"Upload heap analysis to server\" ) // Delegate to default behavior (notification and saving result) defaultListener . onHeapAnalyzed ( heapAnalysis ) } } class DebugExampleApplication : ExampleApplication () { override fun onCreate () { super . onCreate () LeakCanary . config = LeakCanary . config . copy ( onHeapAnalyzedListener = LeakUploader () ) } } Matching known library leaks \u00b6 Before \u00b6 ExcludedRefs excludedRefs = AndroidExcludedRefs . createAppDefaults () . staticField ( \"com.samsing.SomeSingleton\" , \"sContext\" ) . build (); RefWatcher refWatcher = LeakCanary . refWatcher ( this ) . excludedRefs ( excludedRefs ) . buildAndInstall (); } Now \u00b6 LeakCanary . config = LeakCanary . config . copy ( referenceMatchers = AndroidReferenceMatchers . appDefaults + AndroidReferenceMatchers . staticFieldLeak ( \"com.samsing.SomeSingleton\" , \"sContext\" ) ) Info There is no equivalent API to ExcludedRefs.Builder.clazz() because it led to abuses. Instead see Ignoring specific activities or fragment classes . Public API packages \u00b6 Before \u00b6 All public APIs were in com.squareup.leakcanary.* Now \u00b6 All public APIs are in leakcanary.*","title":"Upgrading to LeakCanary 2"},{"location":"upgrading-to-leakcanary-2.0/#dependencies","text":"","title":"Dependencies"},{"location":"upgrading-to-leakcanary-2.0/#before","text":"dependencies { debugImplementation 'com.squareup.leakcanary:leakcanary-android:1.6.3' releaseImplementation 'com.squareup.leakcanary:leakcanary-android-no-op:1.6.3' // Optional, if you use support library fragments: debugImplementation 'com.squareup.leakcanary:leakcanary-support-fragment:1.6.3' }","title":"Before"},{"location":"upgrading-to-leakcanary-2.0/#now","text":"dependencies { debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.10' }","title":"Now"},{"location":"upgrading-to-leakcanary-2.0/#worth-noting","text":"The leakcanary-android-no-op artifact is gone. If you have compile errors, see below. Question : if there\u2019s no no-op anymore, how do I ensure none of this runs during release builds? Answer : as long as you add leakcanary-android as debugImplementation , there won\u2019t be any code referencing LeakCanary in your release builds. LeakCanary does not depend on the support library anymore, and it doesn\u2019t depend on AndroidX either. Detection of AndroidX fragments is automatic if you have the AndroidX fragments dependency.","title":"Worth noting"},{"location":"upgrading-to-leakcanary-2.0/#default-setup-code","text":"","title":"Default setup code"},{"location":"upgrading-to-leakcanary-2.0/#before_1","text":"public class ExampleApplication extends Application { @Override public void onCreate () { super . onCreate (); if ( LeakCanary . isInAnalyzerProcess ( this )) { // This process is dedicated to LeakCanary for heap analysis. // You should not init your app in this process. return ; } LeakCanary . install ( this ); // Normal app init code... } }","title":"Before"},{"location":"upgrading-to-leakcanary-2.0/#now_1","text":"There is no more code for default setup.","title":"Now"},{"location":"upgrading-to-leakcanary-2.0/#worth-noting_1","text":"LeakCanary auto installs itself LeakCanary analysis now runs in the main process so there is no need to call LeakCanary.isInAnalyzerProcess() .","title":"Worth noting"},{"location":"upgrading-to-leakcanary-2.0/#retrieve-the-refwatcher","text":"","title":"Retrieve the RefWatcher"},{"location":"upgrading-to-leakcanary-2.0/#before_2","text":"val refWatcher : RefWatcher = LeakCanary . installedRefWatcher ()","title":"Before"},{"location":"upgrading-to-leakcanary-2.0/#now_2","text":"val objectWatcher : ObjectWatcher = AppWatcher . objectWatcher","title":"Now"},{"location":"upgrading-to-leakcanary-2.0/#compile-errors-because-refwatcher-is-used-in-release-code","text":"If you were using RefWatcher in non debug code, you now get a compile error because the no-op artifact is gone. ObjectWatcher now lives in the object-watcher artifact, which is suitable for release builds. You have two options:","title":"Compile errors because RefWatcher is used in release code"},{"location":"upgrading-to-leakcanary-2.0/#option-1-add-object-watcher-android-to-release-builds","text":"dependencies { implementation 'com.squareup.leakcanary:leakcanary-object-watcher-android:2.10' } It will automatically keep weak references to destroyed activities, fragments, and any instance you pass to AppWatcher.objectWatcher . It will not trigger heap dumps or anything else that LeakCanary does. It\u2019s very little code and should have a no impact on your release app. You can use it to count how many objects are retained, for example to add metadata to OutOfMemoryError crashes: val retainedObjectCount = AppWatcher . objectWatcher . retainedObjectCount","title":"Option 1: Add object-watcher-android to release builds."},{"location":"upgrading-to-leakcanary-2.0/#option-2-make-your-own-objectwatcher-interface","text":"// In shared code interface MaybeObjectWatcher { fun watch ( watchedObject : Any , description : String ) object None : MaybeObjectWatcher { override fun watch ( watchedObject : Any , description : String ) { } } } // In debug code class RealObjectWatcher : MaybeObjectWatcher { override fun watch ( watchedObject : Any , description : String ) { AppWatcher . objectWatcher . watch ( watchedObject , description ) } } Use MaybeObjectWatcher.None in release code and RealObjectWatcher in debug code.","title":"Option 2: Make your own ObjectWatcher interface"},{"location":"upgrading-to-leakcanary-2.0/#configuring-leakcanary","text":"","title":"Configuring LeakCanary"},{"location":"upgrading-to-leakcanary-2.0/#before_3","text":"public class DebugExampleApplication extends ExampleApplication { @Override protected void installLeakCanary () { RefWatcher refWatcher = LeakCanary . refWatcher ( this ) . watchActivities ( false ) . buildAndInstall (); } }","title":"Before"},{"location":"upgrading-to-leakcanary-2.0/#now_3","text":"AppWatcher is in charge of detecting retained objects. Its configuration can be updated at any time by replacing AppWatcher.config : class DebugExampleApplication : ExampleApplication () { override fun onCreate () { super . onCreate () AppWatcher . config = AppWatcher . config . copy ( watchFragmentViews = false ) } } LeakCanary is in charge of taking heap dumps and analyzing them. Its configuration can be updated at any time by replacing LeakCanary.config : disableLeakCanaryButton . setOnClickListener { LeakCanary . config = LeakCanary . config . copy ( dumpHeap = false ) }","title":"Now"},{"location":"upgrading-to-leakcanary-2.0/#running-leakcanary-in-instrumentation-tests","text":"","title":"Running LeakCanary in instrumentation tests"},{"location":"upgrading-to-leakcanary-2.0/#before_4","text":"In your build.gradle file: dependencies { androidTestImplementation \"com.squareup.leakcanary:leakcanary-android-instrumentation:${leakCanaryVersion}\" } android { defaultConfig { // ... testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\" testInstrumentationRunnerArgument \"listener\" , \"com.squareup.leakcanary.FailTestOnLeakRunListener\" } } In your test Application class: public class InstrumentationTestExampleApplication extends DebugExampleApplication { @Override protected void installLeakCanary () { InstrumentationLeakDetector . instrumentationRefWatcher ( this ) . buildAndInstall (); } }","title":"Before"},{"location":"upgrading-to-leakcanary-2.0/#now_4","text":"Remove all the previous test related leak detection code then follow Leak detection in UI tests .","title":"Now"},{"location":"upgrading-to-leakcanary-2.0/#analysis-listener-uploading-to-a-server","text":"","title":"Analysis listener / uploading to a server"},{"location":"upgrading-to-leakcanary-2.0/#before_5","text":"public class LeakUploadService extends DisplayLeakService { @Override protected void afterDefaultHandling ( HeapDump heapDump , AnalysisResult result , String leakInfo ) { // TODO Upload result to server } } RefWatcher refWatcher = LeakCanary . refWatcher ( this ) . listenerServiceClass ( LeakUploadService . class ) . buildAndInstall (); <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android= \"http://schemas.android.com/apk/res/android\" > <application android:name= \"com.example.DebugExampleApplication\" > <service android:name= \"com.example.LeakUploadService\" /> </application> </manifest>","title":"Before"},{"location":"upgrading-to-leakcanary-2.0/#now_5","text":"class LeakUploader : OnHeapAnalyzedListener { val defaultListener = DefaultOnHeapAnalyzedListener . create () override fun onHeapAnalyzed ( heapAnalysis : HeapAnalysis ) { TODO ( \"Upload heap analysis to server\" ) // Delegate to default behavior (notification and saving result) defaultListener . onHeapAnalyzed ( heapAnalysis ) } } class DebugExampleApplication : ExampleApplication () { override fun onCreate () { super . onCreate () LeakCanary . config = LeakCanary . config . copy ( onHeapAnalyzedListener = LeakUploader () ) } }","title":"Now"},{"location":"upgrading-to-leakcanary-2.0/#matching-known-library-leaks","text":"","title":"Matching known library leaks"},{"location":"upgrading-to-leakcanary-2.0/#before_6","text":"ExcludedRefs excludedRefs = AndroidExcludedRefs . createAppDefaults () . staticField ( \"com.samsing.SomeSingleton\" , \"sContext\" ) . build (); RefWatcher refWatcher = LeakCanary . refWatcher ( this ) . excludedRefs ( excludedRefs ) . buildAndInstall (); }","title":"Before"},{"location":"upgrading-to-leakcanary-2.0/#now_6","text":"LeakCanary . config = LeakCanary . config . copy ( referenceMatchers = AndroidReferenceMatchers . appDefaults + AndroidReferenceMatchers . staticFieldLeak ( \"com.samsing.SomeSingleton\" , \"sContext\" ) ) Info There is no equivalent API to ExcludedRefs.Builder.clazz() because it led to abuses. Instead see Ignoring specific activities or fragment classes .","title":"Now"},{"location":"upgrading-to-leakcanary-2.0/#public-api-packages","text":"","title":"Public API packages"},{"location":"upgrading-to-leakcanary-2.0/#before_7","text":"All public APIs were in com.squareup.leakcanary.*","title":"Before"},{"location":"upgrading-to-leakcanary-2.0/#now_7","text":"All public APIs are in leakcanary.*","title":"Now"},{"location":"uploading/","text":"Uploading analysis results \u00b6 You can add an EventListener to upload the analysis result to a server of your choosing: class DebugExampleApplication : ExampleApplication () { override fun onCreate () { super . onCreate () val analysisUploadListener = EventListener { event -> if ( event is HeapAnalysisSucceeded ) { val heapAnalysis = event . heapAnalysis TODO ( \"Upload heap analysis to server\" ) } } LeakCanary . config = LeakCanary . config . run { copy ( eventListeners = eventListeners + analysisUploadListener ) } } } Uploading to Bugsnag \u00b6 A leak trace has a lot in common with a stack trace, so if you lack the engineering resources to build a backend for LeakCanary, you can instead upload leak traces to a crash reporting backend. The client needs to support grouping via custom client-side hashing as well as custom metadata with support for newlines. Info As of this writing, the only known library suitable for uploading leaks is the Bugsnag client. If you managed to make it work with another library, please file an issue . Create a Bugsnag account , create a new project for leak reporting and grab an API key . Make sure the app has the android.permission.INTERNET permission then add the latest version of the Bugsnag Android client library to build.gradle : dependencies { // debugImplementation because LeakCanary should only run in debug builds. debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.10' debugImplementation \"com.bugsnag:bugsnag-android:$bugsnagVersion\" } Info If you\u2019re only using Bugsnag for uploading leaks, then you do not need to set up the Bugsnag Gradle plugin or to configure the API key in your app manifest. Create a new BugsnagLeakUploader : import android.app.Application import com.bugsnag.android.Bugsnag import com.bugsnag.android.Configuration import com.bugsnag.android.ErrorTypes import com.bugsnag.android.Event import com.bugsnag.android.ThreadSendPolicy import shark.HeapAnalysis import shark.HeapAnalysisFailure import shark.HeapAnalysisSuccess import shark.Leak import shark.LeakTrace import shark.LeakTraceReference import shark.LibraryLeak class BugsnagLeakUploader ( applicationContext : Application ) { private val bugsnagClient = Bugsnag . start ( applicationContext , Configuration ( \"YOUR_BUGSNAG_API_KEY\" ). apply { enabledErrorTypes = ErrorTypes ( anrs = false , ndkCrashes = false , unhandledExceptions = false , unhandledRejections = false ) sendThreads = ThreadSendPolicy . NEVER } ) fun upload ( heapAnalysis : HeapAnalysis ) { when ( heapAnalysis ) { is HeapAnalysisSuccess -> { val allLeakTraces = heapAnalysis . allLeaks . toList () . flatMap { leak -> leak . leakTraces . map { leakTrace -> leak to leakTrace } } if ( allLeakTraces . isEmpty ()) { // Track how often we perform a heap analysis that yields no result. bugsnagClient . notify ( NoLeakException ()) { event -> event . addHeapAnalysis ( heapAnalysis ) true } } else { allLeakTraces . forEach { ( leak , leakTrace ) -> val message = \"Memory leak: ${ leak . shortDescription } . See LEAK tab.\" val exception = leakTrace . asFakeException ( message ) bugsnagClient . notify ( exception ) { event -> event . addHeapAnalysis ( heapAnalysis ) event . addLeak ( leak ) event . addLeakTrace ( leakTrace ) event . groupingHash = leak . signature true } } } } is HeapAnalysisFailure -> { // Please file any reported failure to // https://github.com/square/leakcanary/issues bugsnagClient . notify ( heapAnalysis . exception ) } } } class NoLeakException : RuntimeException () private fun Event . addHeapAnalysis ( heapAnalysis : HeapAnalysisSuccess ) { addMetadata ( \"Leak\" , \"heapDumpPath\" , heapAnalysis . heapDumpFile . absolutePath ) heapAnalysis . metadata . forEach { ( key , value ) -> addMetadata ( \"Leak\" , key , value ) } addMetadata ( \"Leak\" , \"analysisDurationMs\" , heapAnalysis . analysisDurationMillis ) } private fun Event . addLeak ( leak : Leak ) { addMetadata ( \"Leak\" , \"libraryLeak\" , leak is LibraryLeak ) if ( leak is LibraryLeak ) { addMetadata ( \"Leak\" , \"libraryLeakPattern\" , leak . pattern . toString ()) addMetadata ( \"Leak\" , \"libraryLeakDescription\" , leak . description ) } } private fun Event . addLeakTrace ( leakTrace : LeakTrace ) { addMetadata ( \"Leak\" , \"retainedHeapByteSize\" , leakTrace . retainedHeapByteSize ) addMetadata ( \"Leak\" , \"signature\" , leakTrace . signature ) addMetadata ( \"Leak\" , \"leakTrace\" , leakTrace . toString ()) } private fun LeakTrace . asFakeException ( message : String ): RuntimeException { val exception = RuntimeException ( message ) val stackTrace = mutableListOf < StackTraceElement > () stackTrace . add ( StackTraceElement ( \"GcRoot\" , gcRootType . name , \"GcRoot.kt\" , 42 )) for ( cause in referencePath ) { stackTrace . add ( buildStackTraceElement ( cause )) } exception . stackTrace = stackTrace . toTypedArray () return exception } private fun buildStackTraceElement ( reference : LeakTraceReference ): StackTraceElement { val file = reference . owningClassName . substringAfterLast ( \".\" ) + \".kt\" return StackTraceElement ( reference . owningClassName , reference . referenceDisplayName , file , 42 ) } } Then add an EventListener to upload the analysis result to Bugsnag: class DebugExampleApplication : ExampleApplication () { override fun onCreate () { super . onCreate () LeakCanary . config = LeakCanary . config . copy ( onHeapAnalyzedListener = BugsnagLeakUploader ( applicationContext = this ) ) } } You should start seeing leaks reported into Bugsnag, grouped by their leak signature: The LEAK tab contains the leak trace:","title":"Uploading analysis results"},{"location":"uploading/#uploading-analysis-results","text":"You can add an EventListener to upload the analysis result to a server of your choosing: class DebugExampleApplication : ExampleApplication () { override fun onCreate () { super . onCreate () val analysisUploadListener = EventListener { event -> if ( event is HeapAnalysisSucceeded ) { val heapAnalysis = event . heapAnalysis TODO ( \"Upload heap analysis to server\" ) } } LeakCanary . config = LeakCanary . config . run { copy ( eventListeners = eventListeners + analysisUploadListener ) } } }","title":"Uploading analysis results"},{"location":"uploading/#uploading-to-bugsnag","text":"A leak trace has a lot in common with a stack trace, so if you lack the engineering resources to build a backend for LeakCanary, you can instead upload leak traces to a crash reporting backend. The client needs to support grouping via custom client-side hashing as well as custom metadata with support for newlines. Info As of this writing, the only known library suitable for uploading leaks is the Bugsnag client. If you managed to make it work with another library, please file an issue . Create a Bugsnag account , create a new project for leak reporting and grab an API key . Make sure the app has the android.permission.INTERNET permission then add the latest version of the Bugsnag Android client library to build.gradle : dependencies { // debugImplementation because LeakCanary should only run in debug builds. debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.10' debugImplementation \"com.bugsnag:bugsnag-android:$bugsnagVersion\" } Info If you\u2019re only using Bugsnag for uploading leaks, then you do not need to set up the Bugsnag Gradle plugin or to configure the API key in your app manifest. Create a new BugsnagLeakUploader : import android.app.Application import com.bugsnag.android.Bugsnag import com.bugsnag.android.Configuration import com.bugsnag.android.ErrorTypes import com.bugsnag.android.Event import com.bugsnag.android.ThreadSendPolicy import shark.HeapAnalysis import shark.HeapAnalysisFailure import shark.HeapAnalysisSuccess import shark.Leak import shark.LeakTrace import shark.LeakTraceReference import shark.LibraryLeak class BugsnagLeakUploader ( applicationContext : Application ) { private val bugsnagClient = Bugsnag . start ( applicationContext , Configuration ( \"YOUR_BUGSNAG_API_KEY\" ). apply { enabledErrorTypes = ErrorTypes ( anrs = false , ndkCrashes = false , unhandledExceptions = false , unhandledRejections = false ) sendThreads = ThreadSendPolicy . NEVER } ) fun upload ( heapAnalysis : HeapAnalysis ) { when ( heapAnalysis ) { is HeapAnalysisSuccess -> { val allLeakTraces = heapAnalysis . allLeaks . toList () . flatMap { leak -> leak . leakTraces . map { leakTrace -> leak to leakTrace } } if ( allLeakTraces . isEmpty ()) { // Track how often we perform a heap analysis that yields no result. bugsnagClient . notify ( NoLeakException ()) { event -> event . addHeapAnalysis ( heapAnalysis ) true } } else { allLeakTraces . forEach { ( leak , leakTrace ) -> val message = \"Memory leak: ${ leak . shortDescription } . See LEAK tab.\" val exception = leakTrace . asFakeException ( message ) bugsnagClient . notify ( exception ) { event -> event . addHeapAnalysis ( heapAnalysis ) event . addLeak ( leak ) event . addLeakTrace ( leakTrace ) event . groupingHash = leak . signature true } } } } is HeapAnalysisFailure -> { // Please file any reported failure to // https://github.com/square/leakcanary/issues bugsnagClient . notify ( heapAnalysis . exception ) } } } class NoLeakException : RuntimeException () private fun Event . addHeapAnalysis ( heapAnalysis : HeapAnalysisSuccess ) { addMetadata ( \"Leak\" , \"heapDumpPath\" , heapAnalysis . heapDumpFile . absolutePath ) heapAnalysis . metadata . forEach { ( key , value ) -> addMetadata ( \"Leak\" , key , value ) } addMetadata ( \"Leak\" , \"analysisDurationMs\" , heapAnalysis . analysisDurationMillis ) } private fun Event . addLeak ( leak : Leak ) { addMetadata ( \"Leak\" , \"libraryLeak\" , leak is LibraryLeak ) if ( leak is LibraryLeak ) { addMetadata ( \"Leak\" , \"libraryLeakPattern\" , leak . pattern . toString ()) addMetadata ( \"Leak\" , \"libraryLeakDescription\" , leak . description ) } } private fun Event . addLeakTrace ( leakTrace : LeakTrace ) { addMetadata ( \"Leak\" , \"retainedHeapByteSize\" , leakTrace . retainedHeapByteSize ) addMetadata ( \"Leak\" , \"signature\" , leakTrace . signature ) addMetadata ( \"Leak\" , \"leakTrace\" , leakTrace . toString ()) } private fun LeakTrace . asFakeException ( message : String ): RuntimeException { val exception = RuntimeException ( message ) val stackTrace = mutableListOf < StackTraceElement > () stackTrace . add ( StackTraceElement ( \"GcRoot\" , gcRootType . name , \"GcRoot.kt\" , 42 )) for ( cause in referencePath ) { stackTrace . add ( buildStackTraceElement ( cause )) } exception . stackTrace = stackTrace . toTypedArray () return exception } private fun buildStackTraceElement ( reference : LeakTraceReference ): StackTraceElement { val file = reference . owningClassName . substringAfterLast ( \".\" ) + \".kt\" return StackTraceElement ( reference . owningClassName , reference . referenceDisplayName , file , 42 ) } } Then add an EventListener to upload the analysis result to Bugsnag: class DebugExampleApplication : ExampleApplication () { override fun onCreate () { super . onCreate () LeakCanary . config = LeakCanary . config . copy ( onHeapAnalyzedListener = BugsnagLeakUploader ( applicationContext = this ) ) } } You should start seeing leaks reported into Bugsnag, grouped by their leak signature: The LEAK tab contains the leak trace:","title":"Uploading to Bugsnag"},{"location":"snippets/bugsnag-uploader/","text":"import android.app.Application import com.bugsnag.android.Bugsnag import com.bugsnag.android.Configuration import com.bugsnag.android.ErrorTypes import com.bugsnag.android.Event import com.bugsnag.android.ThreadSendPolicy import shark.HeapAnalysis import shark.HeapAnalysisFailure import shark.HeapAnalysisSuccess import shark.Leak import shark.LeakTrace import shark.LeakTraceReference import shark.LibraryLeak class BugsnagLeakUploader ( applicationContext : Application ) { private val bugsnagClient = Bugsnag . start ( applicationContext , Configuration ( \"YOUR_BUGSNAG_API_KEY\" ). apply { enabledErrorTypes = ErrorTypes ( anrs = false , ndkCrashes = false , unhandledExceptions = false , unhandledRejections = false ) sendThreads = ThreadSendPolicy . NEVER } ) fun upload ( heapAnalysis : HeapAnalysis ) { when ( heapAnalysis ) { is HeapAnalysisSuccess -> { val allLeakTraces = heapAnalysis . allLeaks . toList () . flatMap { leak -> leak . leakTraces . map { leakTrace -> leak to leakTrace } } if ( allLeakTraces . isEmpty ()) { // Track how often we perform a heap analysis that yields no result. bugsnagClient . notify ( NoLeakException ()) { event -> event . addHeapAnalysis ( heapAnalysis ) true } } else { allLeakTraces . forEach { ( leak , leakTrace ) -> val message = \"Memory leak: ${ leak . shortDescription } . See LEAK tab.\" val exception = leakTrace . asFakeException ( message ) bugsnagClient . notify ( exception ) { event -> event . addHeapAnalysis ( heapAnalysis ) event . addLeak ( leak ) event . addLeakTrace ( leakTrace ) event . groupingHash = leak . signature true } } } } is HeapAnalysisFailure -> { // Please file any reported failure to // https://github.com/square/leakcanary/issues bugsnagClient . notify ( heapAnalysis . exception ) } } } class NoLeakException : RuntimeException () private fun Event . addHeapAnalysis ( heapAnalysis : HeapAnalysisSuccess ) { addMetadata ( \"Leak\" , \"heapDumpPath\" , heapAnalysis . heapDumpFile . absolutePath ) heapAnalysis . metadata . forEach { ( key , value ) -> addMetadata ( \"Leak\" , key , value ) } addMetadata ( \"Leak\" , \"analysisDurationMs\" , heapAnalysis . analysisDurationMillis ) } private fun Event . addLeak ( leak : Leak ) { addMetadata ( \"Leak\" , \"libraryLeak\" , leak is LibraryLeak ) if ( leak is LibraryLeak ) { addMetadata ( \"Leak\" , \"libraryLeakPattern\" , leak . pattern . toString ()) addMetadata ( \"Leak\" , \"libraryLeakDescription\" , leak . description ) } } private fun Event . addLeakTrace ( leakTrace : LeakTrace ) { addMetadata ( \"Leak\" , \"retainedHeapByteSize\" , leakTrace . retainedHeapByteSize ) addMetadata ( \"Leak\" , \"signature\" , leakTrace . signature ) addMetadata ( \"Leak\" , \"leakTrace\" , leakTrace . toString ()) } private fun LeakTrace . asFakeException ( message : String ): RuntimeException { val exception = RuntimeException ( message ) val stackTrace = mutableListOf < StackTraceElement > () stackTrace . add ( StackTraceElement ( \"GcRoot\" , gcRootType . name , \"GcRoot.kt\" , 42 )) for ( cause in referencePath ) { stackTrace . add ( buildStackTraceElement ( cause )) } exception . stackTrace = stackTrace . toTypedArray () return exception } private fun buildStackTraceElement ( reference : LeakTraceReference ): StackTraceElement { val file = reference . owningClassName . substringAfterLast ( \".\" ) + \".kt\" return StackTraceElement ( reference . owningClassName , reference . referenceDisplayName , file , 42 ) } }","title":"Bugsnag uploader"}]}